###############################################################################
# Copyright (c) 2003, 2010 IBM Corporation and others.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     IBM Corporation - initial API and implementation
#     E.D.Willink - Bugs 176110, 191689 
#     Borland - Bug 242880
# 
# $Id: OCLMessages.properties,v 1.16 2010/12/09 17:16:24 ewillink Exp $
#
###############################################################################

# ==============================================================================
# Translation Instruction: section to be translated
# 
# Error messages from the OCL parser/interpreter.
# ==============================================================================

# Message that is substituted for an exception that otherwise does not have one.
# Tells the user that we don't know what happened.
no_message = (no message)

# Error indicating a failure in reading an OCL document.
# args:
#   0 - synopsis of the problem
#
Input_ERROR_ = Error reading OCL input: {0}

# Error indicating that an environment registry extension is missing
# the required class name attribute.
# args:
#   0 - the extension ID, if available
EnvRegistry_missingClass_ERROR_ = Missing class name in environment registry extension (ID {0})

# Error indicating that an environment registry extension is missing
# the required package namespace URI attribute.
# args:
#   0 - the extension ID, if available
EnvRegistry_missingNsURI_ERROR_ = Missing package namespace URI in environment registry extension (ID {0})

# Error indicating that an environment registry extension has an
# unknown element specified.
# args:
#   0 - the extension ID, if available
#   1 - the offending element name
EnvRegistry_unknownElement_ERROR_ = Unknown element "{1}" in environment registry extension (ID {0})

# ==============================================================================
# Translation Instruction: section to be translated
# 
# Error messages from the OCL parser/interpreter.
# ==============================================================================

#
# Indicates that a value is already bound to a name in the evaluation environment.
# args:
#   0 - the name of the variable
#   1 - the value already bound to it
#
BindingExist_ERROR_ = The name: ({0})  already has a binding: ({1})

#
# Indicates that an operation lookup on a classifier failed during evaluation of
# an OCL expression.
# args:
#   0 - the operation name that could not be found
#
UnknownOperation_ERROR_ = Unknown operation for type:  ({0})

#
# Indicates that the named iterator expression is recognized by the parser
# but is not supported by the interpreter.
# args:
#   0 - the iterator name
#
IteratorNotImpl_ERROR_ = Iterator ({0}) not yet implemented.

#
# Indicates attempt to access an index in an integer range, that falls outside of the range.
# args:
#   0 - the index that was attempted
#   1 - the lower bound of the range
#   2 - the upper bound of the range
#
IndexOutOfRange_ERROR_ = Index ({0}) not in range ({1})..({2})

#
# Indicates attempt to navigate a property of a tuple that is not defined by the tuple type.
# args:
#   0 - the name of the missing tuple property
#
TupleFieldDoesntExist_ERROR_ = Cannot find tuple property ({0})

#
# Indicates that a property call expression is missing the reference to the called property.
# args:
#   0 - the text of the property call expression
#
NullProperty_ERROR_ = Null referred property in property call ({0})

#
# Indicates that the source expression of a navigation call expression is missing.
# args:
#   0 - the text of the navigation call expression
#
NullNavigationSource_ERROR_ = Null source in navigation expression ({0})

#
# Indicates that the result type of a navigation call expression is missing.
# args:
#   0 - the text of the navigation call expression
#
NullNavigationType_ERROR_ = Null type in navigation expression ({0})

#
# Indicates that an operation call expression is missing the reference to the called operation.
# args:
#   0 - the text of the operation call expression
#
NullOperation_ERROR_ = Null operation in operation call ({0})

#
# Indicates that the source expression of an operation call expression is missing.
# args:
#   0 - the text of the operation call expression
#
NullSourceOperation_ERROR_ = Null source in operation call ({0})

#
# Indicates that an operation call expression references an operation that does
# not exist in the source type or does not conform to the arguments.
# args:
#   0 - the text of the operation call expression
#
IllegalOperation_ERROR_ = Illegal operation ({0})

#
# Indicates that an operation call expression references an operation that is
# not a "query" (side-effect-free).
# args:
#   0 - the operation name
#
NonQueryOperation_ERROR_ = Cannot call operation ({0}) because it is not a query

#
# Indicates that the operation code referenced by an operation call expression
# does not match the internal code for the OCL pre-defined operation.
# args:
#   0 - the name of the OCL standard operation
#
IllegalOpcode_ERROR_ = Illegal opcode for ({0})

#
# Indicates that the return type of the operation referenced by an operation call
# expression differs from the result type of the expression.
# args:
#   0 - the type of the operation call expression
#
TypeConformanceOperation_ERROR_ = Operation return type does not match operation call expression type ({0})

#
# Indicates that the enumeration literal referenced by an enumeration literal
# expression belongs to a different enumeration than the expression's type.
# args:
#   0 - the name of the enumeration literal
#
IllegalEnumLiteral_ERROR_ = Illegal enumeration literal: ({0})

#
# Indicates that the variable referenced by a variable expression is of a different
# type than the expression.
# args:
#   0 - the name of the variable
#
VariableTypeMismatch_ERROR_= The type of a variable expression must match the type of the variable ({0}).

#
# Indicates that a variable declaration is missing the variable name.
#
MissingNameInVariableDeclaration_ERROR_= Missing Name in variable declaration.

#
# Indicates that a variable initialization expression does not match the variable type.
# args:
#   0 - the name of the variable
#
TypeConformanceInit_ERROR_= Init expression type does not conform to type of variable ({0}).

#
# Indicates that the condition of an 'if' expression does not result in a boolean value.
# args:
#   0 - the text of the condition expression
#
NonBooleanIfExp_ERROR_= If expression condition must be boolean-valued: ({0})

#
# Indicates that the 'then' and 'else' expressions in an 'if' expression do not
# conform to the type of the overall 'if' expression.
# args:
#   0 - the text of the complete 'if' expression
#
TypeConformanceIfExp_ERROR_= If expression type is not equal to common super type of then and else part types: ({0})

#
# Indicates that an integer literal expression type is not Integer.
#
TypeConformanceIntegerLiteral_ERROR_= Integer literal expression must be of type Integer.

#
# Indicates that an unlimited natural literal expression type is not UnlimitedNatural.
#
TypeConformanceUnlimitedNaturalLiteral_ERROR_= Unlimited natural literal expression must be of type UnlimitedNatural.

#
# Indicates that a real literal expression type is not Real.
#
TypeConformanceRealLiteral_ERROR_= Real literal expression must be of type Real.

#
# Indicates that a string literal expression type is not String.
#
TypeConformanceStringLiteral_ERROR_= String literal expression must be of type String.

#
# Indicates that a boolean literal expression type is not Boolean.
#
TypeConformanceBooleanLiteral_ERROR_= Boolean literal expression must be of type Boolean.

#
# Indicates that a null literal expression type is not OclVoid.
#
TypeConformanceNullLiteral_ERROR_= Null literal expression must be of type OclVoid.

#
# Indicates that an OclInvalid literal expression type is not Invalid.
#
TypeConformanceInvalidLiteral_ERROR_= OclInvalid literal expression must be of type Invalid.

#
# Indicates that the 'in' expression type of a 'let' expression does not match
# the type of the overall 'let' expression.
# args:
#   0 - the 'let' expression type
#   1 - the 'in' expression type
#
TypeConformanceLetExp_ERROR_= Let expression type conformance error: ({0}) != ({1})

#
# Indicates that the result variable of an 'iterate' expression has a different
# type from the expression as a whole.
# args:
#   0 - the text of the complete iterate expression
#
TypeConformanceIterateExp_ERROR_= Iterate expression type must be the same as result variable type ({0})

#
# Indicates that the body of an 'iterate' expression does not conform to the result variable type.
# args:
#   0 - the text of the complete iterate expression
#
TypeConformanceIterateExpBody_ERROR_= Iterate expression body type must conform to the result type ({0})

#
# Indicates that the iteration variable of an 'iterate' expression has a different
# type from the source collection's element type.
# args:
#   0 - the text of the complete iterate expression
#
TypeConformanceIterateExpLoopVar_ERROR_= Iterate expression iterator variable must have same type as source element type ({0})

#
# Indicates that the result type of a 'forAll', 'exists', or 'isUnique' iterator
# is not Boolean.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceIteratorResult_ERROR_= Iterator result type must be boolean ({0})

#
# Indicates that the iterator variable of an iterator expression has a different
# type from the source collection's element type.  Note that iterator expressions
# are different from 'iterate' expressions.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceIteratorExpLoopVar_ERROR_= Iterator variable must have same type as source element type ({0})

#
# Indicates that the result type of a 'collect', iterator on a sequence or an
# ordered set is not a sequence.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceCollectSequence_ERROR_= Collect type must be sequence ({0})

#
# Indicates that the result type of a 'collect' iterator on a set or a bag is
# not a bag.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceCollectBag_ERROR_= Collect type must be bag ({0})

#
# Indicates that the result type of a 'closure' iterator is not a set.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceClosure_ERROR_= Closure type must be Set ({0})

#
# Indicates that the body expression of a 'closure' iterator does not conform
# to the element type of the source collection, so that recursive evaluation of
# the body is invalid.
# args:
#   0 - the type of the body expression
#   1 - the element type of the source collection
#
ElementTypeConformanceClosure_ERROR_= Closure type ({0}) does not conform to source type ({1})

#
# Indicates that the result type of a 'select' or 'reject' iterator differs
# from the source collection type.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceSelectReject_ERROR_= Select/reject type must be the same as the source type ({0})

#
# Indicates that the body expression of a 'forAll', 'exists', 'any', 'select', 'reject', or 'one'
# iterator is not Boolean.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceIteratorBodyBoolean_ERROR_= Iterate Expression body type must be boolean ({0})

#
# Indicates that the type of a collection literal expression is not a collection type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceCollectionLiteralExp_ERROR_= Missing or Illegal Type in Collection Literal Expression: ({0})

#
# Indicates that the type of a set literal expression is not a set type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceSetLiteral_ERROR_= Set literal must have SetType: ({0})

#
# Indicates that the type of an ordered set literal expression is not an ordered set type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceOrderedSetLiteral_ERROR_= Ordered set literal must have OrderedSetType: ({0})

#
# Indicates that the type of a bag literal expression is not a bag type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceBagLiteral_ERROR_= Bag literal must have BagType: ({0})

#
# Indicates that the type of a sequence literal expression is not a sequence type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceSequenceLiteral_ERROR_= Sequence literal must have SequenceType: ({0})

#
# Indicates that the element type of an empty collection literal is not Classifier.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceEmptyCollection_ERROR_= Empty collection must have element type OclVoid: ({0})

#
# Indicates that the type of a collection literal expression differs from the
# common supertype of the types of the literal parts.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceCollectionElementType_ERROR_= Collection element type does not match the supertype of the element types: ({0})

#
# Indicates that the type of a tuple literal expression is not a Tuple type.
# args:
#   0 - the text of the complete tuple literal
#
TypeConformanceTupleLiteralExp_ERROR_= Tuple literal expression must be of type Tuple: ({0}).

#
# Indicates that the number of parts of a tuple literal expression does not match
# the number of properties of the tuple type.
# args:
#   0 - the text of the complete tuple literal
#
TypeConformanceTupleLiteralExpParts_ERROR_= The tuple literal expression parts do not match the tuple type: ({0})

#
# Indicates that a tuple literal part did not match any property of the tuple type.
# args:
#   0 - the name of the tuple literal part
#   1 - the text of the complete tuple literal
#
TupleLiteralExpressionPart_ERROR_= Property ({0}) not found in tuple type: ({1})

#
# Indicates that a tuple literal includes two or more parts of the same name.
# args:
#   0 - the duplicate tuple literal part name
#   1 - the text of the complete tuple literal
#
TupleDuplicateName_ERROR_= Duplicate part name ({0}) in tuple literal: ({1})

#
# Indicates that a tuple literal part is missing the reference to the corresponding
# property of the tuple type.
# args:
#   0 - the tuple literal part name
#   1 - the text of the complete tuple literal
#
MissingPropertyInTupleLiteralPart_ERROR_= Tuple literal part ({0}) missing property reference: ({1})

#
# Indicates that a tuple literal part is missing the reference to the type of its value.
# args:
#   0 - the tuple literal part name
#   1 - the text of the complete tuple literal
#
MissingTypeInTupleLiteralPart_ERROR_= Tuple literal part ({0}) missing type reference: ({1})

#
# Indicates that a tuple literal part type differs from the type of the corresponing
# property of the tuple type.
# args:
#   0 - the tuple literal part name
#   1 - the text of the complete tuple literal
#
TuplePartType_ERROR_= Tuple literal part ({0}) type does not match property type: ({1})

#
# Indicates that a tuple literal part's value expression is not compatible with
# the type of the corresponding property in the tuple type.
# args:
#   0 - the tuple literal part name
#   1 - the text of the complete tuple literal
#
TypeConformanceTuplePartValue_ERROR_= Tuple literal part ({0}) value does not conform to tuple property type: ({1})


#
# Indicates that a type expression was found to have a type that is not a
# TypeType (i.e., the metatype for OCL types).
# args:
#   0 - the name of the type that was found
#
TypeConformanceTypeExp_ERROR_= Type of type expression must be TypeType: ({0})

#
# Indicates that a type expression was found to no reference to a type.
# args:
#   0 - the complete text of the type expression
#
TypeExpMissingType_ERROR_= Missing referred type in type expression: ({0})


#
# Indicates that an operation signature could not be resolved in the source
# expression type (i.e., expression on whose result the operation is invoked).
# args:
#   0 - the operation signature (including the name and parameter types)
#
IllegalSignature_ERROR_= illegal operation signature: ({0})


#
# Indicates that an 'iterate' or iterator expression was found whose source was
# not a collection type.
# args:
#   0 - the complete text of the iteration expression
#
IteratorSource_ERROR_= The source of an iterator must be a collection ({0})

#
# Indicates that an iterator variable in an 'iterate' or iterator expression
# is declared with an initial value.
# args:
#   0 - the complete text of the iteration expression
#
IterateExpLoopVarInit_ERROR_= Iteration expression iterator variable may not be initialized: ({0})

#
# Indicates that an iterator expression has more iterator variable than are,
# permitted for the particular iterator kind.
# args:
#   0 - the iterator name
#
TooManyIteratorVariables_ERROR_= {0} iterator has too many iterator variables

#
# Indicates that a variable expression was found that either does not reference
# a declared variable or references a variable that is not completely declared
# (i.e., either has no name or has no type).
# args:
#   0 - the complete text of the variable expression
#
IncompleteVariableExp_ERROR_ = Incomplete reference to variable declaration in variable expression: ({0})

#
# Indicates that a let expression was found that is missing any one of the
# variable declaration, type, or in expression.
# args:
#   0 - the complete text of the let expression
#
IncompleteLetExp_ERROR_ = Incomplete let expression: ({0})

#
# Indicates that an 'iterate' expression was found that is missing any one of
# its mandatory parts:  source expression, result variable, iterator variables,
# body, or type reference.
# args:
#   0 - the complete text of the iterate expression
#
IncompleteIterateExp_ERROR_ = Incomplete iterate expression: ({0})

#
# Indicates that an 'if' expression was found that is missing its 'if', 'then',
# or 'else' part.
# args:
#   0 - the complete text of the 'if' expression
#
IncompleteIfExp_ERROR_= Incomplete if expression: ({0})

#
# Indicates that an iterator expression was found that is missing any one of its
# mandatory pats:  source expression, iterator name, iterator variables, body,
# or type reference.
# args:
#   0 - the complete text of the iterator expression
#
IncompleteIteratorExp_ERROR_= Incomplete iterator expression: ({0})

#
# Indicates that the result (accumulator) variable of an 'iterate' expression
# does not specify an initial value.
# args:
#   0 - the complete text of the 'iterate' expression
#
MissingInitIterateExp_ERROR_ = Iterate expression result must have an init expression: ({0})


#
# Message pattern for the error messages reported by the parser.
# args:
#   0 - the syntax rule name in which the problem was found
#   1 - the error messages describing the problem (usually derived from one
#       of the other messages in this file)
#
ErrorMessage_ERROR_ = ERROR in ({0}): ({1})

#
# Message pattern for the problem messages reported by the problem handler.
# args:
#   0 - the processing phase in which the problem was found
#   1 - the problem severity
#   2 - the syntax rule name in which the problem was found
#   3 - the line number at which the problem was found
#   4 - the error messages describing the problem (usually derived from one
#       of the other messages in this file)
#
ProblemMessage_ERROR_ = {0}-{1} in {2}; {3} : {4}

Severity_Cancel = CANCEL
Severity_Fatal_Error = FATAL-ERROR
Severity_Error = ERROR
Severity_Warning = WARNING
Severity_Info = INFO
Severity_OK = OK

Phase_Parser = Parser
Phase_Unparser = Unparser
Phase_Lexer = Lexer
Phase_Analyzer = Analyzer
Phase_Validator = Validator
Phase_Utility = Utility

#
# Indicates that an OCL expression attempts to declare a variable name that
# is already defined in the current environment.
# args:
#   0 - the variable name
#
VariableUsed_ERROR_ = Variable name already used: ({0})

#
# Indicates that, for some unknown reason, a variable could not be added to the
# current environment.
#
VariableDeclaration_ERROR_ = Variable declaration failed

#
# Indicates that the operation referenced by an operation call expression could
# not be found in the type on which the operation is called.
# args:
#   0 - the signature of the operation (including name and parameter types)
#   1 - the name of the type on which the operation was called
#
OperationNotFound_ERROR_ = Cannot find operation ({0}) for the type ({1})

#
# Indicates that an argument is missing in an operation call expression.
#
BadArg_ERROR_ = Missing argument expression

#
# Indicates that the package referenced by a package context declaration could
# not be found.
# args:
#   0 - the qualified package name
#
PackageNotFound_ERROR_ = Unable to find package: ({0})

#
# Indicates that the context classifier, operation, or property of a constraint
# expression could not be found.
# args:
#   0 - the qualified context classifier/operation/property name
#
UnrecognizedContext_ERROR_ = Unrecognized context: ({0})

#
# Indicates that an attempt was made to define too many constraints in the same
# property context.
# args:
#   0 - the qualified context property name
#
PropertyConstraints_ERROR_ = Property context may define at most one init and one derive expression: ({0})


#
# Indicates that an 'if' expression has a non-boolean condition part.
# args:
#   0 - the complete text of the condition expression
#
BooleanForIf_ERROR_ = Expected boolean condition for if expression: ({0})

#
# Indicates that a navigation expression is attempting to navigating to a
# variable rather than a property of the source expression type.
# args:
#   0 - the name of the variable
#
VarInNavExp_ERROR_ = Cannot navigate to a variable in a navigation expression: ({0})

#
# Indicates that a referenced variable name does not correspond to any known
# variable declaration or model property.
# args:
#   0 - the referenced variable name
#
UnrecognizedVar_ERROR_ = Unrecognized variable: ({0})

#
# Indicates that, in the context in which it appears, a variable declaration
# must include the type.
# args:
#   0 - the variable name
#
DeclarationType_ERROR_ = Declaration of ({0}) must have a type

#
# Indicates that, in the context in which it appears, a variable declaration
# must include an initial value.
# args:
#   0 - the variable name
#
DeclarationNoInitExp_ERROR_ = Declaration of ({0}) must have an initial expression

#
# Indicates that, in the context in which it appears, a variable declaration
# must not include an initial value.
# args:
#   0 - the variable name
#
DeclarationInitExp_ERROR_ = Declaration of ({0}) must not have an initial expression

#
# Indicates that a type expression referenced a type that could not be found
# in the current environment.
# args:
#   0 - the qualified name of the type
#
UnrecognizedType_ERROR_ = Unknown type ({0})


#
# Indicates that the same name is used for two or more parts in a tuple expression.
# args:
#   0 - the duplicated tuple part name
#
DuplicateNameInTuple_ERROR_ = Duplicate part name in tuple: ({0})

#
# Indicates an attempt to assign an initial value to a tuple part in a tuple
# type.
# args:
#   0 - the name of the tuple part in question
#
InitExpNotAllowed_ERROR_ = Initialize expressions not allowed in tuple types: ({0})

#
# Indicates a reference to an enumeration literal that is not defined in the
# containing enumeration.
# args:
#   0 - the enumeration literal name
#
UnrecognizedEnum_ERROR_ = Unknown enumeration literal ({0})

#
# Indicates that the first and last types do not match in a range literal.
# args:
#   0 - the complete text of the range expression
#
FirstLastTypeMismatch_ERROR_ = First and last type mismatch: ({0})


#
# Indicates an attempt to evaluate a Query on a null context where an object
# was expected.
#
NullArgExpectEObj_ERROR_ = Argument is null, expected an Object

#
# Indicates an attempt to evaluate a Query on a null context where a list of
# objects was expected.
#
NullArgExpectlist_ERROR_ = Argument is null, expected a List.

#
# Indicates an attempt to check a Query with a non-boolean constraint expression.
#
BooleanQuery_ERROR_ = Query must be a boolean-valued constraint.

#
# Indicates that evaluation of an OCL expression failed with a run-time exception.
# args:
#   0 - the exception's localized message
#
EvaluationFailed_ERROR_ = Evaluation failed with an exception: {0}

#
# Indicates that the argument to an operation call is of an incompatible type.
# args:
#   0 - the type that defines the operation
#   1 - the name of the operation
#
Noncomforming_ERROR_ = Nonconforming arguments for type ({0}) and operation ({1})

#
# Indicates an attempt to call "<", "<=", ">", or ">=" on a type that does not
# provide any of the supported mechanisms for object comparison.
# args:
#   0 - the comparison operation in question
#
SourceEClass_ERROR_ = Source of operation ({0}) must implement Comparable

#
# Indicates an attempt to call "<", "<=", ">", or ">=" on a type that does not
# provide any of the supported mechanisms for object comparison.
# args:
#   0 - the comparison operation in question
#
SourceOperationCompareTo_ERROR_ = Source of operation ({0}) must define a compatible compareTo or {0} operation

#
# Indicates an incompatible signature for the "compareTo" operation.
#
ResultCompareToInt_ERROR_ = The result of the compareTo operation must be Integer

#
# Indicates that, in a context requiring conformance of declared types, two types
# are not compatible.
# args:
#   0 - name of one of the types
#   1 - name of the other type
#
TypeMismatch_ERROR_ = Type mismatch. No common supertype: ({0}), ({1})

#
# Indicates an attempt to cast one type to another to which it does not conform.
# args:
#   0 - the type being cast
#   1 - the target type, to which the first does not conform
#
CastTypeMismatch_ERROR_ = Invalid cast. ({0}) does not conform to ({1})

#
# Indicates attempt to call an operation not defined by the source collection.
# args:
#   0 - the name of the collection type
#   1 - the operation called
#
CollectionType_ERROR_ = Undefined operation ({1}) for collection type ({0}) 

#
# Indicates an attempt to apply the sum operation to a non-numeric collection.
#
SumOperator_ERROR_= Collection sum operation only applies to numeric types

#
# Indicates mismatch of (non-conformant) tuple types.
# args:
#   0 - one tuple type
#   1 - the other tuple type
#
TupleTypeMismatch_ERROR_= Tuple type mismatch: ({0}), ({1})

#
# Indicates mismatch of (non-conformant) tuple types due to one not defining
# a part defined by the other.
# args:
#   0 - one tuple type
#   1 - name of the the part defined by the first that the second is missing
#   2 - the other tuple type
#
TupleFieldNotFound_ERROR_= Tuple type mismatch. Tuple part ({1}) of ({0}) not found in ({2})

#
# Indicates mismatch of (non-conformant) tuple types due the two defining a
# different number of parts.
# args:
#   0 - one tuple type
#   1 - the other tuple type
#
TupleFieldNumMismatch_ERROR_= Tuple type mismatch. Different number of parts: ({0}) ({1})

#
# Indicates attempt to mutate an OCL collection by invoking remove() on its iterator.
#
RemoveUnsupported_ERROR_= Remove not supported by OCL collections

#
# Indicates an attempt to construct an unsupported (not OCL) collection type.
# args:
#   0 - the integer-valued collection kind code
#
OCLCollectionKindNotImpl_ERROR_ = OCL collection kind ({0}) is not implemented in the java collection factory.


#
# Indicates invalid usage of the OCL-defined oclIsInState() operation.
# args:
#   0 - the complete text of the operation call expression
#
IsInStateSignature_ERROR_= oclIsInState() must have a single State argument: ({0})

#
# Indicates reference to a state that does not exist in the source of the
# oclIsInState() call.
# args:
#   0 - qualified name of the state that was referenced
#   1 - the source type of the oclIsInState() call
#
NoSuchState_ERROR_= No such state ({0}) in type ({1})

#
# Indicates ambiguous reference to a state in the oclIsInState() call, in the
# case that two or more states in different state machines have the same name
# but the reference was not qualified by the state machine name.
# args:
#   0 - qualified name of the state that was referenced
#   1 - the source type of the oclIsInState() call
#
AmbiguousState_ERROR_= Ambiguous reference to state ({0}) in type ({1})

#
# Indicates that a state expression does not have a reference to the state.
# args:
#   0 - the complete text of the state expression
#
MissingStateInStateExp_ERROR_= Missing referredState in StateExp: ({0})

#
# Indicates that a message expression's signature does not correspond to any
# known operation or signal in the target type.
# args:
#   0 - the operation or signal name
#
UnrecognizedMessageType_ERROR_= Unrecognized operation or signal ({0}) in message expression

#
# Indicates that a message expression's signature matches both an operation and
# a signal.
# args:
#   0 - the name of the operation or signal
#
AmbiguousMessageType_ERROR_= Ambiguous message expression: ({0}) could be an operation or a signal

#
# Indicates attempt to use an unspecified value expression outside of the context
# of a message expression.
# args:
#   0 - the complete text of the unspecified value expression
#
IllegalUnspecifiedValueExp_ERROR_= Unspecified values may only be used in message expressions: ({0})

#
# Indicates that a message expression does not have a target expression.
# args:
#   0 - the complete text of the message expression
#
MissingMessageTarget_ERROR_= Missing target in message expression: ({0})s

#
# Indicates that an operation call action in a message expression does not have
# a reference to the called operation.
# args:
#   0 - the complete text of the message expression
#
MissingOperationInCallAction_ERROR_= Missing operation in CallOperationAction: ({0})

#
# Indicates that a signal send action in a message expression does not have
# a reference to the sent signal.
# args:
#   0 - the complete text of the message expression
#
MissingSignalInCallAction_ERROR_= Missing signal in SendSignalAction: ({0})

#
# Indicates that a message expression has the wrong number of arguments for the
# message type (the called operation or sent signal).
# args:
#   0 - the name of the message type
#
MessageArgumentCount_ERROR_= Wrong number of arguments for message type ({0})

#
# Indicates a type mismatch between a message argument in a message expression
# and the corresponding operation parameter or signal property.
# args:
#   0 - the name of the operation parameter or signal property
#   1 - the complete text of the argument expression
#
MessageArgConformance_ERROR_= Argument ({1}) does not conform to parameter ({0}) of message


#
# Indicates that a "def" expression does not reference the feature
# that it defines.
# args:
#   0 - the name of the context classifier that of the definition expression
#
DefinitionConstraintFeature_ERROR_= Unknown defined feature in definition constraint of {0}

#
# Indicates a type mismatch between the declared type of a feature in a "def"
# expression and the expression that specifies its value.
# args:
#   0 - the type of the value expression
#   1 - the declared type of the feature (operation or property)
#
DefinitionConstraintConformance_ERROR_= Def expression type ({0}) does not conform to defined feature type ({1})

#
# Indicates an attempt to define (using a "def" expression) a property that
# already exists in the context classifier.
# args:
#   0 - the name of the property
#   1 - the context classifier name
#
DuplicateProperty_ERROR_= Property ({0}) already defined in type ({1})

#
# Indicates an attempt to define (using a "def" expression) a feature as static
# when the SUPPORT_STATIC_FEATURES ParsingOptions is set false.
# args:
#
UnsupportedStatic_ERROR_= Support for static features has not been enabled

#
# Indicates an attempt to define (using a "def" expression) a feature as static
# when the meta-model (Ecore) does not support static features.
# args:
#
UnimplementedStatic_ERROR_= This meta-model does not support static features

#
# Indicates tan attempt to define (using a "def" expression) an operation that
# already exists in the context classifier.
# args:
#   0 - the complete text of the message expression
#
DuplicateOperation_ERROR_= Operation ({0}) already defined in type ({1})

#
# Indicates a type mismatch between the declared type of the context property
# in an "init" or "derive" expression and the property's declared type.
# args:
#   0 - the type of the value expression
#   1 - the context property name
#   2 - the declared type of the property
#
InitOrDerConstraintConformance_ERROR_= Initial or derived value expression type ({0}) does not conform to property "{1}" type ({2})


#
# Indicates attempt to use the @pre modifier on expressions that are not feature calls.
#
IllegalAtPre_ERROR_ = @pre may only be applied to feature calls

#
# Indicates attempt to use the @pre modifier in a non-postcondition context.
#
AtPreInPostcondition_ERROR_ = @pre may only be used in an operation postcondition constraint

#
# Indicates attempt to specify a body condition for an operation that has no
# value.
# args:
#   0 - the operation name
#
BodyConditionNotAllowed_ERROR_ = Cannot specify body condition for void operation "{0}"

#
# Indicates a type mismatch between the declared result type of an operation
# and the body expression.
# args:
#   0 - the operation name
#   0 - the type of the body expression
#   1 - the declared result type of the operation
#
BodyConditionConformance_ERROR_ = Body condition does not conform to result type of operation "{0}": ({1}), ({2})

#
# Indicates attempt to use the oclIsNew() operation in a non-postcondition context.
#
OCLIsNewInPostcondition_ERROR_ = oclIsNew() may only be called in an operation postcondition constraint

#
# Indicates attempt to apply navigation qualifiers to a non-navigation expression.
# args:
#   0 - the complete text of qualified expression
#
IllegalQualifiers_ERROR_ = Qualifiers may only be applied to navigation calls: ({0})

#
# Indicates attempt to specify the wrong number of qualifiers (if any) or
# qualifiers of the wrong types or order in a navigation expression.
# args:
#   0 - the complete text of qualified expression
#
MismatchedQualifiers_ERROR_ = Qualifiers do not conform to expected types: ({0})

#
# Indicates that an association class call expression is missing the reference to
# the association class.
# args:
#   0 - the complete text of association class call expression
#
MissingAssociationClass_ERROR_ = Missing AssociationClass in association class call: ({0})

#
# Indicates attempt to specify more than one qualifier in an association class
# call expression.
# args:
#   0 - the complete text of association class call expression
#
AssociationClassQualifierCount_ERROR_ = Cannot have more than one qualifier role on association class navigation: ({0})

#
# Indicates attempt qualify association class navigation by something other than
# an association role of the association class.
# args:
#   0 - the complete text of association class call expression
#
AssociationClassQualifierType_ERROR_ = Qualifier on association class navigation must be a role of the navigation source: ({0})

#
# Indicates attempt to call a reflexive association class without qualifying it
# by the navigation source.
# args:
#   0 - the complete text of association class call expression
#
AssociationClassAmbiguous_ERROR_ = Qualifier needed to select navigation direction in reflexive association class: ({0})


#
# Indicates that the body condition does not have the expected form of an
# equality expression on the operation result.
# args:
#   0 - the context operation name
#
BodyConditionForm_ERROR_ = Body condition must have the form "result = <expr>" on operation "{0}"

#
# Indicates that the body condition constraint is not a boolean expression.
# args:
#   0 - the context operation name
#
OperationConstraintBoolean_ERROR_ = Constraint must be boolean-valued on operation "{0}"

# Error indicating an attempt to parse an OCL Expression as an invariant
# constraint, but the expression does not compute a boolean value
# args:
#   0 -  the name of the context classifier on which the invariant is defined
InvariantConstraintBoolean_ERROR_ = Constraint must be boolean-valued on type "{0}"

# Error indicating that an ExpressionInOcl has the wrong contextual classifier
# according to is constrainedElement.
# args:
#   0 - the name of the contextual classifier found
#   1 - the name of the expected classifier
WrongContextClassifier_ERROR_ = Invalid contextual classifier "{0}"; expected "{1}"

# Indicates that the ExpressionInOcl specifying a constraint is missing the
# required context variable.
MissingContextVariable_ERROR_ = Missing context variable in ExpressionInOcl

# Indicates that the ExpressionInOcl specifying a constraint has parameter
# variables when it should not have any.
ExtraneousParameterVariables_ERROR_ = Extraneous parameter variables in ExpressionInOcl

# Indicates that the ExpressionInOcl specifying a constraint has a result
# variable when it should not have one.
ExtraneousResultVariable_ERROR_ = Extraneous result variable in ExpressionInOcl

# Indicates that the ExpressionInOcl specifying a constraint has parameter
# variables that do not match the context operation parameters.
MismatchedParameterVariables_ERROR_ = Mismatched parameter variables in ExpressionInOcl

# Indicates that the ExpressionInOcl specifying a constraint has a result
# variable that does not match the context operation result.
MismatchedResultVariable_ERROR_ = Mismatched result variable in ExpressionInOcl

# Indicates that the ExpressionInOcl specifying a constraint has no result
# variable when its context operation has a return result.
MissingResultVariable_ERROR_ = Missing result variable in ExpressionInOcl

# Indicates that the ExpressionInOcl specifying a constraint has no body
# expression.
MissingBodyExpression_ERROR_ = Missing body expression in ExpressionInOcl

# Indicates a static call to a non-static attribute.
# args:
#   0 - the name of the attribute
NonStaticAttribute_ERROR_ = Static reference to non-static attribute "{0}"

# Indicates a static call to a non-static operation.
# args:
#   0 - the name of the operation
NonStaticOperation_ERROR_ = Static call to non-static operation "{0}"


#
# Indicates a parse failure in which a reasonable diagnostic cannot be produced;
# the input is not consumable by the parser (e.g., perhaps it is empty).
#
InvalidOCL_ERROR_ = Invalid OCL

#
# Indicates that the input to the OCL parser was not an expression of the kind
# that the parser was asked to parse.
# args:
#   0 - the expected expression type (concrete syntax rule name)
#   1 - the actual expression type (concrete syntax rule name)
#
ParseCSTNodeType_ERROR_ = expected parser to return {0} but got {1}


# ==============================================================================
# Translation Instruction: section to be translated
# 
# Error messages from the lexer and/or concrete syntax parser.
# ==============================================================================

#
# Indicates that an invalid character was encountered.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the character that was found
#
OCLParseErrorCodes_LEX_ERROR = {0} {1} unexpected character ignored

#
# Indicates that the parser could not proceed beyond the named token.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the token at which the parser gave up
#
OCLParseErrorCodes_ERROR = {0} {1} parsing terminated at this token

#
# Indicates that the parser tried to recover from a problem by inserting a token.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the token that the parser inserted
#   2 - the token before which the parser inserted the token
#
OCLParseErrorCodes_BEFORE = {0} {1} inserted before {2}

#
# Indicates that the parser could not find the next expected token after the
# specified token.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the next token that the parser expected to find
#   2 - the token after which the parser expected to find it
#
OCLParseErrorCodes_INSERTION = {0} {1} expected after {2}

#
# Indicates that the parser tried to recover by discarding some invalid text.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the text that the parser discarded
#
OCLParseErrorCodes_INVALID = {0} {1} unexpected input discarded

#
# Indicates that the parser encountered an unexpected token.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the token that the parser found
#   2 - the token that the parser had expected to find
#
OCLParseErrorCodes_SUBSTITUTION_SECONDARY = {0} {1} expected instead of {2}

#
# Indicates that the parser encountered an unexpected token.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the token that the parser encountered
#
OCLParseErrorCodes_DELETION = {0} {1} unexpected token(s)

#
# Indicates that the parser attempted to recover my merging two or more distinct
# tokens into a single token.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the tokens that the parser merged
#   2 - the resulting merged token
#
OCLParseErrorCodes_MERGE = {0} merge tokens {2} to form {1}

#
# Indicates that the parser found a token out of place.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the misplaced token
#
OCLParseErrorCodes_MISPLACED = {0} {1} misplaced construct(s)

#
# Indicates that the parser did not find the token that it needed to complete
# an expression.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the token that was expected
#
OCLParseErrorCodes_SCOPE = {0} missing {1} to complete scope

#
# Indicates that the parser encountered a premature end of input.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the last token in the input
#
OCLParseErrorCodes_EOF = {0} End-of-File reached after this token {1}

#
# Indicates that the parser encountered an invalid token.
# args:
#   0 - the location of the problem (see ErrorReport_RowColumn pattern, below)
#   1 - the invalid token
#
OCLParseErrorCodes_INVALID_TOKEN = {0} token {1} is invalid

#
# Indicates the location at which a concrete syntax parsing error was encountered.
# This is the first argument to all of the OCLParseErrorCodes_* messages, above.
# args:
#   0 - the line number at which the problem token started
#   1 - the column number at which the problem token started
#   2 - the line number at which the problem token terminated
#   3 - the column number at which the problem token terminated
ErrorReport_RowColumn = {0}:{1}:{2}:{3}

#
# Indicates the usage of the MDT implementation's support for
# the 7.4.8 reference to a conceptaul operation.
# args:
#   0 - the conceptual operation name
#
Conceptual_Operation_Name_ = Usage of conceptual operation name: {0}

#
# Indicates the usage of the MDT implementation's non-standard "..." escape
# syntax for element names that are not valid tokens in the OCL concrete syntax.
# args:
#   0 - the quoted element name escape sequence
#
NonStd_DQuote_Escape_ = Usage of non-standard quoted element name: {0}

#
# Indicates the usage of the MDT implementation's non-standard '' escape
# syntax for single quotation marks embedded in string literals.
# args:
#   0 - the string literal containing the escape sequence
#
NonStd_SQuote_Escape_ = Usage of non-standard escaped quote in string literal: {0}

#
# Indicates the usage of the a non-standard operation defined by the
# MDT implementation.
# args:
#   0 - the operation
#
NonStd_Operation_ = Usage of non-standard "{0}" operation

#
# Indicates the usage of the a non-standard iterator expression defined by the
# MDT implementation.
# args:
#   0 - the iterator name
#
NonStd_Iterator_ = Usage of non-standard "{0}" iterator

#
# Indicates the usage of the a non-standard capability of specifying, in the
# concrete syntax of constraint context, an inherited feature as context.
# args:
#   0 - the classifier inheriting the feature
#   1 - the feature in question that is declared as a constraint context
#
NonStd_InheritedFeatureContext_ = Usage of non-standard feature context "{1}" inherited by "{0}"

#
# Indicates an ambiguous association end navigation.
# args:
#   0 - the iterator name
#
Ambig_AssocEnd_ = Multiple association ends named "{0}" in classifier "{1}"

#
# Indicates usage of the Java convention for comparison via compareTo()
# operation instead of the OCL-standard <, >, <=, and >= operations.
#
NonStd_CompareTo_ = Usage of non-standard interpolation of relational operators from "compareTo()" operation

#
# Indicates that a string literal is not properly closed, i.e. the 
# escape sequence start symbol is immediately followed by a trailing quote
#
StringNotProperlyClosed_ERROR = String literal not properly closed

#
# Indicates that a string literal contains an invalid escape sequence
#
InvalidEscapeSequence_ERROR = Invalid escape sequence (valid ones are \\b \\t \\n \\f \\r \\\" \\\' \\\\)
    
#
# Indicates that an xor,or,and expression is parsed differently for OCL 2.2 than its predecessors.
#
XorOrAndPrecedence_WARNING = Precedence of xor,or,and changed for OCL 2.2.

#
# Indicates that evaluation of an OCL expression yielded the invalid result.
#   0 - the OCL expression
#
EvaluationResultIsInvalid_ERROR_ = OCL evaluation result of ''{0}'' is invalid

#
# Indicates that the OCL body for the body annotation on
# an EOperation is either missing or invalid.
#   0 - the model element
#
MissingBodyForInvocationDelegate_ERROR_ = Missing or invalid body constraint for ''{0}''

#
# Indicates that the OCL body for the derivation annotation on
# an EStructuralFeature is either missing or invalid.
#   0 - the model element
#
MissingDerivationForSettingDelegate_ERROR_ = Missing or invalid derivation constraint for ''{0}''

#
# Indicates that the OCL constraint to be validated does not yield a Boolean value.
#   0 - the OCL constraint
#
ValidationConstraintIsNotBoolean_ERROR_ = OCL validation constraint ''{0}'' is not boolean

#
# Indicates that validation of a model element yielded the invalid result.
#   0 - the model element
#
ValidationResultIsInvalid_ERROR_ = OCL validation result of ''{0}'' is invalid

#
# Indicates that validation of a model element yielded the null result.
#   0 - the model element
#
ValidationResultIsNull_ERROR_ = OCL validation result of ''{0}'' is null

#
# Indicates that validation of a model element yielded a non-Boolean result.
#   0 - the model element
#
ValidationResultIsNotBoolean_ERROR_ = OCL validation result of ''{0}'' is not boolean

#
# Name of a "hidden opposite" property, re-using the description
# of the forward property
#   0 - the description of the forward property
#
HiddenOppositeOf = Hidden opposite of ''{0}''

#
# Indicates that execution of a model operation used eDynamicInvoke to workaround
# the missing overloaded eInvoke that would be provided if genmodel' Operation Reflection
# was set true.
#   0 - the model class
#
NoOperationReflection_WARNING_ = Override of eInvoke(int,EList) not found for ''{0}'': set ''Operation Reflection'' true and re-genmodel.

#
# Indicates that an extra argument is present in a query.
#   0 - the name of the extra argument
#
ExtraArg_ERROR_ = Extra argument expression ({0})
