/*
* generated by Xtext
*/

package org.eclipse.ocl.examples.xtext.essentialocl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class EssentialOCLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final RuleCall cExpCSParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
		//
		//Model returns ExpCS:
		//	ExpCS;
		public ParserRule getRule() { return rule; }

		//ExpCS
		public RuleCall getExpCSParserRuleCall() { return cExpCSParserRuleCall; }
	}

	public class NUMBER_LITERALElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER_LITERAL");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Keyword cEKeyword_2_0_0 = (Keyword)cAlternatives_2_0.eContents().get(0);
		private final Keyword cEKeyword_2_0_1 = (Keyword)cAlternatives_2_0.eContents().get(1);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Keyword cPlusSignKeyword_2_1_0 = (Keyword)cAlternatives_2_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2_1_1 = (Keyword)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		
		//// Not terminal to allow parser backtracking to sort out "5..7"
		//
		//NUMBER_LITERAL returns BigNumber:
		//	INT ("." INT)? (("e" | "E") ("+" | "-")? INT)?;
		public ParserRule getRule() { return rule; }

		//INT ("." INT)? (("e" | "E") ("+" | "-")? INT)?
		public Group getGroup() { return cGroup; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//("." INT)?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }

		//(("e" | "E") ("+" | "-")? INT)?
		public Group getGroup_2() { return cGroup_2; }

		//"e" | "E"
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }

		//"e"
		public Keyword getEKeyword_2_0_0() { return cEKeyword_2_0_0; }

		//"E"
		public Keyword getEKeyword_2_0_1() { return cEKeyword_2_0_1; }

		//("+" | "-")?
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//"+"
		public Keyword getPlusSignKeyword_2_1_0() { return cPlusSignKeyword_2_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_2_1_1() { return cHyphenMinusKeyword_2_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2_2() { return cINTTerminalRuleCall_2_2; }
	}

	public class EssentialOCLReservedKeywordsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EssentialOCLReservedKeywords");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAndKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cElseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEndifKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cIfKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cImpliesKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cInKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLetKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cNotKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cOrKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cThenKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cXorKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		
		//EssentialOCLReservedKeywords returns ecore::EString:
		//	"and" | "else" | "endif" | "if" | "implies" | "in" | "let" | "not" | "or" | "then" | "xor";
		public ParserRule getRule() { return rule; }

		//"and" | "else" | "endif" | "if" | "implies" | "in" | "let" | "not" | "or" | "then" | "xor"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"and"
		public Keyword getAndKeyword_0() { return cAndKeyword_0; }

		//"else"
		public Keyword getElseKeyword_1() { return cElseKeyword_1; }

		//"endif"
		public Keyword getEndifKeyword_2() { return cEndifKeyword_2; }

		//"if"
		public Keyword getIfKeyword_3() { return cIfKeyword_3; }

		//"implies"
		public Keyword getImpliesKeyword_4() { return cImpliesKeyword_4; }

		//"in"
		public Keyword getInKeyword_5() { return cInKeyword_5; }

		//"let"
		public Keyword getLetKeyword_6() { return cLetKeyword_6; }

		//"not"
		public Keyword getNotKeyword_7() { return cNotKeyword_7; }

		//"or"
		public Keyword getOrKeyword_8() { return cOrKeyword_8; }

		//"then"
		public Keyword getThenKeyword_9() { return cThenKeyword_9; }

		//"xor"
		public Keyword getXorKeyword_10() { return cXorKeyword_10; }
	}

	public class EssentialOCLRestrictedKeywordsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EssentialOCLRestrictedKeywords");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EssentialOCLRestrictedKeywords returns ecore::EString:
		//	"e" | "E";
		public ParserRule getRule() { return rule; }

		//"e" | "E"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"e"
		public Keyword getEKeyword_0() { return cEKeyword_0; }

		//"E"
		public Keyword getEKeyword_1() { return cEKeyword_1; }
	}

	public class RestrictedKeywordsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RestrictedKeywords");
		private final RuleCall cEssentialOCLRestrictedKeywordsParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Intended to be overridden
		//
		//RestrictedKeywords returns ecore::EString:
		//	EssentialOCLRestrictedKeywords;
		public ParserRule getRule() { return rule; }

		//EssentialOCLRestrictedKeywords
		public RuleCall getEssentialOCLRestrictedKeywordsParserRuleCall() { return cEssentialOCLRestrictedKeywordsParserRuleCall; }
	}

	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Identifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRestrictedKeywordsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Identifier returns ecore::EString:
		//	ID | RestrictedKeywords;
		public ParserRule getRule() { return rule; }

		//ID | RestrictedKeywords
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//RestrictedKeywords
		public RuleCall getRestrictedKeywordsParserRuleCall_1() { return cRestrictedKeywordsParserRuleCall_1; }
	}

	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final RuleCall cSINGLE_QUOTED_STRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//StringLiteral returns ecore::EString:
		//	SINGLE_QUOTED_STRING;
		public ParserRule getRule() { return rule; }

		//SINGLE_QUOTED_STRING
		public RuleCall getSINGLE_QUOTED_STRINGTerminalRuleCall() { return cSINGLE_QUOTED_STRINGTerminalRuleCall; }
	}

	public class SimpleNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleName");
		private final RuleCall cIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////---------------------------------------------------------------------
		//
		////  Names
		//
		////---------------------------------------------------------------------
		//
		/// *  Temporary backward compatibility support for 7.4.8 conceptual usage 
		//
		//conceptualOperationName returns SimpleNameCS:
		//
		//	value='and'
		//
		//	| value='implies'
		//
		//	| value='not'
		//
		//	| value='or'
		//
		//	| value='xor'
		//
		//	| value='<'
		//
		//	| value='<='
		//
		//	| value='>='
		//
		//	| value='>'
		//
		//	| value='='
		//
		//	| value='<>'
		//
		//	| value='+'
		//
		//	| value='-'
		//
		//	| value='*'
		//
		//	| value='/';
		//
		//conceptualOperationNameCS returns SimpleNameCS:
		//
		//	conceptualOperationName; * // *tupleKeywordCS returns ecore::EString:
		//
		//	value='Tuple'; * // *restrictedKeywordCS returns ecore::EString: 
		//
		//	CollectionTypeIdentifierCS
		//
		////  restrictedKeywordCS -> BooleanLiteralExpCS
		//
		////  restrictedKeywordCS -> InvalidLiteralExpCS
		//
		////  restrictedKeywordCS -> NullLiteralExpCS
		//
		////-  restrictedKeywordCS -> selfKeywordCS
		//
		//|	primitiveTypeCS
		//
		//|	tupleKeywordCS; * /SimpleName returns ecore::EString:
		//	Identifier;
		public ParserRule getRule() { return rule; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall() { return cIdentifierParserRuleCall; }
	}

	public class PrimitiveTypeIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveTypeIdentifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBooleanKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cIntegerKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRealKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cStringKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cUnlimitedNaturalKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cOclAnyKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cOclInvalidKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cOclVoidKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		
		////pathNameCS returns NameExpCS:
		//
		////	(namespace=[NamespaceCS|Identifier] '::')* element=[NamedElementCS|Identifier]
		//
		////
		//
		////	ref=[ModelElementCS|PathName]
		//
		////;
		//
		////---------------------------------------------------------------------
		//
		////  Types
		//
		////---------------------------------------------------------------------
		//
		//PrimitiveTypeIdentifier returns ecore::EString:
		//	"Boolean" | "Integer" | "Real" | "String" | "UnlimitedNatural" | "OclAny" | "OclInvalid" | "OclVoid";
		public ParserRule getRule() { return rule; }

		//"Boolean" | "Integer" | "Real" | "String" | "UnlimitedNatural" | "OclAny" | "OclInvalid" | "OclVoid"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"Boolean"
		public Keyword getBooleanKeyword_0() { return cBooleanKeyword_0; }

		//"Integer"
		public Keyword getIntegerKeyword_1() { return cIntegerKeyword_1; }

		//"Real"
		public Keyword getRealKeyword_2() { return cRealKeyword_2; }

		//"String"
		public Keyword getStringKeyword_3() { return cStringKeyword_3; }

		//"UnlimitedNatural"
		public Keyword getUnlimitedNaturalKeyword_4() { return cUnlimitedNaturalKeyword_4; }

		//"OclAny"
		public Keyword getOclAnyKeyword_5() { return cOclAnyKeyword_5; }

		//"OclInvalid"
		public Keyword getOclInvalidKeyword_6() { return cOclInvalidKeyword_6; }

		//"OclVoid"
		public Keyword getOclVoidKeyword_7() { return cOclVoidKeyword_7; }
	}

	public class PrimitiveTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveTypeCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNamePrimitiveTypeIdentifierParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//PrimitiveTypeCS:
		//	name=PrimitiveTypeIdentifier;
		public ParserRule getRule() { return rule; }

		//name=PrimitiveTypeIdentifier
		public Assignment getNameAssignment() { return cNameAssignment; }

		//PrimitiveTypeIdentifier
		public RuleCall getNamePrimitiveTypeIdentifierParserRuleCall_0() { return cNamePrimitiveTypeIdentifierParserRuleCall_0; }
	}

	public class CollectionTypeIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionTypeIdentifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSetKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBagKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSequenceKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cCollectionKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cOrderedSetKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		//CollectionTypeIdentifier returns ecore::EString:
		//	"Set" | "Bag" | "Sequence" | "Collection" | "OrderedSet";
		public ParserRule getRule() { return rule; }

		//"Set" | "Bag" | "Sequence" | "Collection" | "OrderedSet"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"Set"
		public Keyword getSetKeyword_0() { return cSetKeyword_0; }

		//"Bag"
		public Keyword getBagKeyword_1() { return cBagKeyword_1; }

		//"Sequence"
		public Keyword getSequenceKeyword_2() { return cSequenceKeyword_2; }

		//"Collection"
		public Keyword getCollectionKeyword_3() { return cCollectionKeyword_3; }

		//"OrderedSet"
		public Keyword getOrderedSetKeyword_4() { return cOrderedSetKeyword_4; }
	}

	public class TypeExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitiveTypeCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNameExpCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCollectionTypeCSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTupleTypeCSParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//TypeExpCS:
		//	PrimitiveTypeCS | NameExpCS | CollectionTypeCS | TupleTypeCS;
		public ParserRule getRule() { return rule; }

		//PrimitiveTypeCS | NameExpCS | CollectionTypeCS | TupleTypeCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimitiveTypeCS
		public RuleCall getPrimitiveTypeCSParserRuleCall_0() { return cPrimitiveTypeCSParserRuleCall_0; }

		//NameExpCS
		public RuleCall getNameExpCSParserRuleCall_1() { return cNameExpCSParserRuleCall_1; }

		//CollectionTypeCS
		public RuleCall getCollectionTypeCSParserRuleCall_2() { return cCollectionTypeCSParserRuleCall_2; }

		//TupleTypeCS
		public RuleCall getTupleTypeCSParserRuleCall_3() { return cTupleTypeCSParserRuleCall_3; }
	}

	public class CollectionTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionTypeCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameCollectionTypeIdentifierParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeCSAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeCSTypeExpCSParserRuleCall_1_1_0 = (RuleCall)cTypeCSAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//CollectionTypeCS:
		//	name=CollectionTypeIdentifier ("(" typeCS=TypeExpCS ")")?;
		public ParserRule getRule() { return rule; }

		//name=CollectionTypeIdentifier ("(" typeCS=TypeExpCS ")")?
		public Group getGroup() { return cGroup; }

		//name=CollectionTypeIdentifier
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//CollectionTypeIdentifier
		public RuleCall getNameCollectionTypeIdentifierParserRuleCall_0_0() { return cNameCollectionTypeIdentifierParserRuleCall_0_0; }

		//("(" typeCS=TypeExpCS ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//typeCS=TypeExpCS
		public Assignment getTypeCSAssignment_1_1() { return cTypeCSAssignment_1_1; }

		//TypeExpCS
		public RuleCall getTypeCSTypeExpCSParserRuleCall_1_1_0() { return cTypeCSTypeExpCSParserRuleCall_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class TupleTypeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleTypeCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameTupleKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cPartAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cPartTuplePartCSParserRuleCall_2_0_0 = (RuleCall)cPartAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cPartAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cPartTuplePartCSParserRuleCall_2_1_1_0 = (RuleCall)cPartAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TupleTypeCS:
		//	name="Tuple" "(" (part+=tuplePartCS ("," part+=tuplePartCS)*)? ")";
		public ParserRule getRule() { return rule; }

		//name="Tuple" "(" (part+=tuplePartCS ("," part+=tuplePartCS)*)? ")"
		public Group getGroup() { return cGroup; }

		//name="Tuple"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"Tuple"
		public Keyword getNameTupleKeyword_0_0() { return cNameTupleKeyword_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(part+=tuplePartCS ("," part+=tuplePartCS)*)?
		public Group getGroup_2() { return cGroup_2; }

		//part+=tuplePartCS
		public Assignment getPartAssignment_2_0() { return cPartAssignment_2_0; }

		//tuplePartCS
		public RuleCall getPartTuplePartCSParserRuleCall_2_0_0() { return cPartTuplePartCSParserRuleCall_2_0_0; }

		//("," part+=tuplePartCS)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//part+=tuplePartCS
		public Assignment getPartAssignment_2_1_1() { return cPartAssignment_2_1_1; }

		//tuplePartCS
		public RuleCall getPartTuplePartCSParserRuleCall_2_1_1_0() { return cPartTuplePartCSParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class TuplePartCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "tuplePartCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSimpleNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeExpCSParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//tuplePartCS returns VariableCS:
		//	name=SimpleName ":" type=TypeExpCS;
		public ParserRule getRule() { return rule; }

		//name=SimpleName ":" type=TypeExpCS
		public Group getGroup() { return cGroup; }

		//name=SimpleName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SimpleName
		public RuleCall getNameSimpleNameParserRuleCall_0_0() { return cNameSimpleNameParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=TypeExpCS
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//TypeExpCS
		public RuleCall getTypeTypeExpCSParserRuleCall_2_0() { return cTypeTypeExpCSParserRuleCall_2_0; }
	}

	public class CollectionLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionLiteralExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCollectionTypeCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCollectionLiteralExpCSTypeCSAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cCollectionLiteralPartsAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cCollectionLiteralPartsCollectionLiteralPartCSParserRuleCall_1_2_0_0 = (RuleCall)cCollectionLiteralPartsAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cCollectionLiteralPartsAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cCollectionLiteralPartsCollectionLiteralPartCSParserRuleCall_1_2_1_1_0 = (RuleCall)cCollectionLiteralPartsAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		////---------------------------------------------------------------------
		//
		////  Literals
		//
		////---------------------------------------------------------------------
		//
		//// EnumLiteralExpCS is parsed as a PropertyCallExpCS[C]
		//
		////  LiteralExpCS -> EnumLiteralExpCS
		//
		////LiteralExpCS returns LiteralExpCS:
		//
		////	CollectionLiteralExpCS
		//
		////|	TupleLiteralExpCS
		//
		////|	PrimitiveLiteralExpCS
		//
		////|	primitiveTypeCS
		//
		////|	NameExpCS
		//
		//////|	collectionTypeCS
		//
		////|	TupleTypeCS
		//
		////;
		//
		//// or CollectionTypeLiteral
		//
		//CollectionLiteralExpCS returns LiteralExpCS:
		//	CollectionTypeCS ({CollectionLiteralExpCS.typeCS=current} "{" (collectionLiteralParts+=CollectionLiteralPartCS (","
		//	collectionLiteralParts+=CollectionLiteralPartCS)*)? "}")?;
		public ParserRule getRule() { return rule; }

		//CollectionTypeCS ({CollectionLiteralExpCS.typeCS=current} "{" (collectionLiteralParts+=CollectionLiteralPartCS (","
		//collectionLiteralParts+=CollectionLiteralPartCS)*)? "}")?
		public Group getGroup() { return cGroup; }

		//CollectionTypeCS
		public RuleCall getCollectionTypeCSParserRuleCall_0() { return cCollectionTypeCSParserRuleCall_0; }

		//({CollectionLiteralExpCS.typeCS=current} "{" (collectionLiteralParts+=CollectionLiteralPartCS (","
		//collectionLiteralParts+=CollectionLiteralPartCS)*)? "}")?
		public Group getGroup_1() { return cGroup_1; }

		//{CollectionLiteralExpCS.typeCS=current}
		public Action getCollectionLiteralExpCSTypeCSAction_1_0() { return cCollectionLiteralExpCSTypeCSAction_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }

		//(collectionLiteralParts+=CollectionLiteralPartCS ("," collectionLiteralParts+=CollectionLiteralPartCS)*)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//collectionLiteralParts+=CollectionLiteralPartCS
		public Assignment getCollectionLiteralPartsAssignment_1_2_0() { return cCollectionLiteralPartsAssignment_1_2_0; }

		//CollectionLiteralPartCS
		public RuleCall getCollectionLiteralPartsCollectionLiteralPartCSParserRuleCall_1_2_0_0() { return cCollectionLiteralPartsCollectionLiteralPartCSParserRuleCall_1_2_0_0; }

		//("," collectionLiteralParts+=CollectionLiteralPartCS)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//","
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }

		//collectionLiteralParts+=CollectionLiteralPartCS
		public Assignment getCollectionLiteralPartsAssignment_1_2_1_1() { return cCollectionLiteralPartsAssignment_1_2_1_1; }

		//CollectionLiteralPartCS
		public RuleCall getCollectionLiteralPartsCollectionLiteralPartCSParserRuleCall_1_2_1_1_0() { return cCollectionLiteralPartsCollectionLiteralPartCSParserRuleCall_1_2_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_3() { return cRightCurlyBracketKeyword_1_3; }
	}

	public class CollectionLiteralPartCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionLiteralPartCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionCSAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionCSExpCSParserRuleCall_0_0 = (RuleCall)cExpressionCSAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cLastExpressionCSAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cLastExpressionCSExpCSParserRuleCall_1_1_0 = (RuleCall)cLastExpressionCSAssignment_1_1.eContents().get(0);
		
		//CollectionLiteralPartCS:
		//	expressionCS=ExpCS (".." lastExpressionCS=ExpCS)?;
		public ParserRule getRule() { return rule; }

		//expressionCS=ExpCS (".." lastExpressionCS=ExpCS)?
		public Group getGroup() { return cGroup; }

		//expressionCS=ExpCS
		public Assignment getExpressionCSAssignment_0() { return cExpressionCSAssignment_0; }

		//ExpCS
		public RuleCall getExpressionCSExpCSParserRuleCall_0_0() { return cExpressionCSExpCSParserRuleCall_0_0; }

		//(".." lastExpressionCS=ExpCS)?
		public Group getGroup_1() { return cGroup_1; }

		//".."
		public Keyword getFullStopFullStopKeyword_1_0() { return cFullStopFullStopKeyword_1_0; }

		//lastExpressionCS=ExpCS
		public Assignment getLastExpressionCSAssignment_1_1() { return cLastExpressionCSAssignment_1_1; }

		//ExpCS
		public RuleCall getLastExpressionCSExpCSParserRuleCall_1_1_0() { return cLastExpressionCSExpCSParserRuleCall_1_1_0; }
	}

	public class PrimitiveLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveLiteralExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralExpCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringLiteralExpCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanLiteralExpCSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cInvalidLiteralExpCSParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNullLiteralExpCSParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//PrimitiveLiteralExpCS:
		//	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | InvalidLiteralExpCS | NullLiteralExpCS;
		public ParserRule getRule() { return rule; }

		//NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | InvalidLiteralExpCS | NullLiteralExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//NumberLiteralExpCS
		public RuleCall getNumberLiteralExpCSParserRuleCall_0() { return cNumberLiteralExpCSParserRuleCall_0; }

		//StringLiteralExpCS
		public RuleCall getStringLiteralExpCSParserRuleCall_1() { return cStringLiteralExpCSParserRuleCall_1; }

		//BooleanLiteralExpCS
		public RuleCall getBooleanLiteralExpCSParserRuleCall_2() { return cBooleanLiteralExpCSParserRuleCall_2; }

		//InvalidLiteralExpCS
		public RuleCall getInvalidLiteralExpCSParserRuleCall_3() { return cInvalidLiteralExpCSParserRuleCall_3; }

		//NullLiteralExpCS
		public RuleCall getNullLiteralExpCSParserRuleCall_4() { return cNullLiteralExpCSParserRuleCall_4; }
	}

	public class TupleLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleLiteralExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTupleLiteralExpCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTupleKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPartAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPartTupleLiteralPartCSParserRuleCall_2_1_0 = (RuleCall)cPartAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cPartAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cPartTupleLiteralPartCSParserRuleCall_2_2_1_0 = (RuleCall)cPartAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		
		//// or TupleTypeLiteral
		//
		//TupleLiteralExpCS:
		//	{TupleLiteralExpCS} "Tuple" ("{" part+=TupleLiteralPartCS ("," part+=TupleLiteralPartCS)* "}")?;
		public ParserRule getRule() { return rule; }

		//{TupleLiteralExpCS} "Tuple" ("{" part+=TupleLiteralPartCS ("," part+=TupleLiteralPartCS)* "}")?
		public Group getGroup() { return cGroup; }

		//{TupleLiteralExpCS}
		public Action getTupleLiteralExpCSAction_0() { return cTupleLiteralExpCSAction_0; }

		//"Tuple"
		public Keyword getTupleKeyword_1() { return cTupleKeyword_1; }

		//("{" part+=TupleLiteralPartCS ("," part+=TupleLiteralPartCS)* "}")?
		public Group getGroup_2() { return cGroup_2; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2_0() { return cLeftCurlyBracketKeyword_2_0; }

		//part+=TupleLiteralPartCS
		public Assignment getPartAssignment_2_1() { return cPartAssignment_2_1; }

		//TupleLiteralPartCS
		public RuleCall getPartTupleLiteralPartCSParserRuleCall_2_1_0() { return cPartTupleLiteralPartCSParserRuleCall_2_1_0; }

		//("," part+=TupleLiteralPartCS)*
		public Group getGroup_2_2() { return cGroup_2_2; }

		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }

		//part+=TupleLiteralPartCS
		public Assignment getPartAssignment_2_2_1() { return cPartAssignment_2_2_1; }

		//TupleLiteralPartCS
		public RuleCall getPartTupleLiteralPartCSParserRuleCall_2_2_1_0() { return cPartTupleLiteralPartCSParserRuleCall_2_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2_3() { return cRightCurlyBracketKeyword_2_3; }
	}

	public class TupleLiteralPartCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TupleLiteralPartCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSimpleNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeTypeExpCSParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInitExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInitExpressionExpCSParserRuleCall_3_0 = (RuleCall)cInitExpressionAssignment_3.eContents().get(0);
		
		//TupleLiteralPartCS returns VariableCS:
		//	name=SimpleName (":" type=TypeExpCS)? "=" initExpression=ExpCS;
		public ParserRule getRule() { return rule; }

		//name=SimpleName (":" type=TypeExpCS)? "=" initExpression=ExpCS
		public Group getGroup() { return cGroup; }

		//name=SimpleName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SimpleName
		public RuleCall getNameSimpleNameParserRuleCall_0_0() { return cNameSimpleNameParserRuleCall_0_0; }

		//(":" type=TypeExpCS)?
		public Group getGroup_1() { return cGroup_1; }

		//":"
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }

		//type=TypeExpCS
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }

		//TypeExpCS
		public RuleCall getTypeTypeExpCSParserRuleCall_1_1_0() { return cTypeTypeExpCSParserRuleCall_1_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//initExpression=ExpCS
		public Assignment getInitExpressionAssignment_3() { return cInitExpressionAssignment_3; }

		//ExpCS
		public RuleCall getInitExpressionExpCSParserRuleCall_3_0() { return cInitExpressionExpCSParserRuleCall_3_0; }
	}

	public class NumberLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberLiteralExpCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameNUMBER_LITERALParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//NumberLiteralExpCS:
		//	name=NUMBER_LITERAL;
		public ParserRule getRule() { return rule; }

		//name=NUMBER_LITERAL
		public Assignment getNameAssignment() { return cNameAssignment; }

		//NUMBER_LITERAL
		public RuleCall getNameNUMBER_LITERALParserRuleCall_0() { return cNameNUMBER_LITERALParserRuleCall_0; }
	}

	public class StringLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteralExpCS");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameStringLiteralParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//StringLiteralExpCS:
		//	name+=StringLiteral+;
		public ParserRule getRule() { return rule; }

		//name+=StringLiteral+
		public Assignment getNameAssignment() { return cNameAssignment; }

		//StringLiteral
		public RuleCall getNameStringLiteralParserRuleCall_0() { return cNameStringLiteralParserRuleCall_0; }
	}

	public class BooleanLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteralExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cNameTrueKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cNameFalseKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		
		//BooleanLiteralExpCS:
		//	name="true" | name="false";
		public ParserRule getRule() { return rule; }

		//name="true" | name="false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//name="true"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"true"
		public Keyword getNameTrueKeyword_0_0() { return cNameTrueKeyword_0_0; }

		//name="false"
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//"false"
		public Keyword getNameFalseKeyword_1_0() { return cNameFalseKeyword_1_0; }
	}

	public class InvalidLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InvalidLiteralExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInvalidLiteralExpCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cInvalidKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//InvalidLiteralExpCS:
		//	{InvalidLiteralExpCS} "invalid";
		public ParserRule getRule() { return rule; }

		//{InvalidLiteralExpCS} "invalid"
		public Group getGroup() { return cGroup; }

		//{InvalidLiteralExpCS}
		public Action getInvalidLiteralExpCSAction_0() { return cInvalidLiteralExpCSAction_0; }

		//"invalid"
		public Keyword getInvalidKeyword_1() { return cInvalidKeyword_1; }
	}

	public class NullLiteralExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NullLiteralExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNullLiteralExpCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NullLiteralExpCS:
		//	{NullLiteralExpCS} "null";
		public ParserRule getRule() { return rule; }

		//{NullLiteralExpCS} "null"
		public Group getGroup() { return cGroup; }

		//{NullLiteralExpCS}
		public Action getNullLiteralExpCSAction_0() { return cNullLiteralExpCSAction_0; }

		//"null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }
	}

	public class ExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cImpliesCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLetExpCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////---------------------------------------------------------------------
		//
		////  Expressions
		//
		////---------------------------------------------------------------------
		//
		//// An OclExpressionCS comprising one or more LetExpCS is kept separate to ensure
		//
		////  that let is right associative, whereas infix operators are left associative.
		//
		////   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
		//
		//// is
		//
		////   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
		//
		//ExpCS:
		//	impliesCS | LetExpCS;
		public ParserRule getRule() { return rule; }

		//impliesCS | LetExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//impliesCS
		public RuleCall getImpliesCSParserRuleCall_0() { return cImpliesCSParserRuleCall_0; }

		//LetExpCS
		public RuleCall getLetExpCSParserRuleCall_1() { return cLetExpCSParserRuleCall_1; }
	}

	public class ImpliesCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "impliesCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpImpliesKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cArgumentAlternatives_1_2_0 = (Alternatives)cArgumentAssignment_1_2.eContents().get(0);
		private final RuleCall cArgumentXorCSParserRuleCall_1_2_0_0 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cArgumentLetExpCSParserRuleCall_1_2_0_1 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(1);
		
		//impliesCS returns ExpCS:
		//	xorCS ({InfixExpCS.source=current} op="implies" argument=(xorCS | LetExpCS))*;
		public ParserRule getRule() { return rule; }

		//xorCS ({InfixExpCS.source=current} op="implies" argument=(xorCS | LetExpCS))*
		public Group getGroup() { return cGroup; }

		//xorCS
		public RuleCall getXorCSParserRuleCall_0() { return cXorCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op="implies" argument=(xorCS | LetExpCS))*
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op="implies"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"implies"
		public Keyword getOpImpliesKeyword_1_1_0() { return cOpImpliesKeyword_1_1_0; }

		//argument=(xorCS | LetExpCS)
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//xorCS | LetExpCS
		public Alternatives getArgumentAlternatives_1_2_0() { return cArgumentAlternatives_1_2_0; }

		//xorCS
		public RuleCall getArgumentXorCSParserRuleCall_1_2_0_0() { return cArgumentXorCSParserRuleCall_1_2_0_0; }

		//LetExpCS
		public RuleCall getArgumentLetExpCSParserRuleCall_1_2_0_1() { return cArgumentLetExpCSParserRuleCall_1_2_0_1; }
	}

	public class XorCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xorCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpXorKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cArgumentAlternatives_1_2_0 = (Alternatives)cArgumentAssignment_1_2.eContents().get(0);
		private final RuleCall cArgumentOrCSParserRuleCall_1_2_0_0 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cArgumentLetExpCSParserRuleCall_1_2_0_1 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(1);
		
		//xorCS returns ExpCS:
		//	orCS ({InfixExpCS.source=current} op="xor" argument=(orCS | LetExpCS))*;
		public ParserRule getRule() { return rule; }

		//orCS ({InfixExpCS.source=current} op="xor" argument=(orCS | LetExpCS))*
		public Group getGroup() { return cGroup; }

		//orCS
		public RuleCall getOrCSParserRuleCall_0() { return cOrCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op="xor" argument=(orCS | LetExpCS))*
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op="xor"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"xor"
		public Keyword getOpXorKeyword_1_1_0() { return cOpXorKeyword_1_1_0; }

		//argument=(orCS | LetExpCS)
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//orCS | LetExpCS
		public Alternatives getArgumentAlternatives_1_2_0() { return cArgumentAlternatives_1_2_0; }

		//orCS
		public RuleCall getArgumentOrCSParserRuleCall_1_2_0_0() { return cArgumentOrCSParserRuleCall_1_2_0_0; }

		//LetExpCS
		public RuleCall getArgumentLetExpCSParserRuleCall_1_2_0_1() { return cArgumentLetExpCSParserRuleCall_1_2_0_1; }
	}

	public class OrCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "orCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpOrKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cArgumentAlternatives_1_2_0 = (Alternatives)cArgumentAssignment_1_2.eContents().get(0);
		private final RuleCall cArgumentAndCSParserRuleCall_1_2_0_0 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cArgumentLetExpCSParserRuleCall_1_2_0_1 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(1);
		
		//orCS returns ExpCS:
		//	andCS ({InfixExpCS.source=current} op="or" argument=(andCS | LetExpCS))*;
		public ParserRule getRule() { return rule; }

		//andCS ({InfixExpCS.source=current} op="or" argument=(andCS | LetExpCS))*
		public Group getGroup() { return cGroup; }

		//andCS
		public RuleCall getAndCSParserRuleCall_0() { return cAndCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op="or" argument=(andCS | LetExpCS))*
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op="or"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"or"
		public Keyword getOpOrKeyword_1_1_0() { return cOpOrKeyword_1_1_0; }

		//argument=(andCS | LetExpCS)
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//andCS | LetExpCS
		public Alternatives getArgumentAlternatives_1_2_0() { return cArgumentAlternatives_1_2_0; }

		//andCS
		public RuleCall getArgumentAndCSParserRuleCall_1_2_0_0() { return cArgumentAndCSParserRuleCall_1_2_0_0; }

		//LetExpCS
		public RuleCall getArgumentLetExpCSParserRuleCall_1_2_0_1() { return cArgumentLetExpCSParserRuleCall_1_2_0_1; }
	}

	public class AndCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "andCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpAndKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cArgumentAlternatives_1_2_0 = (Alternatives)cArgumentAssignment_1_2.eContents().get(0);
		private final RuleCall cArgumentEqualityCSParserRuleCall_1_2_0_0 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cArgumentLetExpCSParserRuleCall_1_2_0_1 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(1);
		
		//andCS returns ExpCS:
		//	equalityCS ({InfixExpCS.source=current} op="and" argument=(equalityCS | LetExpCS))*;
		public ParserRule getRule() { return rule; }

		//equalityCS ({InfixExpCS.source=current} op="and" argument=(equalityCS | LetExpCS))*
		public Group getGroup() { return cGroup; }

		//equalityCS
		public RuleCall getEqualityCSParserRuleCall_0() { return cEqualityCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op="and" argument=(equalityCS | LetExpCS))*
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op="and"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"and"
		public Keyword getOpAndKeyword_1_1_0() { return cOpAndKeyword_1_1_0; }

		//argument=(equalityCS | LetExpCS)
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//equalityCS | LetExpCS
		public Alternatives getArgumentAlternatives_1_2_0() { return cArgumentAlternatives_1_2_0; }

		//equalityCS
		public RuleCall getArgumentEqualityCSParserRuleCall_1_2_0_0() { return cArgumentEqualityCSParserRuleCall_1_2_0_0; }

		//LetExpCS
		public RuleCall getArgumentLetExpCSParserRuleCall_1_2_0_1() { return cArgumentLetExpCSParserRuleCall_1_2_0_1; }
	}

	public class EqualityCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "equalityCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cArgumentAlternatives_1_2_0 = (Alternatives)cArgumentAssignment_1_2.eContents().get(0);
		private final RuleCall cArgumentRelationalCSParserRuleCall_1_2_0_0 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cArgumentLetExpCSParserRuleCall_1_2_0_1 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(1);
		
		//equalityCS returns ExpCS:
		//	relationalCS ({InfixExpCS.source=current} op=("=" | "<>") argument=(relationalCS | LetExpCS))*;
		public ParserRule getRule() { return rule; }

		//relationalCS ({InfixExpCS.source=current} op=("=" | "<>") argument=(relationalCS | LetExpCS))*
		public Group getGroup() { return cGroup; }

		//relationalCS
		public RuleCall getRelationalCSParserRuleCall_0() { return cRelationalCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op=("=" | "<>") argument=(relationalCS | LetExpCS))*
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op=("=" | "<>")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"=" | "<>"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"="
		public Keyword getOpEqualsSignKeyword_1_1_0_0() { return cOpEqualsSignKeyword_1_1_0_0; }

		//"<>"
		public Keyword getOpLessThanSignGreaterThanSignKeyword_1_1_0_1() { return cOpLessThanSignGreaterThanSignKeyword_1_1_0_1; }

		//argument=(relationalCS | LetExpCS)
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//relationalCS | LetExpCS
		public Alternatives getArgumentAlternatives_1_2_0() { return cArgumentAlternatives_1_2_0; }

		//relationalCS
		public RuleCall getArgumentRelationalCSParserRuleCall_1_2_0_0() { return cArgumentRelationalCSParserRuleCall_1_2_0_0; }

		//LetExpCS
		public RuleCall getArgumentLetExpCSParserRuleCall_1_2_0_1() { return cArgumentLetExpCSParserRuleCall_1_2_0_1; }
	}

	public class RelationalCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "relationalCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cArgumentAlternatives_1_2_0 = (Alternatives)cArgumentAssignment_1_2.eContents().get(0);
		private final RuleCall cArgumentAdditiveCSParserRuleCall_1_2_0_0 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cArgumentLetExpCSParserRuleCall_1_2_0_1 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(1);
		
		//relationalCS returns ExpCS:
		//	additiveCS ({InfixExpCS.source=current} op=(">" | "<" | ">=" | "<=") argument=(additiveCS | LetExpCS))*;
		public ParserRule getRule() { return rule; }

		//additiveCS ({InfixExpCS.source=current} op=(">" | "<" | ">=" | "<=") argument=(additiveCS | LetExpCS))*
		public Group getGroup() { return cGroup; }

		//additiveCS
		public RuleCall getAdditiveCSParserRuleCall_0() { return cAdditiveCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op=(">" | "<" | ">=" | "<=") argument=(additiveCS | LetExpCS))*
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op=(">" | "<" | ">=" | "<=")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//">" | "<" | ">=" | "<="
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//">"
		public Keyword getOpGreaterThanSignKeyword_1_1_0_0() { return cOpGreaterThanSignKeyword_1_1_0_0; }

		//"<"
		public Keyword getOpLessThanSignKeyword_1_1_0_1() { return cOpLessThanSignKeyword_1_1_0_1; }

		//">="
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_2() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_2; }

		//"<="
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_3() { return cOpLessThanSignEqualsSignKeyword_1_1_0_3; }

		//argument=(additiveCS | LetExpCS)
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//additiveCS | LetExpCS
		public Alternatives getArgumentAlternatives_1_2_0() { return cArgumentAlternatives_1_2_0; }

		//additiveCS
		public RuleCall getArgumentAdditiveCSParserRuleCall_1_2_0_0() { return cArgumentAdditiveCSParserRuleCall_1_2_0_0; }

		//LetExpCS
		public RuleCall getArgumentLetExpCSParserRuleCall_1_2_0_1() { return cArgumentLetExpCSParserRuleCall_1_2_0_1; }
	}

	public class AdditiveCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "additiveCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cArgumentAlternatives_1_2_0 = (Alternatives)cArgumentAssignment_1_2.eContents().get(0);
		private final RuleCall cArgumentMultiplicativeCSParserRuleCall_1_2_0_0 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cArgumentLetExpCSParserRuleCall_1_2_0_1 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(1);
		
		//additiveCS returns ExpCS:
		//	multiplicativeCS ({InfixExpCS.source=current} op=("+" | "-") argument=(multiplicativeCS | LetExpCS))*;
		public ParserRule getRule() { return rule; }

		//multiplicativeCS ({InfixExpCS.source=current} op=("+" | "-") argument=(multiplicativeCS | LetExpCS))*
		public Group getGroup() { return cGroup; }

		//multiplicativeCS
		public RuleCall getMultiplicativeCSParserRuleCall_0() { return cMultiplicativeCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op=("+" | "-") argument=(multiplicativeCS | LetExpCS))*
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op=("+" | "-")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"+" | "-"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"+"
		public Keyword getOpPlusSignKeyword_1_1_0_0() { return cOpPlusSignKeyword_1_1_0_0; }

		//"-"
		public Keyword getOpHyphenMinusKeyword_1_1_0_1() { return cOpHyphenMinusKeyword_1_1_0_1; }

		//argument=(multiplicativeCS | LetExpCS)
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//multiplicativeCS | LetExpCS
		public Alternatives getArgumentAlternatives_1_2_0() { return cArgumentAlternatives_1_2_0; }

		//multiplicativeCS
		public RuleCall getArgumentMultiplicativeCSParserRuleCall_1_2_0_0() { return cArgumentMultiplicativeCSParserRuleCall_1_2_0_0; }

		//LetExpCS
		public RuleCall getArgumentLetExpCSParserRuleCall_1_2_0_1() { return cArgumentLetExpCSParserRuleCall_1_2_0_1; }
	}

	public class MultiplicativeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "multiplicativeCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cArgumentAlternatives_1_2_0 = (Alternatives)cArgumentAssignment_1_2.eContents().get(0);
		private final RuleCall cArgumentUnaryCSParserRuleCall_1_2_0_0 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cArgumentLetExpCSParserRuleCall_1_2_0_1 = (RuleCall)cArgumentAlternatives_1_2_0.eContents().get(1);
		
		//multiplicativeCS returns ExpCS:
		//	unaryCS ({InfixExpCS.source=current} op=("*" | "/") argument=(unaryCS | LetExpCS))*;
		public ParserRule getRule() { return rule; }

		//unaryCS ({InfixExpCS.source=current} op=("*" | "/") argument=(unaryCS | LetExpCS))*
		public Group getGroup() { return cGroup; }

		//unaryCS
		public RuleCall getUnaryCSParserRuleCall_0() { return cUnaryCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op=("*" | "/") argument=(unaryCS | LetExpCS))*
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op=("*" | "/")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"*" | "/"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"*"
		public Keyword getOpAsteriskKeyword_1_1_0_0() { return cOpAsteriskKeyword_1_1_0_0; }

		//"/"
		public Keyword getOpSolidusKeyword_1_1_0_1() { return cOpSolidusKeyword_1_1_0_1; }

		//argument=(unaryCS | LetExpCS)
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//unaryCS | LetExpCS
		public Alternatives getArgumentAlternatives_1_2_0() { return cArgumentAlternatives_1_2_0; }

		//unaryCS
		public RuleCall getArgumentUnaryCSParserRuleCall_1_2_0_0() { return cArgumentUnaryCSParserRuleCall_1_2_0_0; }

		//LetExpCS
		public RuleCall getArgumentLetExpCSParserRuleCall_1_2_0_1() { return cArgumentLetExpCSParserRuleCall_1_2_0_1; }
	}

	public class UnaryCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unaryCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNavigationExpCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPrefixExpCSAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpNotKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cSourceAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSourceUnaryCSParserRuleCall_1_2_0 = (RuleCall)cSourceAssignment_1_2.eContents().get(0);
		
		//unaryCS returns ExpCS:
		//	NavigationExpCS | {PrefixExpCS} op=("-" | "not") source=unaryCS;
		public ParserRule getRule() { return rule; }

		//NavigationExpCS | {PrefixExpCS} op=("-" | "not") source=unaryCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//NavigationExpCS
		public RuleCall getNavigationExpCSParserRuleCall_0() { return cNavigationExpCSParserRuleCall_0; }

		//{PrefixExpCS} op=("-" | "not") source=unaryCS
		public Group getGroup_1() { return cGroup_1; }

		//{PrefixExpCS}
		public Action getPrefixExpCSAction_1_0() { return cPrefixExpCSAction_1_0; }

		//op=("-" | "not")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"-" | "not"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"-"
		public Keyword getOpHyphenMinusKeyword_1_1_0_0() { return cOpHyphenMinusKeyword_1_1_0_0; }

		//"not"
		public Keyword getOpNotKeyword_1_1_0_1() { return cOpNotKeyword_1_1_0_1; }

		//source=unaryCS
		public Assignment getSourceAssignment_1_2() { return cSourceAssignment_1_2; }

		//unaryCS
		public RuleCall getSourceUnaryCSParserRuleCall_1_2_0() { return cSourceUnaryCSParserRuleCall_1_2_0; }
	}

	public class NavigationExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NavigationExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSubNavigationExpCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpFullStopKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cArgumentNavigatingExpCSParserRuleCall_1_2_0 = (RuleCall)cArgumentAssignment_1_2.eContents().get(0);
		
		//NavigationExpCS returns ExpCS:
		//	SubNavigationExpCS ({InfixExpCS.source=current} op=("." | "->") argument=NavigatingExpCS)? //	|	({InfixExpCS.source=current} op='^' argument=NavigatingExpCS)
		//
		//	//	|	({InfixExpCS.source=current} op='^^' argument=NavigatingExpCS)
		//
		//;
		public ParserRule getRule() { return rule; }

		//SubNavigationExpCS ({InfixExpCS.source=current} op=("." | "->") argument=NavigatingExpCS)? //	|	({InfixExpCS.source=current} op='^' argument=NavigatingExpCS)
		//
		////	|	({InfixExpCS.source=current} op='^^' argument=NavigatingExpCS)
		public Group getGroup() { return cGroup; }

		//SubNavigationExpCS
		public RuleCall getSubNavigationExpCSParserRuleCall_0() { return cSubNavigationExpCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op=("." | "->") argument=NavigatingExpCS)?
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op=("." | "->")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"." | "->"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"."
		public Keyword getOpFullStopKeyword_1_1_0_0() { return cOpFullStopKeyword_1_1_0_0; }

		//"->"
		public Keyword getOpHyphenMinusGreaterThanSignKeyword_1_1_0_1() { return cOpHyphenMinusGreaterThanSignKeyword_1_1_0_1; }

		//argument=NavigatingExpCS
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//NavigatingExpCS
		public RuleCall getArgumentNavigatingExpCSParserRuleCall_1_2_0() { return cArgumentNavigatingExpCSParserRuleCall_1_2_0; }
	}

	public class NavigatingExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NavigatingExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSubNavigatingExpCSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInfixExpCSSourceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpFullStopKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cArgumentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cArgumentNavigatingExpCSParserRuleCall_1_2_0 = (RuleCall)cArgumentAssignment_1_2.eContents().get(0);
		
		//// Follows ., ->, ^
		//
		//NavigatingExpCS returns ExpCS:
		//	SubNavigatingExpCS ({InfixExpCS.source=current} op=("." | "->") argument=NavigatingExpCS)? //	|	({InfixExpCS.source=current} op='^' argument=NavigatingExpCS)
		//
		//	//	|	({InfixExpCS.source=current} op='^^' argument=NavigatingExpCS)
		//
		//;
		public ParserRule getRule() { return rule; }

		//SubNavigatingExpCS ({InfixExpCS.source=current} op=("." | "->") argument=NavigatingExpCS)? //	|	({InfixExpCS.source=current} op='^' argument=NavigatingExpCS)
		//
		////	|	({InfixExpCS.source=current} op='^^' argument=NavigatingExpCS)
		public Group getGroup() { return cGroup; }

		//SubNavigatingExpCS
		public RuleCall getSubNavigatingExpCSParserRuleCall_0() { return cSubNavigatingExpCSParserRuleCall_0; }

		//({InfixExpCS.source=current} op=("." | "->") argument=NavigatingExpCS)?
		public Group getGroup_1() { return cGroup_1; }

		//{InfixExpCS.source=current}
		public Action getInfixExpCSSourceAction_1_0() { return cInfixExpCSSourceAction_1_0; }

		//op=("." | "->")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"." | "->"
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//"."
		public Keyword getOpFullStopKeyword_1_1_0_0() { return cOpFullStopKeyword_1_1_0_0; }

		//"->"
		public Keyword getOpHyphenMinusGreaterThanSignKeyword_1_1_0_1() { return cOpHyphenMinusGreaterThanSignKeyword_1_1_0_1; }

		//argument=NavigatingExpCS
		public Assignment getArgumentAssignment_1_2() { return cArgumentAssignment_1_2; }

		//NavigatingExpCS
		public RuleCall getArgumentNavigatingExpCSParserRuleCall_1_2_0() { return cArgumentNavigatingExpCSParserRuleCall_1_2_0; }
	}

	public class SubNavigationExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubNavigationExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRoundBracketExpCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSquareBracketExpCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSelfExpCSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPrimitiveLiteralExpCSParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTupleLiteralExpCSParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cCollectionLiteralExpCSParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cPreExpCSParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cTypeExpCSParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cIfExpCSParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final Group cGroup_9 = (Group)cAlternatives.eContents().get(9);
		private final Keyword cLeftParenthesisKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Action cNestedExpCSAction_9_1 = (Action)cGroup_9.eContents().get(1);
		private final Assignment cSourceAssignment_9_2 = (Assignment)cGroup_9.eContents().get(2);
		private final RuleCall cSourceExpCSParserRuleCall_9_2_0 = (RuleCall)cSourceAssignment_9_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_9_3 = (Keyword)cGroup_9.eContents().get(3);
		
		//// May be be followed by ., ->, ^
		//
		//SubNavigationExpCS returns ExpCS:
		//	RoundBracketExpCS | SquareBracketExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS |
		//	CollectionLiteralExpCS | PreExpCS | TypeExpCS | IfExpCS | "(" {NestedExpCS} source=ExpCS ")";
		public ParserRule getRule() { return rule; }

		//RoundBracketExpCS | SquareBracketExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS | CollectionLiteralExpCS
		//| PreExpCS | TypeExpCS | IfExpCS | "(" {NestedExpCS} source=ExpCS ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//RoundBracketExpCS
		public RuleCall getRoundBracketExpCSParserRuleCall_0() { return cRoundBracketExpCSParserRuleCall_0; }

		//SquareBracketExpCS
		public RuleCall getSquareBracketExpCSParserRuleCall_1() { return cSquareBracketExpCSParserRuleCall_1; }

		//SelfExpCS
		public RuleCall getSelfExpCSParserRuleCall_2() { return cSelfExpCSParserRuleCall_2; }

		//PrimitiveLiteralExpCS
		public RuleCall getPrimitiveLiteralExpCSParserRuleCall_3() { return cPrimitiveLiteralExpCSParserRuleCall_3; }

		//TupleLiteralExpCS
		public RuleCall getTupleLiteralExpCSParserRuleCall_4() { return cTupleLiteralExpCSParserRuleCall_4; }

		//CollectionLiteralExpCS
		public RuleCall getCollectionLiteralExpCSParserRuleCall_5() { return cCollectionLiteralExpCSParserRuleCall_5; }

		//PreExpCS
		public RuleCall getPreExpCSParserRuleCall_6() { return cPreExpCSParserRuleCall_6; }

		//TypeExpCS
		public RuleCall getTypeExpCSParserRuleCall_7() { return cTypeExpCSParserRuleCall_7; }

		//IfExpCS
		public RuleCall getIfExpCSParserRuleCall_8() { return cIfExpCSParserRuleCall_8; }

		//"(" {NestedExpCS} source=ExpCS ")"
		public Group getGroup_9() { return cGroup_9; }

		//"("
		public Keyword getLeftParenthesisKeyword_9_0() { return cLeftParenthesisKeyword_9_0; }

		//{NestedExpCS}
		public Action getNestedExpCSAction_9_1() { return cNestedExpCSAction_9_1; }

		//source=ExpCS
		public Assignment getSourceAssignment_9_2() { return cSourceAssignment_9_2; }

		//ExpCS
		public RuleCall getSourceExpCSParserRuleCall_9_2_0() { return cSourceExpCSParserRuleCall_9_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_9_3() { return cRightParenthesisKeyword_9_3; }
	}

	public class SubNavigatingExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubNavigatingExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRoundBracketExpCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSquareBracketExpCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPreExpCSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cNameExpCSParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// Follows ., ->, ^, May be be followed by ., ->, ^
		//
		//SubNavigatingExpCS returns ExpCS:
		//	RoundBracketExpCS | SquareBracketExpCS | PreExpCS | NameExpCS;
		public ParserRule getRule() { return rule; }

		//RoundBracketExpCS | SquareBracketExpCS | PreExpCS | NameExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//RoundBracketExpCS
		public RuleCall getRoundBracketExpCSParserRuleCall_0() { return cRoundBracketExpCSParserRuleCall_0; }

		//SquareBracketExpCS
		public RuleCall getSquareBracketExpCSParserRuleCall_1() { return cSquareBracketExpCSParserRuleCall_1; }

		//PreExpCS
		public RuleCall getPreExpCSParserRuleCall_2() { return cPreExpCSParserRuleCall_2; }

		//NameExpCS
		public RuleCall getNameExpCSParserRuleCall_3() { return cNameExpCSParserRuleCall_3; }
	}

	public class IteratorVariableCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "iteratorVariableCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSimpleNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeTypeExpCSParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		
		//iteratorVariableCS returns VariableCS:
		//	name=SimpleName (":" type=TypeExpCS)?;
		public ParserRule getRule() { return rule; }

		//name=SimpleName (":" type=TypeExpCS)?
		public Group getGroup() { return cGroup; }

		//name=SimpleName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SimpleName
		public RuleCall getNameSimpleNameParserRuleCall_0_0() { return cNameSimpleNameParserRuleCall_0_0; }

		//(":" type=TypeExpCS)?
		public Group getGroup_1() { return cGroup_1; }

		//":"
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }

		//type=TypeExpCS
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }

		//TypeExpCS
		public RuleCall getTypeTypeExpCSParserRuleCall_1_1_0() { return cTypeTypeExpCSParserRuleCall_1_1_0; }
	}

	public class IteratorAccumulatorCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "iteratorAccumulatorCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSimpleNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeExpCSParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cInitExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInitExpressionExpCSParserRuleCall_4_0 = (RuleCall)cInitExpressionAssignment_4.eContents().get(0);
		
		//iteratorAccumulatorCS returns VariableCS:
		//	name=SimpleName ":" type=TypeExpCS "=" initExpression=ExpCS;
		public ParserRule getRule() { return rule; }

		//name=SimpleName ":" type=TypeExpCS "=" initExpression=ExpCS
		public Group getGroup() { return cGroup; }

		//name=SimpleName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SimpleName
		public RuleCall getNameSimpleNameParserRuleCall_0_0() { return cNameSimpleNameParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=TypeExpCS
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//TypeExpCS
		public RuleCall getTypeTypeExpCSParserRuleCall_2_0() { return cTypeTypeExpCSParserRuleCall_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//initExpression=ExpCS
		public Assignment getInitExpressionAssignment_4() { return cInitExpressionAssignment_4; }

		//ExpCS
		public RuleCall getInitExpressionExpCSParserRuleCall_4_0() { return cInitExpressionExpCSParserRuleCall_4_0; }
	}

	public class RoundBracketExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RoundBracketExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameNameExpCSParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommercialAtKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cPreAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cPrePreKeyword_1_1_0 = (Keyword)cPreAssignment_1_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cVariable1Assignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cVariable1IteratorVariableCSParserRuleCall_3_0_0 = (RuleCall)cVariable1Assignment_3_0.eContents().get(0);
		private final Alternatives cAlternatives_3_1 = (Alternatives)cGroup_3.eContents().get(1);
		private final Group cGroup_3_1_0 = (Group)cAlternatives_3_1.eContents().get(0);
		private final Keyword cCommaKeyword_3_1_0_0 = (Keyword)cGroup_3_1_0.eContents().get(0);
		private final Assignment cVariable2Assignment_3_1_0_1 = (Assignment)cGroup_3_1_0.eContents().get(1);
		private final RuleCall cVariable2IteratorVariableCSParserRuleCall_3_1_0_1_0 = (RuleCall)cVariable2Assignment_3_1_0_1.eContents().get(0);
		private final Group cGroup_3_1_1 = (Group)cAlternatives_3_1.eContents().get(1);
		private final Keyword cSemicolonKeyword_3_1_1_0 = (Keyword)cGroup_3_1_1.eContents().get(0);
		private final Assignment cVariable2Assignment_3_1_1_1 = (Assignment)cGroup_3_1_1.eContents().get(1);
		private final RuleCall cVariable2IteratorAccumulatorCSParserRuleCall_3_1_1_1_0 = (RuleCall)cVariable2Assignment_3_1_1_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cArgumentsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cArgumentsExpCSParserRuleCall_4_0_0 = (RuleCall)cArgumentsAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cArgumentsExpCSParserRuleCall_4_1_1_0 = (RuleCall)cArgumentsAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//RoundBracketExpCS:
		//	name=NameExpCS ("@" pre?="pre")? "(" (variable1=iteratorVariableCS ("," variable2=iteratorVariableCS | ";"
		//	variable2=iteratorAccumulatorCS)? "|")? (arguments+=ExpCS ("," arguments+=ExpCS)*)? ")";
		public ParserRule getRule() { return rule; }

		//name=NameExpCS ("@" pre?="pre")? "(" (variable1=iteratorVariableCS ("," variable2=iteratorVariableCS | ";"
		//variable2=iteratorAccumulatorCS)? "|")? (arguments+=ExpCS ("," arguments+=ExpCS)*)? ")"
		public Group getGroup() { return cGroup; }

		//name=NameExpCS
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//NameExpCS
		public RuleCall getNameNameExpCSParserRuleCall_0_0() { return cNameNameExpCSParserRuleCall_0_0; }

		//("@" pre?="pre")?
		public Group getGroup_1() { return cGroup_1; }

		//"@"
		public Keyword getCommercialAtKeyword_1_0() { return cCommercialAtKeyword_1_0; }

		//pre?="pre"
		public Assignment getPreAssignment_1_1() { return cPreAssignment_1_1; }

		//"pre"
		public Keyword getPrePreKeyword_1_1_0() { return cPrePreKeyword_1_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(variable1=iteratorVariableCS ("," variable2=iteratorVariableCS | ";" variable2=iteratorAccumulatorCS)? "|")?
		public Group getGroup_3() { return cGroup_3; }

		//variable1=iteratorVariableCS
		public Assignment getVariable1Assignment_3_0() { return cVariable1Assignment_3_0; }

		//iteratorVariableCS
		public RuleCall getVariable1IteratorVariableCSParserRuleCall_3_0_0() { return cVariable1IteratorVariableCSParserRuleCall_3_0_0; }

		//("," variable2=iteratorVariableCS | ";" variable2=iteratorAccumulatorCS)?
		public Alternatives getAlternatives_3_1() { return cAlternatives_3_1; }

		//"," variable2=iteratorVariableCS
		public Group getGroup_3_1_0() { return cGroup_3_1_0; }

		//","
		public Keyword getCommaKeyword_3_1_0_0() { return cCommaKeyword_3_1_0_0; }

		//variable2=iteratorVariableCS
		public Assignment getVariable2Assignment_3_1_0_1() { return cVariable2Assignment_3_1_0_1; }

		//iteratorVariableCS
		public RuleCall getVariable2IteratorVariableCSParserRuleCall_3_1_0_1_0() { return cVariable2IteratorVariableCSParserRuleCall_3_1_0_1_0; }

		//";" variable2=iteratorAccumulatorCS
		public Group getGroup_3_1_1() { return cGroup_3_1_1; }

		//";"
		public Keyword getSemicolonKeyword_3_1_1_0() { return cSemicolonKeyword_3_1_1_0; }

		//variable2=iteratorAccumulatorCS
		public Assignment getVariable2Assignment_3_1_1_1() { return cVariable2Assignment_3_1_1_1; }

		//iteratorAccumulatorCS
		public RuleCall getVariable2IteratorAccumulatorCSParserRuleCall_3_1_1_1_0() { return cVariable2IteratorAccumulatorCSParserRuleCall_3_1_1_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_3_2() { return cVerticalLineKeyword_3_2; }

		//(arguments+=ExpCS ("," arguments+=ExpCS)*)?
		public Group getGroup_4() { return cGroup_4; }

		//arguments+=ExpCS
		public Assignment getArgumentsAssignment_4_0() { return cArgumentsAssignment_4_0; }

		//ExpCS
		public RuleCall getArgumentsExpCSParserRuleCall_4_0_0() { return cArgumentsExpCSParserRuleCall_4_0_0; }

		//("," arguments+=ExpCS)*
		public Group getGroup_4_1() { return cGroup_4_1; }

		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }

		//arguments+=ExpCS
		public Assignment getArgumentsAssignment_4_1_1() { return cArgumentsAssignment_4_1_1; }

		//ExpCS
		public RuleCall getArgumentsExpCSParserRuleCall_4_1_1_0() { return cArgumentsExpCSParserRuleCall_4_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class SquareBracketExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SquareBracketExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameNameExpCSParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgumentsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentsExpCSParserRuleCall_2_0 = (RuleCall)cArgumentsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cArgumentsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cArgumentsExpCSParserRuleCall_3_1_0 = (RuleCall)cArgumentsAssignment_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommercialAtKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cPreAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final Keyword cPrePreKeyword_5_1_0 = (Keyword)cPreAssignment_5_1.eContents().get(0);
		
		//SquareBracketExpCS:
		//	name=NameExpCS "[" arguments+=ExpCS ("," arguments+=ExpCS)* "]" ("@" pre?="pre")?;
		public ParserRule getRule() { return rule; }

		//name=NameExpCS "[" arguments+=ExpCS ("," arguments+=ExpCS)* "]" ("@" pre?="pre")?
		public Group getGroup() { return cGroup; }

		//name=NameExpCS
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//NameExpCS
		public RuleCall getNameNameExpCSParserRuleCall_0_0() { return cNameNameExpCSParserRuleCall_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//arguments+=ExpCS
		public Assignment getArgumentsAssignment_2() { return cArgumentsAssignment_2; }

		//ExpCS
		public RuleCall getArgumentsExpCSParserRuleCall_2_0() { return cArgumentsExpCSParserRuleCall_2_0; }

		//("," arguments+=ExpCS)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//arguments+=ExpCS
		public Assignment getArgumentsAssignment_3_1() { return cArgumentsAssignment_3_1; }

		//ExpCS
		public RuleCall getArgumentsExpCSParserRuleCall_3_1_0() { return cArgumentsExpCSParserRuleCall_3_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }

		//("@" pre?="pre")?
		public Group getGroup_5() { return cGroup_5; }

		//"@"
		public Keyword getCommercialAtKeyword_5_0() { return cCommercialAtKeyword_5_0; }

		//pre?="pre"
		public Assignment getPreAssignment_5_1() { return cPreAssignment_5_1; }

		//"pre"
		public Keyword getPrePreKeyword_5_1_0() { return cPrePreKeyword_5_1_0; }
	}

	public class PreExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PreExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameNameExpCSParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cCommercialAtKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cPreKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PreExpCS:
		//	name=NameExpCS "@" "pre";
		public ParserRule getRule() { return rule; }

		//name=NameExpCS "@" "pre"
		public Group getGroup() { return cGroup; }

		//name=NameExpCS
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//NameExpCS
		public RuleCall getNameNameExpCSParserRuleCall_0_0() { return cNameNameExpCSParserRuleCall_0_0; }

		//"@"
		public Keyword getCommercialAtKeyword_1() { return cCommercialAtKeyword_1; }

		//"pre"
		public Keyword getPreKeyword_2() { return cPreKeyword_2; }
	}

	public class SelfExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelfExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelfExpCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSelfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//SelfExpCS:
		//	{SelfExpCS} "self";
		public ParserRule getRule() { return rule; }

		//{SelfExpCS} "self"
		public Group getGroup() { return cGroup; }

		//{SelfExpCS}
		public Action getSelfExpCSAction_0() { return cSelfExpCSAction_0; }

		//"self"
		public Keyword getSelfKeyword_1() { return cSelfKeyword_1; }
	}

	public class NameExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NameExpCS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPathNameExpCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleNameExpCSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//NameExpCS:
		//	PathNameExpCS | SimpleNameExpCS;
		public ParserRule getRule() { return rule; }

		//PathNameExpCS | SimpleNameExpCS
		public Alternatives getAlternatives() { return cAlternatives; }

		//PathNameExpCS
		public RuleCall getPathNameExpCSParserRuleCall_0() { return cPathNameExpCSParserRuleCall_0; }

		//SimpleNameExpCS
		public RuleCall getSimpleNameExpCSParserRuleCall_1() { return cSimpleNameExpCSParserRuleCall_1; }
	}

	public class PathNameExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PathNameExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNamespaceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNamespaceNamespaceCSCrossReference_0_0 = (CrossReference)cNamespaceAssignment_0.eContents().get(0);
		private final RuleCall cNamespaceNamespaceCSIdentifierParserRuleCall_0_0_1 = (RuleCall)cNamespaceNamespaceCSCrossReference_0_0.eContents().get(1);
		private final Keyword cColonColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementNameExpCSParserRuleCall_2_0 = (RuleCall)cElementAssignment_2.eContents().get(0);
		
		//PathNameExpCS:
		//	namespace=[base::NamespaceCS|Identifier] "::" element=NameExpCS;
		public ParserRule getRule() { return rule; }

		//namespace=[base::NamespaceCS|Identifier] "::" element=NameExpCS
		public Group getGroup() { return cGroup; }

		//namespace=[base::NamespaceCS|Identifier]
		public Assignment getNamespaceAssignment_0() { return cNamespaceAssignment_0; }

		//[base::NamespaceCS|Identifier]
		public CrossReference getNamespaceNamespaceCSCrossReference_0_0() { return cNamespaceNamespaceCSCrossReference_0_0; }

		//Identifier
		public RuleCall getNamespaceNamespaceCSIdentifierParserRuleCall_0_0_1() { return cNamespaceNamespaceCSIdentifierParserRuleCall_0_0_1; }

		//"::"
		public Keyword getColonColonKeyword_1() { return cColonColonKeyword_1; }

		//element=NameExpCS
		public Assignment getElementAssignment_2() { return cElementAssignment_2; }

		//NameExpCS
		public RuleCall getElementNameExpCSParserRuleCall_2_0() { return cElementNameExpCSParserRuleCall_2_0; }
	}

	public class SimpleNameExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleNameExpCS");
		private final Assignment cElementAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cElementNamedElementCSCrossReference_0 = (CrossReference)cElementAssignment.eContents().get(0);
		private final RuleCall cElementNamedElementCSIdentifierParserRuleCall_0_1 = (RuleCall)cElementNamedElementCSCrossReference_0.eContents().get(1);
		
		//SimpleNameExpCS:
		//	element=[base::NamedElementCS|Identifier];
		public ParserRule getRule() { return rule; }

		//element=[base::NamedElementCS|Identifier]
		public Assignment getElementAssignment() { return cElementAssignment; }

		//[base::NamedElementCS|Identifier]
		public CrossReference getElementNamedElementCSCrossReference_0() { return cElementNamedElementCSCrossReference_0; }

		//Identifier
		public RuleCall getElementNamedElementCSIdentifierParserRuleCall_0_1() { return cElementNamedElementCSIdentifierParserRuleCall_0_1; }
	}

	public class IfExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpCSParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenExpressionExpCSParserRuleCall_3_0 = (RuleCall)cThenExpressionAssignment_3.eContents().get(0);
		private final Keyword cElseKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cElseExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseExpressionExpCSParserRuleCall_5_0 = (RuleCall)cElseExpressionAssignment_5.eContents().get(0);
		private final Keyword cEndifKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//IfExpCS:
		//	"if" condition=ExpCS "then" thenExpression=ExpCS "else" elseExpression=ExpCS "endif";
		public ParserRule getRule() { return rule; }

		//"if" condition=ExpCS "then" thenExpression=ExpCS "else" elseExpression=ExpCS "endif"
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//condition=ExpCS
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//ExpCS
		public RuleCall getConditionExpCSParserRuleCall_1_0() { return cConditionExpCSParserRuleCall_1_0; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }

		//thenExpression=ExpCS
		public Assignment getThenExpressionAssignment_3() { return cThenExpressionAssignment_3; }

		//ExpCS
		public RuleCall getThenExpressionExpCSParserRuleCall_3_0() { return cThenExpressionExpCSParserRuleCall_3_0; }

		//"else"
		public Keyword getElseKeyword_4() { return cElseKeyword_4; }

		//elseExpression=ExpCS
		public Assignment getElseExpressionAssignment_5() { return cElseExpressionAssignment_5; }

		//ExpCS
		public RuleCall getElseExpressionExpCSParserRuleCall_5_0() { return cElseExpressionExpCSParserRuleCall_5_0; }

		//"endif"
		public Keyword getEndifKeyword_6() { return cEndifKeyword_6; }
	}

	public class LetExpCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LetExpCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableLetVariableCSParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVariableAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVariableLetVariableCSParserRuleCall_2_1_0 = (RuleCall)cVariableAssignment_2_1.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cInAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInExpCSParserRuleCall_4_0 = (RuleCall)cInAssignment_4.eContents().get(0);
		
		//LetExpCS:
		//	"let" variable+=LetVariableCS ("," variable+=LetVariableCS)* "in" in=ExpCS;
		public ParserRule getRule() { return rule; }

		//"let" variable+=LetVariableCS ("," variable+=LetVariableCS)* "in" in=ExpCS
		public Group getGroup() { return cGroup; }

		//"let"
		public Keyword getLetKeyword_0() { return cLetKeyword_0; }

		//variable+=LetVariableCS
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }

		//LetVariableCS
		public RuleCall getVariableLetVariableCSParserRuleCall_1_0() { return cVariableLetVariableCSParserRuleCall_1_0; }

		//("," variable+=LetVariableCS)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//variable+=LetVariableCS
		public Assignment getVariableAssignment_2_1() { return cVariableAssignment_2_1; }

		//LetVariableCS
		public RuleCall getVariableLetVariableCSParserRuleCall_2_1_0() { return cVariableLetVariableCSParserRuleCall_2_1_0; }

		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }

		//in=ExpCS
		public Assignment getInAssignment_4() { return cInAssignment_4; }

		//ExpCS
		public RuleCall getInExpCSParserRuleCall_4_0() { return cInExpCSParserRuleCall_4_0; }
	}

	public class LetVariableCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LetVariableCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSimpleNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeExpCSParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cInitExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInitExpressionExpCSParserRuleCall_4_0 = (RuleCall)cInitExpressionAssignment_4.eContents().get(0);
		
		//LetVariableCS returns VariableCS:
		//	name=SimpleName ":" type=TypeExpCS "=" initExpression=ExpCS;
		public ParserRule getRule() { return rule; }

		//name=SimpleName ":" type=TypeExpCS "=" initExpression=ExpCS
		public Group getGroup() { return cGroup; }

		//name=SimpleName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//SimpleName
		public RuleCall getNameSimpleNameParserRuleCall_0_0() { return cNameSimpleNameParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=TypeExpCS
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//TypeExpCS
		public RuleCall getTypeTypeExpCSParserRuleCall_2_0() { return cTypeTypeExpCSParserRuleCall_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//initExpression=ExpCS
		public Assignment getInitExpressionAssignment_4() { return cInitExpressionAssignment_4; }

		//ExpCS
		public RuleCall getInitExpressionExpCSParserRuleCall_4_0() { return cInitExpressionExpCSParserRuleCall_4_0; }
	}
	
	
	private ModelElements pModel;
	private TerminalRule tDOUBLE_QUOTED_STRING;
	private TerminalRule tSINGLE_QUOTED_STRING;
	private TerminalRule tID;
	private TerminalRule tINT;
	private NUMBER_LITERALElements pNUMBER_LITERAL;
	private TerminalRule tML_COMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tANY_OTHER;
	private EssentialOCLReservedKeywordsElements pEssentialOCLReservedKeywords;
	private EssentialOCLRestrictedKeywordsElements pEssentialOCLRestrictedKeywords;
	private RestrictedKeywordsElements pRestrictedKeywords;
	private IdentifierElements pIdentifier;
	private StringLiteralElements pStringLiteral;
	private SimpleNameElements pSimpleName;
	private PrimitiveTypeIdentifierElements pPrimitiveTypeIdentifier;
	private PrimitiveTypeCSElements pPrimitiveTypeCS;
	private CollectionTypeIdentifierElements pCollectionTypeIdentifier;
	private TypeExpCSElements pTypeExpCS;
	private CollectionTypeCSElements pCollectionTypeCS;
	private TupleTypeCSElements pTupleTypeCS;
	private TuplePartCSElements pTuplePartCS;
	private CollectionLiteralExpCSElements pCollectionLiteralExpCS;
	private CollectionLiteralPartCSElements pCollectionLiteralPartCS;
	private PrimitiveLiteralExpCSElements pPrimitiveLiteralExpCS;
	private TupleLiteralExpCSElements pTupleLiteralExpCS;
	private TupleLiteralPartCSElements pTupleLiteralPartCS;
	private NumberLiteralExpCSElements pNumberLiteralExpCS;
	private StringLiteralExpCSElements pStringLiteralExpCS;
	private BooleanLiteralExpCSElements pBooleanLiteralExpCS;
	private InvalidLiteralExpCSElements pInvalidLiteralExpCS;
	private NullLiteralExpCSElements pNullLiteralExpCS;
	private ExpCSElements pExpCS;
	private ImpliesCSElements pImpliesCS;
	private XorCSElements pXorCS;
	private OrCSElements pOrCS;
	private AndCSElements pAndCS;
	private EqualityCSElements pEqualityCS;
	private RelationalCSElements pRelationalCS;
	private AdditiveCSElements pAdditiveCS;
	private MultiplicativeCSElements pMultiplicativeCS;
	private UnaryCSElements pUnaryCS;
	private NavigationExpCSElements pNavigationExpCS;
	private NavigatingExpCSElements pNavigatingExpCS;
	private SubNavigationExpCSElements pSubNavigationExpCS;
	private SubNavigatingExpCSElements pSubNavigatingExpCS;
	private IteratorVariableCSElements pIteratorVariableCS;
	private IteratorAccumulatorCSElements pIteratorAccumulatorCS;
	private RoundBracketExpCSElements pRoundBracketExpCS;
	private SquareBracketExpCSElements pSquareBracketExpCS;
	private PreExpCSElements pPreExpCS;
	private SelfExpCSElements pSelfExpCS;
	private NameExpCSElements pNameExpCS;
	private PathNameExpCSElements pPathNameExpCS;
	private SimpleNameExpCSElements pSimpleNameExpCS;
	private IfExpCSElements pIfExpCS;
	private LetExpCSElements pLetExpCS;
	private LetVariableCSElements pLetVariableCS;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public EssentialOCLGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	////generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
	//
	//Model returns ExpCS:
	//	ExpCS;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//terminal DOUBLE_QUOTED_STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"";
	public TerminalRule getDOUBLE_QUOTED_STRINGRule() {
		return (tDOUBLE_QUOTED_STRING != null) ? tDOUBLE_QUOTED_STRING : (tDOUBLE_QUOTED_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOUBLE_QUOTED_STRING"));
	} 

	//terminal SINGLE_QUOTED_STRING:
	//	"\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSINGLE_QUOTED_STRINGRule() {
		return (tSINGLE_QUOTED_STRING != null) ? tSINGLE_QUOTED_STRING : (tSINGLE_QUOTED_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SINGLE_QUOTED_STRING"));
	} 

	//terminal ID:
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")* | "_" SINGLE_QUOTED_STRING;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//// String to allow diverse re-use
	//
	//terminal INT:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//// Not terminal to allow parser backtracking to sort out "5..7"
	//
	//NUMBER_LITERAL returns BigNumber:
	//	INT ("." INT)? (("e" | "E") ("+" | "-")? INT)?;
	public NUMBER_LITERALElements getNUMBER_LITERALAccess() {
		return (pNUMBER_LITERAL != null) ? pNUMBER_LITERAL : (pNUMBER_LITERAL = new NUMBER_LITERALElements());
	}
	
	public ParserRule getNUMBER_LITERALRule() {
		return getNUMBER_LITERALAccess().getRule();
	}

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//terminal SL_COMMENT:
	//	"--" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 

	//EssentialOCLReservedKeywords returns ecore::EString:
	//	"and" | "else" | "endif" | "if" | "implies" | "in" | "let" | "not" | "or" | "then" | "xor";
	public EssentialOCLReservedKeywordsElements getEssentialOCLReservedKeywordsAccess() {
		return (pEssentialOCLReservedKeywords != null) ? pEssentialOCLReservedKeywords : (pEssentialOCLReservedKeywords = new EssentialOCLReservedKeywordsElements());
	}
	
	public ParserRule getEssentialOCLReservedKeywordsRule() {
		return getEssentialOCLReservedKeywordsAccess().getRule();
	}

	//EssentialOCLRestrictedKeywords returns ecore::EString:
	//	"e" | "E";
	public EssentialOCLRestrictedKeywordsElements getEssentialOCLRestrictedKeywordsAccess() {
		return (pEssentialOCLRestrictedKeywords != null) ? pEssentialOCLRestrictedKeywords : (pEssentialOCLRestrictedKeywords = new EssentialOCLRestrictedKeywordsElements());
	}
	
	public ParserRule getEssentialOCLRestrictedKeywordsRule() {
		return getEssentialOCLRestrictedKeywordsAccess().getRule();
	}

	//// Intended to be overridden
	//
	//RestrictedKeywords returns ecore::EString:
	//	EssentialOCLRestrictedKeywords;
	public RestrictedKeywordsElements getRestrictedKeywordsAccess() {
		return (pRestrictedKeywords != null) ? pRestrictedKeywords : (pRestrictedKeywords = new RestrictedKeywordsElements());
	}
	
	public ParserRule getRestrictedKeywordsRule() {
		return getRestrictedKeywordsAccess().getRule();
	}

	//Identifier returns ecore::EString:
	//	ID | RestrictedKeywords;
	public IdentifierElements getIdentifierAccess() {
		return (pIdentifier != null) ? pIdentifier : (pIdentifier = new IdentifierElements());
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}

	//StringLiteral returns ecore::EString:
	//	SINGLE_QUOTED_STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return (pStringLiteral != null) ? pStringLiteral : (pStringLiteral = new StringLiteralElements());
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	////---------------------------------------------------------------------
	//
	////  Names
	//
	////---------------------------------------------------------------------
	//
	/// *  Temporary backward compatibility support for 7.4.8 conceptual usage 
	//
	//conceptualOperationName returns SimpleNameCS:
	//
	//	value='and'
	//
	//	| value='implies'
	//
	//	| value='not'
	//
	//	| value='or'
	//
	//	| value='xor'
	//
	//	| value='<'
	//
	//	| value='<='
	//
	//	| value='>='
	//
	//	| value='>'
	//
	//	| value='='
	//
	//	| value='<>'
	//
	//	| value='+'
	//
	//	| value='-'
	//
	//	| value='*'
	//
	//	| value='/';
	//
	//conceptualOperationNameCS returns SimpleNameCS:
	//
	//	conceptualOperationName; * // *tupleKeywordCS returns ecore::EString:
	//
	//	value='Tuple'; * // *restrictedKeywordCS returns ecore::EString: 
	//
	//	CollectionTypeIdentifierCS
	//
	////  restrictedKeywordCS -> BooleanLiteralExpCS
	//
	////  restrictedKeywordCS -> InvalidLiteralExpCS
	//
	////  restrictedKeywordCS -> NullLiteralExpCS
	//
	////-  restrictedKeywordCS -> selfKeywordCS
	//
	//|	primitiveTypeCS
	//
	//|	tupleKeywordCS; * /SimpleName returns ecore::EString:
	//	Identifier;
	public SimpleNameElements getSimpleNameAccess() {
		return (pSimpleName != null) ? pSimpleName : (pSimpleName = new SimpleNameElements());
	}
	
	public ParserRule getSimpleNameRule() {
		return getSimpleNameAccess().getRule();
	}

	////pathNameCS returns NameExpCS:
	//
	////	(namespace=[NamespaceCS|Identifier] '::')* element=[NamedElementCS|Identifier]
	//
	////
	//
	////	ref=[ModelElementCS|PathName]
	//
	////;
	//
	////---------------------------------------------------------------------
	//
	////  Types
	//
	////---------------------------------------------------------------------
	//
	//PrimitiveTypeIdentifier returns ecore::EString:
	//	"Boolean" | "Integer" | "Real" | "String" | "UnlimitedNatural" | "OclAny" | "OclInvalid" | "OclVoid";
	public PrimitiveTypeIdentifierElements getPrimitiveTypeIdentifierAccess() {
		return (pPrimitiveTypeIdentifier != null) ? pPrimitiveTypeIdentifier : (pPrimitiveTypeIdentifier = new PrimitiveTypeIdentifierElements());
	}
	
	public ParserRule getPrimitiveTypeIdentifierRule() {
		return getPrimitiveTypeIdentifierAccess().getRule();
	}

	//PrimitiveTypeCS:
	//	name=PrimitiveTypeIdentifier;
	public PrimitiveTypeCSElements getPrimitiveTypeCSAccess() {
		return (pPrimitiveTypeCS != null) ? pPrimitiveTypeCS : (pPrimitiveTypeCS = new PrimitiveTypeCSElements());
	}
	
	public ParserRule getPrimitiveTypeCSRule() {
		return getPrimitiveTypeCSAccess().getRule();
	}

	//CollectionTypeIdentifier returns ecore::EString:
	//	"Set" | "Bag" | "Sequence" | "Collection" | "OrderedSet";
	public CollectionTypeIdentifierElements getCollectionTypeIdentifierAccess() {
		return (pCollectionTypeIdentifier != null) ? pCollectionTypeIdentifier : (pCollectionTypeIdentifier = new CollectionTypeIdentifierElements());
	}
	
	public ParserRule getCollectionTypeIdentifierRule() {
		return getCollectionTypeIdentifierAccess().getRule();
	}

	//TypeExpCS:
	//	PrimitiveTypeCS | NameExpCS | CollectionTypeCS | TupleTypeCS;
	public TypeExpCSElements getTypeExpCSAccess() {
		return (pTypeExpCS != null) ? pTypeExpCS : (pTypeExpCS = new TypeExpCSElements());
	}
	
	public ParserRule getTypeExpCSRule() {
		return getTypeExpCSAccess().getRule();
	}

	//CollectionTypeCS:
	//	name=CollectionTypeIdentifier ("(" typeCS=TypeExpCS ")")?;
	public CollectionTypeCSElements getCollectionTypeCSAccess() {
		return (pCollectionTypeCS != null) ? pCollectionTypeCS : (pCollectionTypeCS = new CollectionTypeCSElements());
	}
	
	public ParserRule getCollectionTypeCSRule() {
		return getCollectionTypeCSAccess().getRule();
	}

	//TupleTypeCS:
	//	name="Tuple" "(" (part+=tuplePartCS ("," part+=tuplePartCS)*)? ")";
	public TupleTypeCSElements getTupleTypeCSAccess() {
		return (pTupleTypeCS != null) ? pTupleTypeCS : (pTupleTypeCS = new TupleTypeCSElements());
	}
	
	public ParserRule getTupleTypeCSRule() {
		return getTupleTypeCSAccess().getRule();
	}

	//tuplePartCS returns VariableCS:
	//	name=SimpleName ":" type=TypeExpCS;
	public TuplePartCSElements getTuplePartCSAccess() {
		return (pTuplePartCS != null) ? pTuplePartCS : (pTuplePartCS = new TuplePartCSElements());
	}
	
	public ParserRule getTuplePartCSRule() {
		return getTuplePartCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	//
	////  Literals
	//
	////---------------------------------------------------------------------
	//
	//// EnumLiteralExpCS is parsed as a PropertyCallExpCS[C]
	//
	////  LiteralExpCS -> EnumLiteralExpCS
	//
	////LiteralExpCS returns LiteralExpCS:
	//
	////	CollectionLiteralExpCS
	//
	////|	TupleLiteralExpCS
	//
	////|	PrimitiveLiteralExpCS
	//
	////|	primitiveTypeCS
	//
	////|	NameExpCS
	//
	//////|	collectionTypeCS
	//
	////|	TupleTypeCS
	//
	////;
	//
	//// or CollectionTypeLiteral
	//
	//CollectionLiteralExpCS returns LiteralExpCS:
	//	CollectionTypeCS ({CollectionLiteralExpCS.typeCS=current} "{" (collectionLiteralParts+=CollectionLiteralPartCS (","
	//	collectionLiteralParts+=CollectionLiteralPartCS)*)? "}")?;
	public CollectionLiteralExpCSElements getCollectionLiteralExpCSAccess() {
		return (pCollectionLiteralExpCS != null) ? pCollectionLiteralExpCS : (pCollectionLiteralExpCS = new CollectionLiteralExpCSElements());
	}
	
	public ParserRule getCollectionLiteralExpCSRule() {
		return getCollectionLiteralExpCSAccess().getRule();
	}

	//CollectionLiteralPartCS:
	//	expressionCS=ExpCS (".." lastExpressionCS=ExpCS)?;
	public CollectionLiteralPartCSElements getCollectionLiteralPartCSAccess() {
		return (pCollectionLiteralPartCS != null) ? pCollectionLiteralPartCS : (pCollectionLiteralPartCS = new CollectionLiteralPartCSElements());
	}
	
	public ParserRule getCollectionLiteralPartCSRule() {
		return getCollectionLiteralPartCSAccess().getRule();
	}

	//PrimitiveLiteralExpCS:
	//	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | InvalidLiteralExpCS | NullLiteralExpCS;
	public PrimitiveLiteralExpCSElements getPrimitiveLiteralExpCSAccess() {
		return (pPrimitiveLiteralExpCS != null) ? pPrimitiveLiteralExpCS : (pPrimitiveLiteralExpCS = new PrimitiveLiteralExpCSElements());
	}
	
	public ParserRule getPrimitiveLiteralExpCSRule() {
		return getPrimitiveLiteralExpCSAccess().getRule();
	}

	//// or TupleTypeLiteral
	//
	//TupleLiteralExpCS:
	//	{TupleLiteralExpCS} "Tuple" ("{" part+=TupleLiteralPartCS ("," part+=TupleLiteralPartCS)* "}")?;
	public TupleLiteralExpCSElements getTupleLiteralExpCSAccess() {
		return (pTupleLiteralExpCS != null) ? pTupleLiteralExpCS : (pTupleLiteralExpCS = new TupleLiteralExpCSElements());
	}
	
	public ParserRule getTupleLiteralExpCSRule() {
		return getTupleLiteralExpCSAccess().getRule();
	}

	//TupleLiteralPartCS returns VariableCS:
	//	name=SimpleName (":" type=TypeExpCS)? "=" initExpression=ExpCS;
	public TupleLiteralPartCSElements getTupleLiteralPartCSAccess() {
		return (pTupleLiteralPartCS != null) ? pTupleLiteralPartCS : (pTupleLiteralPartCS = new TupleLiteralPartCSElements());
	}
	
	public ParserRule getTupleLiteralPartCSRule() {
		return getTupleLiteralPartCSAccess().getRule();
	}

	//NumberLiteralExpCS:
	//	name=NUMBER_LITERAL;
	public NumberLiteralExpCSElements getNumberLiteralExpCSAccess() {
		return (pNumberLiteralExpCS != null) ? pNumberLiteralExpCS : (pNumberLiteralExpCS = new NumberLiteralExpCSElements());
	}
	
	public ParserRule getNumberLiteralExpCSRule() {
		return getNumberLiteralExpCSAccess().getRule();
	}

	//StringLiteralExpCS:
	//	name+=StringLiteral+;
	public StringLiteralExpCSElements getStringLiteralExpCSAccess() {
		return (pStringLiteralExpCS != null) ? pStringLiteralExpCS : (pStringLiteralExpCS = new StringLiteralExpCSElements());
	}
	
	public ParserRule getStringLiteralExpCSRule() {
		return getStringLiteralExpCSAccess().getRule();
	}

	//BooleanLiteralExpCS:
	//	name="true" | name="false";
	public BooleanLiteralExpCSElements getBooleanLiteralExpCSAccess() {
		return (pBooleanLiteralExpCS != null) ? pBooleanLiteralExpCS : (pBooleanLiteralExpCS = new BooleanLiteralExpCSElements());
	}
	
	public ParserRule getBooleanLiteralExpCSRule() {
		return getBooleanLiteralExpCSAccess().getRule();
	}

	//InvalidLiteralExpCS:
	//	{InvalidLiteralExpCS} "invalid";
	public InvalidLiteralExpCSElements getInvalidLiteralExpCSAccess() {
		return (pInvalidLiteralExpCS != null) ? pInvalidLiteralExpCS : (pInvalidLiteralExpCS = new InvalidLiteralExpCSElements());
	}
	
	public ParserRule getInvalidLiteralExpCSRule() {
		return getInvalidLiteralExpCSAccess().getRule();
	}

	//NullLiteralExpCS:
	//	{NullLiteralExpCS} "null";
	public NullLiteralExpCSElements getNullLiteralExpCSAccess() {
		return (pNullLiteralExpCS != null) ? pNullLiteralExpCS : (pNullLiteralExpCS = new NullLiteralExpCSElements());
	}
	
	public ParserRule getNullLiteralExpCSRule() {
		return getNullLiteralExpCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	//
	////  Expressions
	//
	////---------------------------------------------------------------------
	//
	//// An OclExpressionCS comprising one or more LetExpCS is kept separate to ensure
	//
	////  that let is right associative, whereas infix operators are left associative.
	//
	////   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
	//
	//// is
	//
	////   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
	//
	//ExpCS:
	//	impliesCS | LetExpCS;
	public ExpCSElements getExpCSAccess() {
		return (pExpCS != null) ? pExpCS : (pExpCS = new ExpCSElements());
	}
	
	public ParserRule getExpCSRule() {
		return getExpCSAccess().getRule();
	}

	//impliesCS returns ExpCS:
	//	xorCS ({InfixExpCS.source=current} op="implies" argument=(xorCS | LetExpCS))*;
	public ImpliesCSElements getImpliesCSAccess() {
		return (pImpliesCS != null) ? pImpliesCS : (pImpliesCS = new ImpliesCSElements());
	}
	
	public ParserRule getImpliesCSRule() {
		return getImpliesCSAccess().getRule();
	}

	//xorCS returns ExpCS:
	//	orCS ({InfixExpCS.source=current} op="xor" argument=(orCS | LetExpCS))*;
	public XorCSElements getXorCSAccess() {
		return (pXorCS != null) ? pXorCS : (pXorCS = new XorCSElements());
	}
	
	public ParserRule getXorCSRule() {
		return getXorCSAccess().getRule();
	}

	//orCS returns ExpCS:
	//	andCS ({InfixExpCS.source=current} op="or" argument=(andCS | LetExpCS))*;
	public OrCSElements getOrCSAccess() {
		return (pOrCS != null) ? pOrCS : (pOrCS = new OrCSElements());
	}
	
	public ParserRule getOrCSRule() {
		return getOrCSAccess().getRule();
	}

	//andCS returns ExpCS:
	//	equalityCS ({InfixExpCS.source=current} op="and" argument=(equalityCS | LetExpCS))*;
	public AndCSElements getAndCSAccess() {
		return (pAndCS != null) ? pAndCS : (pAndCS = new AndCSElements());
	}
	
	public ParserRule getAndCSRule() {
		return getAndCSAccess().getRule();
	}

	//equalityCS returns ExpCS:
	//	relationalCS ({InfixExpCS.source=current} op=("=" | "<>") argument=(relationalCS | LetExpCS))*;
	public EqualityCSElements getEqualityCSAccess() {
		return (pEqualityCS != null) ? pEqualityCS : (pEqualityCS = new EqualityCSElements());
	}
	
	public ParserRule getEqualityCSRule() {
		return getEqualityCSAccess().getRule();
	}

	//relationalCS returns ExpCS:
	//	additiveCS ({InfixExpCS.source=current} op=(">" | "<" | ">=" | "<=") argument=(additiveCS | LetExpCS))*;
	public RelationalCSElements getRelationalCSAccess() {
		return (pRelationalCS != null) ? pRelationalCS : (pRelationalCS = new RelationalCSElements());
	}
	
	public ParserRule getRelationalCSRule() {
		return getRelationalCSAccess().getRule();
	}

	//additiveCS returns ExpCS:
	//	multiplicativeCS ({InfixExpCS.source=current} op=("+" | "-") argument=(multiplicativeCS | LetExpCS))*;
	public AdditiveCSElements getAdditiveCSAccess() {
		return (pAdditiveCS != null) ? pAdditiveCS : (pAdditiveCS = new AdditiveCSElements());
	}
	
	public ParserRule getAdditiveCSRule() {
		return getAdditiveCSAccess().getRule();
	}

	//multiplicativeCS returns ExpCS:
	//	unaryCS ({InfixExpCS.source=current} op=("*" | "/") argument=(unaryCS | LetExpCS))*;
	public MultiplicativeCSElements getMultiplicativeCSAccess() {
		return (pMultiplicativeCS != null) ? pMultiplicativeCS : (pMultiplicativeCS = new MultiplicativeCSElements());
	}
	
	public ParserRule getMultiplicativeCSRule() {
		return getMultiplicativeCSAccess().getRule();
	}

	//unaryCS returns ExpCS:
	//	NavigationExpCS | {PrefixExpCS} op=("-" | "not") source=unaryCS;
	public UnaryCSElements getUnaryCSAccess() {
		return (pUnaryCS != null) ? pUnaryCS : (pUnaryCS = new UnaryCSElements());
	}
	
	public ParserRule getUnaryCSRule() {
		return getUnaryCSAccess().getRule();
	}

	//NavigationExpCS returns ExpCS:
	//	SubNavigationExpCS ({InfixExpCS.source=current} op=("." | "->") argument=NavigatingExpCS)? //	|	({InfixExpCS.source=current} op='^' argument=NavigatingExpCS)
	//
	//	//	|	({InfixExpCS.source=current} op='^^' argument=NavigatingExpCS)
	//
	//;
	public NavigationExpCSElements getNavigationExpCSAccess() {
		return (pNavigationExpCS != null) ? pNavigationExpCS : (pNavigationExpCS = new NavigationExpCSElements());
	}
	
	public ParserRule getNavigationExpCSRule() {
		return getNavigationExpCSAccess().getRule();
	}

	//// Follows ., ->, ^
	//
	//NavigatingExpCS returns ExpCS:
	//	SubNavigatingExpCS ({InfixExpCS.source=current} op=("." | "->") argument=NavigatingExpCS)? //	|	({InfixExpCS.source=current} op='^' argument=NavigatingExpCS)
	//
	//	//	|	({InfixExpCS.source=current} op='^^' argument=NavigatingExpCS)
	//
	//;
	public NavigatingExpCSElements getNavigatingExpCSAccess() {
		return (pNavigatingExpCS != null) ? pNavigatingExpCS : (pNavigatingExpCS = new NavigatingExpCSElements());
	}
	
	public ParserRule getNavigatingExpCSRule() {
		return getNavigatingExpCSAccess().getRule();
	}

	//// May be be followed by ., ->, ^
	//
	//SubNavigationExpCS returns ExpCS:
	//	RoundBracketExpCS | SquareBracketExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS |
	//	CollectionLiteralExpCS | PreExpCS | TypeExpCS | IfExpCS | "(" {NestedExpCS} source=ExpCS ")";
	public SubNavigationExpCSElements getSubNavigationExpCSAccess() {
		return (pSubNavigationExpCS != null) ? pSubNavigationExpCS : (pSubNavigationExpCS = new SubNavigationExpCSElements());
	}
	
	public ParserRule getSubNavigationExpCSRule() {
		return getSubNavigationExpCSAccess().getRule();
	}

	//// Follows ., ->, ^, May be be followed by ., ->, ^
	//
	//SubNavigatingExpCS returns ExpCS:
	//	RoundBracketExpCS | SquareBracketExpCS | PreExpCS | NameExpCS;
	public SubNavigatingExpCSElements getSubNavigatingExpCSAccess() {
		return (pSubNavigatingExpCS != null) ? pSubNavigatingExpCS : (pSubNavigatingExpCS = new SubNavigatingExpCSElements());
	}
	
	public ParserRule getSubNavigatingExpCSRule() {
		return getSubNavigatingExpCSAccess().getRule();
	}

	//iteratorVariableCS returns VariableCS:
	//	name=SimpleName (":" type=TypeExpCS)?;
	public IteratorVariableCSElements getIteratorVariableCSAccess() {
		return (pIteratorVariableCS != null) ? pIteratorVariableCS : (pIteratorVariableCS = new IteratorVariableCSElements());
	}
	
	public ParserRule getIteratorVariableCSRule() {
		return getIteratorVariableCSAccess().getRule();
	}

	//iteratorAccumulatorCS returns VariableCS:
	//	name=SimpleName ":" type=TypeExpCS "=" initExpression=ExpCS;
	public IteratorAccumulatorCSElements getIteratorAccumulatorCSAccess() {
		return (pIteratorAccumulatorCS != null) ? pIteratorAccumulatorCS : (pIteratorAccumulatorCS = new IteratorAccumulatorCSElements());
	}
	
	public ParserRule getIteratorAccumulatorCSRule() {
		return getIteratorAccumulatorCSAccess().getRule();
	}

	//RoundBracketExpCS:
	//	name=NameExpCS ("@" pre?="pre")? "(" (variable1=iteratorVariableCS ("," variable2=iteratorVariableCS | ";"
	//	variable2=iteratorAccumulatorCS)? "|")? (arguments+=ExpCS ("," arguments+=ExpCS)*)? ")";
	public RoundBracketExpCSElements getRoundBracketExpCSAccess() {
		return (pRoundBracketExpCS != null) ? pRoundBracketExpCS : (pRoundBracketExpCS = new RoundBracketExpCSElements());
	}
	
	public ParserRule getRoundBracketExpCSRule() {
		return getRoundBracketExpCSAccess().getRule();
	}

	//SquareBracketExpCS:
	//	name=NameExpCS "[" arguments+=ExpCS ("," arguments+=ExpCS)* "]" ("@" pre?="pre")?;
	public SquareBracketExpCSElements getSquareBracketExpCSAccess() {
		return (pSquareBracketExpCS != null) ? pSquareBracketExpCS : (pSquareBracketExpCS = new SquareBracketExpCSElements());
	}
	
	public ParserRule getSquareBracketExpCSRule() {
		return getSquareBracketExpCSAccess().getRule();
	}

	//PreExpCS:
	//	name=NameExpCS "@" "pre";
	public PreExpCSElements getPreExpCSAccess() {
		return (pPreExpCS != null) ? pPreExpCS : (pPreExpCS = new PreExpCSElements());
	}
	
	public ParserRule getPreExpCSRule() {
		return getPreExpCSAccess().getRule();
	}

	//SelfExpCS:
	//	{SelfExpCS} "self";
	public SelfExpCSElements getSelfExpCSAccess() {
		return (pSelfExpCS != null) ? pSelfExpCS : (pSelfExpCS = new SelfExpCSElements());
	}
	
	public ParserRule getSelfExpCSRule() {
		return getSelfExpCSAccess().getRule();
	}

	//NameExpCS:
	//	PathNameExpCS | SimpleNameExpCS;
	public NameExpCSElements getNameExpCSAccess() {
		return (pNameExpCS != null) ? pNameExpCS : (pNameExpCS = new NameExpCSElements());
	}
	
	public ParserRule getNameExpCSRule() {
		return getNameExpCSAccess().getRule();
	}

	//PathNameExpCS:
	//	namespace=[base::NamespaceCS|Identifier] "::" element=NameExpCS;
	public PathNameExpCSElements getPathNameExpCSAccess() {
		return (pPathNameExpCS != null) ? pPathNameExpCS : (pPathNameExpCS = new PathNameExpCSElements());
	}
	
	public ParserRule getPathNameExpCSRule() {
		return getPathNameExpCSAccess().getRule();
	}

	//SimpleNameExpCS:
	//	element=[base::NamedElementCS|Identifier];
	public SimpleNameExpCSElements getSimpleNameExpCSAccess() {
		return (pSimpleNameExpCS != null) ? pSimpleNameExpCS : (pSimpleNameExpCS = new SimpleNameExpCSElements());
	}
	
	public ParserRule getSimpleNameExpCSRule() {
		return getSimpleNameExpCSAccess().getRule();
	}

	//IfExpCS:
	//	"if" condition=ExpCS "then" thenExpression=ExpCS "else" elseExpression=ExpCS "endif";
	public IfExpCSElements getIfExpCSAccess() {
		return (pIfExpCS != null) ? pIfExpCS : (pIfExpCS = new IfExpCSElements());
	}
	
	public ParserRule getIfExpCSRule() {
		return getIfExpCSAccess().getRule();
	}

	//LetExpCS:
	//	"let" variable+=LetVariableCS ("," variable+=LetVariableCS)* "in" in=ExpCS;
	public LetExpCSElements getLetExpCSAccess() {
		return (pLetExpCS != null) ? pLetExpCS : (pLetExpCS = new LetExpCSElements());
	}
	
	public ParserRule getLetExpCSRule() {
		return getLetExpCSAccess().getRule();
	}

	//LetVariableCS returns VariableCS:
	//	name=SimpleName ":" type=TypeExpCS "=" initExpression=ExpCS;
	public LetVariableCSElements getLetVariableCSAccess() {
		return (pLetVariableCS != null) ? pLetVariableCS : (pLetVariableCS = new LetVariableCSElements());
	}
	
	public ParserRule getLetVariableCSRule() {
		return getLetVariableCSAccess().getRule();
	}
}
