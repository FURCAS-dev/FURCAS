/*
 * Automatically generated by Perl script from MOF model constraints text file.
 */
package com.sap.tc.moin.repository.test.ocl;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import com.sap.tc.moin.repository.mmi.model.Classifier;
import com.sap.tc.moin.repository.mmi.model.Feature;
import com.sap.tc.moin.repository.mmi.model.Operation;
import com.sap.tc.moin.repository.mmi.model.__impl.ModelPackageInternal;
import com.sap.tc.moin.repository.mmi.reflect.RefPackage;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.omg.ocl.__impl.OclPackageInternal;

import com.sap.tc.moin.ocl.utils.OclStatement;
import com.sap.tc.moin.repository.test.ocl.base.BaseOclTest;

/**
 * Do not change this manually, as it will be generated when MOF is changed
 */
public class TestMOFConstraints extends BaseOclTest {

    protected RefPackage pkgs[] = { null, null, null };

    Map<Classifier, Set<Feature>> helperOperations = new HashMap<Classifier, Set<Feature>>( );

    /**
     *
     */

    @Override
    @Before
    public void beforeTestMethod( ) throws Exception {

        super.beforeTestMethod( );
        this.pkgs[0] = this.modelPackage;
        this.pkgs[1] = this.mofPkg.getOcl( );
        this.pkgs[2] = ( (OclPackageInternal) this.mofPkg.getOcl( ) ).getAttaching( coreConnection );
    }

    @Override
    @After
    public void afterTestMethod( ) throws Exception {

        this.pkgs[0] = null;
        this.pkgs[1] = null;
        this.pkgs[2] = null;
        super.afterTestMethod( );
    }

    /**
     * @throws Exception
     */
    @Test
    public void testHelperOps( ) throws Exception {

        this.defineHelperOperations( );
    }

    /**
     */
    @Test
    public void testC_01( ) {

        String inv = "context ModelElement inv: not self.oclIsTypeOf(Package) implies \n" + "self.container -> size() = 1";
        String name = "[C_01](ModelElement): MustBeContainedUnlessPackage";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_05( ) {

        String inv = "context Namespace inv: self.contents->forAll(e1, e2 | e1.name = e2.name implies \n" + "e1 = e2)";
        String name = "[C_05](Namespace): ContentNamesMustNotCollide";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_06( ) {

        String inv = "context GeneralizableElement inv: self.allSupertypes() -> forAll(s | s <> self)";
        String name = "[C_06](GeneralizableElement): SupertypeMustNotBeSelf";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_08( ) {

        String inv = "context GeneralizableElement inv: let superContents = self.allSupertypes() -> \n" + "collect(s | s.contents) in \n" + "self.contents -> \n" + "forAll(m1 | \n" + "superContents -> \n" + "forAll(m2 | \n" + "m1.name = m2.name implies m1 = m2))";
        String name = "[C_08](GeneralizableElement): ContentsMustNotCollideWithSupertypes";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_09( ) {

        String inv = "context GeneralizableElement inv: let superNamespaces = \n" + "self.supertypes -> collect(s | s.extendedNamespace()) in \n" + "superNamespaces -> asSet() -> isUnique(s | s.name)";
        String name = "[C_09](GeneralizableElement): DiamondRuleMustBeObeyed";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_10( ) {

        String inv = "context GeneralizableElement inv: self.isRoot implies self.supertypes -> isEmpty()";
        String name = "[C_10](GeneralizableElement): NoSupertypesAllowedForRoot";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_12( ) {

        String inv = "context GeneralizableElement inv: self.supertypes -> forAll(s | not s.isLeaf)";
        String name = "[C_12](GeneralizableElement): NoSubtypesAllowedForLeaf";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_13( ) {

        String inv = "context TypedElement inv: not self.type.oclIsKindOf(Association)";
        String name = "[C_13](TypedElement): AssociationsCannotBeTypes";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_15( ) {

        String inv = "context Class inv: self.contents->forAll(e | \n" + "e.oclIsTypeOf(Class) or \n" + "e.oclIsKindOf(DataType) or \n" + "e.oclIsTypeOf(Attribute) or \n" + "e.oclIsTypeOf(Reference) or \n" + "e.oclIsTypeOf(Operation) or \n" + "e.oclIsTypeOf(Exception) or \n"
                     + "e.oclIsTypeOf(Constant) or \n" + "e.oclIsKindOf(Constraint) or \n" + "e.oclIsTypeOf(Tag))";
        String name = "[C_15](Class): ClassContainmentRules";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_16( ) {

        String inv = "context Class inv: self.isAbstract implies not self.isSingleton";
        String name = "[C_16](Class): AbstractClassesCannotBeSingleton";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_17( ) {

        String inv = "context DataType inv: if \n" + "self.oclIsTypeOf(StructureType) \n" + "then \n" + "self.contents->forAll(e | \n" + "e.oclIsTypeOf(AliasType) or \n" + "e.oclIsKindOf(Constraint) or \n" + "e.oclIsTypeOf(Tag) or \n" + "e.oclIsTypeOf(StructureField)) \n" + "else \n" + "if \n"
                     + "self.oclIsTypeOf(TupleType) \n" + "then \n" + "self.contents->forAll(e | \n" + "e.oclIsTypeOf(AliasType) or \n" + "e.oclIsKindOf(Constraint) or \n" + "e.oclIsTypeOf(Tag) or \n" + "e.oclIsTypeOf(Attribute)) \n" + "else \n" + "self.contents->forAll(e | \n"
                     + "e.oclIsTypeOf(AliasType) or \n" + "e.oclIsKindOf(Constraint) or \n" + "e.oclIsTypeOf(Tag)) \n" + "endif \n" + "endif";
        String name = "[C_17](DataType): DataTypeContainmentRules";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_19( ) {

        String inv = "context DataType inv: self.supertypes -> isEmpty()";
        String name = "[C_19](DataType): DataTypesHaveNoSupertypes";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_20( ) {

        String inv = "context DataType inv: not self.isAbstract";
        String name = "[C_20](DataType): DataTypesCannotBeAbstract";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_21( ) {

        String inv = "context Reference inv: self.multiplicity.lower = self.referencedEnd.multiplicity.lower \n" + "and \n" + "self.multiplicity.upper = self.referencedEnd.multiplicity.upper \n" + "and \n" + "self.multiplicity.isOrdered = self.referencedEnd.multiplicity.isOrdered \n" + "and \n"
                     + "self.multiplicity.%isUnique = self.referencedEnd.multiplicity.%isUnique";
        String name = "[C_21](Reference): ReferenceMultiplicityMustMatchEnd";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_22( ) {

        String inv = "context Reference inv: self.scope = ScopeKind::instance_level";
        String name = "[C_22](Reference): ReferenceMustBeInstanceScoped";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_23( ) {

        String inv = "context Reference inv: self.isChangeable = self.referencedEnd.isChangeable";
        String name = "[C_23](Reference): ChangeableReferenceMustHaveChangeableEnd";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_24( ) {

        String inv = "context Reference inv: self.type = self.referencedEnd.type";
        String name = "[C_24](Reference): ReferenceTypeMustMatchEndType";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_25( ) {

        String inv = "context Reference inv: self.referencedEnd.isNavigable";
        String name = "[C_25](Reference): ReferencedEndMustBeNavigable";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_26( ) {

        String inv = "context Reference inv: if (self.container.oclIsKindOf(GeneralizableElement)) \n" + "then \n" + "let otherType = self.referencedEnd.otherEnd().type in \n" + "let superTypes = \n" + "self.container.oclAsType(GeneralizableElement).allSupertypes() in \n"
                     + "(self.container = otherType) or superTypes->includes(otherType) \n" + "else \n" + "false \n" + "endif";
        String name = "[C_26](Reference): ContainerMustMatchExposedType";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_28( ) {

        String inv = "context Operation inv: self.contents->forAll(e | \n" + "e.oclIsTypeOf(Parameter) or \n" + "e.oclIsKindOf(Constraint) or \n" + "e.oclIsTypeOf(Tag))";
        String name = "[C_28](Operation): OperationContainmentRules";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_29( ) {

        String inv = "context Operation inv: self.contents -> \n" + "select(c | c.oclIsTypeOf(Parameter)) -> \n" + "select(p : ModelElement | p.oclAsType(Parameter).direction = \n" + "DirectionKind::return_dir) -> size() < 2";
        String name = "[C_29](Operation): OperationsHaveAtMostOneReturn";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_31( ) {

        String inv = "context Exception inv: self.contents->forAll(e | \n" + "e.oclIsTypeOf(Parameter) or \n" + "e.oclIsTypeOf(Tag))";
        String name = "[C_31](Exception): ExceptionContainmentRules";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_32( ) {

        String inv = "context Exception inv: self.contents -> \n" + "select(c | c.oclIsTypeOf(Parameter)) -> \n" + "forAll(p : ModelElement | p.oclAsType(Parameter).direction = \n" + "DirectionKind::out_dir)";
        String name = "[C_32](Exception): ExceptionsHaveOnlyOutParameters";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_33( ) {

        String inv = "context Association inv: self.contents->forAll(e | \n" + "e.oclIsTypeOf(AssociationEnd) or \n" + "e.oclIsKindOf(Constraint) or \n" + "e.oclIsTypeOf(Tag))";
        String name = "[C_33](Association): AssociationContainmentRules";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_34( ) {

        String inv = "context Association inv: self.supertypes -> isEmpty()";
        String name = "[C_34](Association): AssociationsHaveNoSupertypes";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_35( ) {

        String inv = "context Association inv: self.isRoot and self.isLeaf";
        String name = "[C_35](Association): AssociationMustBeRootAndLeaf";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_36( ) {

        String inv = "context Association inv: not self.isAbstract";
        String name = "[C_36](Association): AssociationsCannotBeAbstract";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_37( ) {

        String inv = "context Association inv: self.visibility = VisibilityKind::public_vis";
        String name = "[C_37](Association): AssociationsMustBePublic";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_38( ) {

        String inv = "context Association inv: self.contents -> \n" + "select(c | c.oclIsTypeOf(AssociationEnd)) -> size() = 2";
        String name = "[C_38](Association): AssociationsMustBeBinary";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_39( ) {

        String inv = "context AssociationEnd inv: self.type.oclIsTypeOf(Class)";
        String name = "[C_39](AssociationEnd): EndTypeMustBeClass";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_40( ) {

        String inv = "context AssociationEnd inv: (self.multiplicity.upper > 1 or \n" + "self.multiplicity.upper = Model::Unbounded) implies \n" + "self.multiplicity.%isUnique";
        String name = "[C_40](AssociationEnd): EndsMustBeUnique";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_41( ) {

        String inv = "context AssociationEnd inv: self.multiplicity.isOrdered implies \n" + "not self.otherEnd().multiplicity.isOrdered";
        String name = "[C_41](AssociationEnd): CannotHaveTwoOrderedEnds";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_42( ) {

        String inv = "context AssociationEnd inv: self.aggregation <> AggregationKind::none implies \n" + "self.otherEnd().aggregation = AggregationKind::none";
        String name = "[C_42](AssociationEnd): CannotHaveTwoAggregateEnds";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_43( ) {

        String inv = "context Package inv: self.contents->forAll(e | \n" + "e.oclIsTypeOf(Package) or \n" + "e.oclIsTypeOf(Class) or \n" + "e.oclIsKindOf(DataType) or \n" + "e.oclIsTypeOf(Association) or \n" + "e.oclIsTypeOf(Exception) or \n" + "e.oclIsTypeOf(Constant) or \n"
                     + "e.oclIsKindOf(Constraint) or \n" + "e.oclIsTypeOf(Import) or \n" + "e.oclIsKindOf(OCL::Expressions::OclExpression) or \n" + "e.oclIsKindOf(OCL::Expressions::VariableDeclaration) or \n" + "e.oclIsTypeOf(Tag))";
        String name = "[C_43](Package): PackageContainmentRules";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_44( ) {

        String inv = "context Package inv: not self.isAbstract";
        String name = "[C_44](Package): PackagesCannotBeAbstract";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_46( ) {

        String inv = "context Import inv: self.imported.oclIsTypeOf(Class) or \n" + "self.imported.oclIsTypeOf(Package)";
        String name = "[C_46](Import): CanOnlyImportPackagesAndClasses";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_47( ) {

        String inv = "context Import inv: self.container <> self.imported";
        String name = "[C_47](Import): CannotImportSelf";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_48( ) {

        String inv = "context Import inv: not self.container.contents -> includes(self.imported)";
        String name = "[C_48](Import): CannotImportNestedComponents";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_49( ) {

        String inv = "context Import inv: self.container -> notEmpty() implies \n" + "self.container.container -> isEmpty()";
        String name = "[C_49](Import): NestedPackagesCannotImport";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_50( ) {

        String inv = "context Constraint inv: self.constrainedElements -> \n" + "forAll(c | \n" + "not ( \n" + "c.oclIsKindOf(Constraint) or \n" + "c.oclIsTypeOf(Tag) or \n" + "c.oclIsTypeOf(Import) or \n" + "c.oclIsTypeOf(Constant)))";
        String name = "[C_50](Constraint): CannotConstrainThisElement";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_51( ) {

        String inv = "context Constraint inv: self.constrainedElements -> \n" + "forAll(c | self.container = c or \n" + "self.container.extendedNamespace() -> \n" + "includes(c))";
        String name = "[C_51](Constraint): ConstraintsLimitedToContainer";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_53( ) {

        String inv = "context Constant inv: self.type.oclIsTypeOf(PrimitiveType)";
        String name = "[C_53](Constant): ConstantsTypeMustBePrimitive";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_54( ) {

        String inv = "context MultiplicityType inv: self.lower >= 0 and self.lower <> Unbounded";
        String name = "[C_54](MultiplicityType): LowerCannotBeNegativeOrUnbounded";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_55( ) {

        String inv = "context MultiplicityType inv: self.lower <= self.upper or self.upper = Unbounded";
        String name = "[C_55](MultiplicityType): LowerCannotExceedUpper";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_56( ) {

        String inv = "context MultiplicityType inv: self.upper >= 1 or self.upper = Unbounded";
        String name = "[C_56](MultiplicityType): UpperMustBePositive";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_57( ) {

        String inv = "context MultiplicityType inv: self.upper = 1 implies \n" + "(not self.isOrdered and not self.%isUnique)";
        String name = "[C_57](MultiplicityType): MustBeUnorderedNonunique";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testC_59( ) {

        String inv = "context StructureType inv: self.contents -> exists(c | c.oclIsTypeOf(StructureField))";
        String name = "[C_59](StructureType): MustHaveFields";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_01( ) {

        String inv = "context StructureField inv: self.type.oclIsKindOf(PrimitiveType) or \n" + "self.type.oclIsKindOf(EnumerationType) or \n" + "self.type.oclIsKindOf(StructureType) or \n" + "self.type.oclIsKindOf(Constraint)";
        String name = "[MMC_01](StructureField): StructureFieldsCannotBeObjectValued";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_02( ) {

        String inv = "context Attribute inv: self.scope = ScopeKind::instance_level";
        String name = "[MMC_02](Attribute): AttributesMustNotBeStatic";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_03( ) {

        String inv = "context Association inv: if self.isDerived \n" + "-- this check is only for derived associations \n" + "then \n" + "-- get the ends \n" + "let ends: Sequence(ModelElement) = \n" + "self.contents-> \n" + "select(t | t.oclIsKindOf(AssociationEnd))->asSequence() \n" + "in \n"
                     + "-- compare the changeability \n" + "ends->at(1).oclAsType(AssociationEnd).isChangeable \n" + "= ends->at(2).oclAsType(AssociationEnd).isChangeable \n" + "else \n" + "-- non-derived associations are not checked \n" + "true \n" + "endif";
        String name = "[MMC_03](Association): DerivedAssocEndsMustMatchChangeability";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_05( ) {

        String inv = "context AssociationEnd inv: self.aggregation = AggregationKind::composite implies self.multiplicity.upper = 1";
        String name = "[MMC_05](AssociationEnd): CompositeAssociationEndsUpperBoundIs1";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_06( ) {

        String inv = "context OclConstraint inv: self.language = 'OCL' \n" + "implies self.oclExpression.type = Boolean";
        String name = "[MMC_06](OclConstraint): ExpressionMustBeBoolean";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_07( ) {

        String inv = "context AssociationEnd inv: if self.multiplicity.isOrdered then \n" + "-- an AssociationEnd may not be ordered if the other end does not have storage \n" + "-- he other end may become stored because \n"
                     + "-- 1) explicitly: there is a \"Storage\" tag on the other end with value \"true\" \n" + "-- 2) the other end's type has a reference that has this end as referencedEnd AND \n" + "--     the \"Storage\" tag (on the other end) does not exist or it has value \"if_reference\" \n"
                     + "-- First we get the other end's type, loop over its references and see if one of them expose this \n" + "let exposedEnds:Set(AssociationEnd) = \n" + "self.otherEnd().type.contents-> \n" + "select(t | t.oclIsKindOf(Reference))-> \n" + "iterate(theElement: ModelElement; \n"
                     + "theValues: Set(AssociationEnd) = Set{} \n" + "| \n" + "theValues->union \n" + "(theElement.oclAsType(Reference).referencedEnd.asSet()) \n" + ") \n" + "in \n" + "let exposingReferenceFound = exposedEnds->includes(self) in \n" + "let tagFound: Boolean = false in \n"
                     + "-- Now we check if the find the \"Storage\" tag and get the values \n" + "let values:Set(String) = \n" + "self.otherEnd().tag->iterate(theTag: Tag; \n" + "theValues:Set(String) = Set{} \n" + "| \n" + "if theTag.tagId = 'org.omg.sap2mof.store' \n" + "then \n"
                     + "let tagFound = true in \n" + "theValues->union(theTag.values->asSet()) \n" + "else \n" + "theValues->union(theValues) \n" + "endif \n" + ") \n" + "in \n" + "let trueValueFound = values->exists(val | val='yes') in \n"
                     + "let ifRefValueFound = values->exists(val | val='if_reference') in \n" + "trueValueFound \n" + "or \n" + "( exposingReferenceFound and not tagFound ) \n" + "or \n" + "( exposingReferenceFound and ifRefValueFound ) \n" + "else \n" + "-- not ordered, skip all other checks \n"
                     + "true \n" + "endif";
        String name = "[MMC_07](AssociationEnd): OrderedEndsRequireStorageOnOtherEnd";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_09( ) {

        String inv = "context StructuralFeature inv: self.name.size() > 2 implies ( \n" + "self.name.subString(1,2)<>('__') and \n" + "self.name.subString(1,3)<>('___') )";
        String name = "[MMC_09](StructuralFeature): StructuralFeatureName";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_10( ) {

        String inv = "context Class inv: not self.isSingleton";
        String name = "[MMC_10](Class): NoSingletonsAllowed";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_11( ) {

        String inv = "context Association inv: not self.isDerived";
        String name = "[MMC_11](Association): AssociationsMustNotBeDerived";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_12( ) {

        String inv = "context Attribute inv: not self.isDerived";
        String name = "[MMC_12](Attribute): AttributesMustNotBeDerived";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_13( ) {

        String inv = "context Package inv: self.isRoot and self.isLeaf";
        String name = "[MMC_13](Package): PackageMustBeRootAndLeaf";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_14( ) {

        String inv = "context DataType inv: self.isRoot and self.isLeaf";
        String name = "[MMC_14](DataType): DataTypeMustBeRootAndLeaf";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_15( ) {

        String inv = "context OclConstraint inv: self.language = 'OCLInit' \n" + "implies self.oclExpression.oclIsKindOf(PrimitiveLiteralExp)";
        String name = "[MMC_15](OclConstraint): InitExpressionMustBePrimitiveLiteral";
        parseOCLConstraint( name, inv );
    }

    /**
     */
    @Test
    public void testMMC_16( ) {

        String inv = "context OclConstraint inv: self.language = 'OCLInit' \n" + "implies self.initializedAttribute.multiplicity.upper = 1";
        String name = "[MMC_16](OclConstraint): InitializedAttributeUpperBoundsMustBeOne";
        parseOCLConstraint( name, inv );
    }


    private Map<Classifier, Set<Feature>> defineHelperOperations( ) {

        if ( this.helperOperations.isEmpty( ) ) {
            String body;
            OclStatement stmt;

            body = "context Namespace " + "def: extendedNamespace() : Set(ModelElement) = " + "self.contents->asSet()";
            stmt = parseHelperOperation( body );
            Classifier classifier0 = (Classifier) this.modelPackage.getNamespace( ).refMetaObject( );
            Set<Feature> clfeatures0 = this.helperOperations.get( classifier0 );
            if ( clfeatures0 == null ) {
                clfeatures0 = new HashSet<Feature>( );
                this.helperOperations.put( classifier0, clfeatures0 );
            }
            clfeatures0.add( (Operation) stmt.getContext( ) );

            body = "context GeneralizableElement " + "def: extendedNamespace() : Set(ModelElement) = " + "self.contents->asSet()->union(self.allSupertypes() -> collect(s | s.contents)->asSet())";
            stmt = parseHelperOperation( body );
            Classifier classifier1 = (Classifier) ( (ModelPackageInternal) this.modelPackage ).getGeneralizableElement( coreConnection ).refMetaObject( );
            Set<Feature> clfeatures1 = this.helperOperations.get( classifier1 );
            if ( clfeatures1 == null ) {
                clfeatures1 = new HashSet<Feature>( );
                this.helperOperations.put( classifier1, clfeatures1 );
            }
            clfeatures1.add( (Operation) stmt.getContext( ) );

            body = "context Package " + "def: extendedNamespace() : Set(ModelElement) = " + "let ens = self.contents->asSet()->union(self.allSupertypes() -> collect(s | s.contents)->asSet()) in "
                   + "let imports = ens -> select(e | e.oclIsKindOf(Import)) ->collect(i | i.oclAsType(Import).imported)->asSet() in " + "ens -> union(imports)";
            stmt = parseHelperOperation( body );
            Classifier classifier2 = (Classifier) ( (ModelPackageInternal) this.modelPackage ).getMofPackage( coreConnection ).refMetaObject( );
            Set<Feature> clfeatures2 = this.helperOperations.get( classifier2 );
            if ( clfeatures2 == null ) {
                clfeatures2 = new HashSet<Feature>( );
                this.helperOperations.put( classifier2, clfeatures2 );
            }
            clfeatures2.add( (Operation) stmt.getContext( ) );
        }
        return this.helperOperations;
    }

    private void parseOCLConstraint( String name, String inv ) {

        parse( inv, null, this.pkgs, this.defineHelperOperations( ) );
    }

    private OclStatement parseHelperOperation( String def ) {

        Collection<OclStatement> result = parse( def, null, this.pkgs );
        if ( result.size( ) != 1 ) {
            fail( "Helper operation parsed to <> 1 Statement: " + def );
        }
        OclStatement stmt = result.iterator( ).next( );
        if ( stmt.getKind( ) != OclStatement.DEFINITION ) {
            fail( "Helper operation did not parse to a Definition: " + def );
        }
        return stmt;
    }
}
