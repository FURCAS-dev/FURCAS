#!/usr/bin/perl
use strict;
#use warnings;

#
# This Perl script generates a Java class that can be used as a JUnit test
# within MOIN to parse the MOF model constraints.
# It does so by parsing two files (which need to be passed as command line
# arguments: the first contains the MOF model constraints and the second
# contains the helper functions defined for those constraints.
#
# Since we had to edit the constraints quite heavily we' ve chosen this approach
# rather than editing the Java file by hand.
# Once we feel assured that the MOF model constraints will be parsed, we could
# directly load a combined text file and let the parser parse that text file.
#
# But for now, we've stick with this script.
#
# To (re-) generate the Java class, open a command shell window and type
# perl mof_constraints.pl mof_constraints.txt mof_helper.txt > TestMOFConstraints.java
#
# (Update) D046918
# Adapted Script to JUnit4
#

BEGIN { $0 =~ s|.*/||; }

@ARGV = ('-') unless @ARGV;
$ARGV = shift;

#<>;                             # Skip first "/****"
$/ = "/****";

my @mof = qw(
  Class
  Exception
  Package
);
my %mof = map { $_ => 1 } @mof;

#
# Header stuff 
#
print << "EOB";
/*
 * Automatically generated by Perl script from MOF model constraints text file.
 */
package com.sap.tc.moin.repository.test.ocl;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import com.sap.tc.moin.repository.mmi.model.Classifier;
import com.sap.tc.moin.repository.mmi.model.Feature;
import com.sap.tc.moin.repository.mmi.model.Operation;
import com.sap.tc.moin.repository.mmi.reflect.RefPackage;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;

import com.sap.tc.moin.ocl.utils.OclStatement;
import com.sap.tc.moin.repository.test.ocl.base.BaseOclTest;
/**
  * Do not change this manually, as it will be generated when MOF is changed
  */
public class TestMOFConstraints extends BaseOclTest {

    protected RefPackage pkgs[] = { null, null, null };

    Map<Classifier, Set<Feature>> helperOperations = new HashMap<Classifier, Set<Feature>>();
	/**
	 *
	 */
    public TestMOFConstraints() {
        super(null);
    }
	/**
	 * \@param name the test method
	 */
    public TestMOFConstraints(String name) {
        super(name);
    }

    \@Override
    \@Before
    public void beforeTestMethod() throws Exception {
        super.beforeTestMethod();
        this.pkgs[0] = this.modelPackage;
        this.pkgs[1] = this.mofPkg.getOcl();
        this.pkgs[2] = this.mofPkg.getOcl().getAttaching();
    }

    \@Override
    \@After
    public void afterTestMethod() throws Exception {
        this.pkgs[0] = null;
        this.pkgs[1] = null;
        this.pkgs[2] = null;
        super.afterTestMethod();
    }
	/**
	 * \@throws Exception
	 */
    \@Test
    public void testHelperOps() throws Exception {
        this.defineHelperOperations();
    }
EOB

#
# Generate the test methods from the text file
#

open(INP, $ARGV) or warn "Can't open $ARGV: $!\n";
# skip first
<INP>;
while (<INP>) {
  s/\r$//mg;
  my ($num, $name, $ctx, $type, $expr) =
    m|^\s*\[(.+?)\]\s+(\w+)\s+.+\*\*\*\*/\s+context (.+?)\s+(\w+):\s+(.+?)\s+(?:/\*\*\*\*)?$|s;
  $num =~ s/\W/_/g;
  # $ctx = "Mof$ctx" if $mof{$ctx};
  $expr =~ s/\s*\n\s*/ \\n" +\n\t "/g;
  next if $type ne "inv";
  print <<"EOB";

	/**
    */
	\@Test
	public void test$num () {
    	String inv = "context $ctx inv: $expr";
    	String name = "[$num]($ctx): $name";
    	parseOCLConstraint (name, inv);
	}
EOB
}

$ARGV = shift;
open(INP, $ARGV) or warn "Can't open $ARGV: $!\n";
print <<"EOB";
	\@Ignore
	private Map<Classifier, Set<Feature>> defineHelperOperations() {
	
		if (this.helperOperations.isEmpty()) {
			String body;
			OclStatement stmt;
EOB

<INP>;
my ($count) = 0;
while (<INP>) {
	s/\r$//mg;
	my ($expr) =
    m|^.+\*\*\*\*/\s+(context .+)(?:\s\s+/\*\*\*\*?)$|s;
	$expr =~ s/\s*\n\s*/ " +\n\t "/g;

	next if $expr eq "";
	
	print <<"EOB";
	
			body = "$expr";
		    stmt = parseHelperOperation(body);
		    Classifier classifier$count = (Classifier) this.modelPackage.getNamespace().refMetaObject();
		    Set<Feature> clfeatures$count = this.helperOperations.get(classifier$count);
		    if (clfeatures$count == null){
		    	clfeatures$count = new HashSet<Feature>();
	    	    this.helperOperations.put(classifier$count, clfeatures$count);
		        }
		    clfeatures$count.add((Operation)stmt.getContext());
EOB
$count++;
}
print << "EOB";
	}
	return this.helperOperations;
}
EOB
#
# stuff we need to append at the end
# 
print <<"EOB";    

	private void parseOCLConstraint(String name, String inv) {
		parse(inv, null, this.pkgs, this.defineHelperOperations());
	}

	private OclStatement parseHelperOperation(String def) {
		Collection<OclStatement> result = parse(def, null, this.pkgs);
        if (result.size() != 1) {
            fail("Helper operation parsed to <> 1 Statement: " + def);
        }
        OclStatement stmt = result.iterator().next();
        if (stmt.getKind() != OclStatement.DEFINITION) {
            fail("Helper operation did not parse to a Definition: " + def);
        }
        return stmt;
	}
}
EOB
