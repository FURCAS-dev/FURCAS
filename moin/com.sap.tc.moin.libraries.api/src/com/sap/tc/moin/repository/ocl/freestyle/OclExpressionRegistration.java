package com.sap.tc.moin.repository.ocl.freestyle;

import java.util.Collection;
import java.util.Set;

import com.sap.tc.moin.repository.events.filter.EventFilter;
import com.sap.tc.moin.repository.events.type.ModelChangeEvent;
import com.sap.tc.moin.repository.mmi.reflect.RefObject;

import com.sap.tc.moin.repository.Connection;
import com.sap.tc.moin.repository.MRI;
import com.sap.tc.moin.repository.ocl.OclRegistryService;
import com.sap.tc.moin.repository.ocl.debugger.OclDebuggerNode;
import com.sap.tc.moin.repository.ocl.notification.OclManagerException;
import com.sap.tc.moin.repository.ocl.registry.OclRegistrationCategory;

/**
 * This is the registration object for an arbitrary OCL Expression.
 * <p>
 * Registration of listeners is done through this interface, while triggering of
 * the invalidation checks is done through the {@link OclFreestyleRegistry}
 * interface.
 * <p>
 * 
 * @noimplement This interface is not intended to be implemented by clients.
 */
public interface OclExpressionRegistration extends OclRegistration {

    /**
     * This evaluates the expression for a given context.
     * 
     * @param context the object for which to evaluate the expression, may be
     * null if the expression does not refer to 'self'
     * @return the result of the evaluation
     * @throws OclManagerException if evaluation fails
     */
    public Object evaluateExpression( RefObject context ) throws OclManagerException;

    /**
     * This evaluates the expression for a given context.
     * 
     * @param context the object for which to evaluate the expression, may be
     * null if the expression does not refer to 'self'
     * @return the result of the evaluation
     * @throws OclManagerException if evaluation fails
     */
    public Object evaluateExpression( MRI context ) throws OclManagerException;


    /**
     * Creates the OclDebugger tree.
     * <p>
     * This tree represents the expression tree generated by the parser enriched
     * with the actual values for each node. This can be helpful to analyze the
     * course of evaluation of this expression for a specific object.
     * 
     * @param context the object for which to evaluate the expression, may be
     * null if the expression does not refer to 'self'
     * @return the debugger tree root node
     * @throws OclManagerException if anything goes wrong during creation of the
     * tree
     */
    public OclDebuggerNode debugExpression( RefObject context ) throws OclManagerException;

    /**
     * Creates the OclDebugger tree.
     * <p>
     * This tree represents the expression tree generated by the parser enriched
     * with the actual values for each node. This can be helpful to analyze the
     * course of evaluation of this expression for a specific object.
     * 
     * @param context the object for which to evaluate the expression, may be
     * null if the expression does not refer to 'self'
     * @return the debugger tree root node
     * @throws OclManagerException if anything goes wrong during creation of the
     * tree
     */
    public OclDebuggerNode debugExpression( MRI context ) throws OclManagerException;

    /**
     * Registers an invalidation listener.
     * <p>
     * Notification will be triggered after a call to
     * {@link OclRegistryService#analyzeModelPartitions(String, java.util.Set)}
     * 
     * @param category the category; must not be a MOIN-specific one (see
     * {@link OclRegistrationCategory})
     * @param listener the listener
     * @return see {@link Set#add(Object)}
     * @throws IllegalArgumentException if a MOIN-specific category is provided
     * in {@code category}
     */
    public boolean registerPartitionBasedInvalidationListener( String category, ExpressionInvalidationListener listener ) throws IllegalArgumentException;

    /**
     * Registers and invalidation listener with an object filter
     * <p>
     * Notification will be triggered after a call to
     * {@link OclRegistryService#analyzeModelPartitions(String, java.util.Set)}
     * 
     * @param category the category; must not be a MOIN-specific one (see
     * {@link OclRegistrationCategory})
     * @param listener the listener
     * @param objectFilter notify only if an object in this filter is affected
     * @return see {@link Set#add(Object)}
     * @throws IllegalArgumentException if a MOIN-specific category is provided
     * in {@code category}
     */
    public boolean registerPartitionBasedInvalidationListener( String category, ExpressionInvalidationListener listener, Collection<MRI> objectFilter ) throws IllegalArgumentException;

    /**
     * Registers an event based invalidation listener
     * 
     * @param listener the listener
     * @param objectFilter notify only if an object in this filter is affected
     * @param immediate if true, events are evaluated immediately, else they are
     * collected and can be evaluated by calling the trigger method
     * {@link OclRegistryService#analyzeCollectedEvents(String)}
     * @return see {@link Set#add(Object)}
     */
    public boolean registerEventBasedInvalidationListener( ExpressionInvalidationListener listener, Collection<MRI> objectFilter, boolean immediate );

    /**
     * Registers an event based invalidation listener
     * 
     * @param listener the listener
     * @param immediate if true, events are evaluated immediately, else they are
     * collected and can be evaluated by calling the trigger method
     * {@link OclRegistryService#analyzeCollectedEvents(String)}
     * @return see {@link Set#add(Object)}
     */
    public boolean registerEventBasedInvalidationListener( ExpressionInvalidationListener listener, boolean immediate );

    /**
     * Unregisters the listener
     * 
     * @param listener the listener to unregister
     * @return see {@link Set#remove(Object)}
     */
    public boolean unregisterInvalidationListener( ExpressionInvalidationListener listener );

    /**
     * Computes the elements that were affected by the {@link ModelChangeEvent} for this
     * expression registration. This uses the Impact Analysis.
     * 
     * @param mce The {@link ModelChangeEvent}
     * @param conn The {@link Connection} that should be used to compute the affected elements.
     * @return A {@link Set} of {@link MRI MRIs} of the elements that were affected by the {@link ModelChangeEvent}.
     */
    Set<MRI> getAffectedModelElements(ModelChangeEvent mce, Connection conn);

    
    /**
     * Returns the EventFilter that was computed by the Impact Analysis for 
     * the current OCL registration.
     * 
     * @return The {@link EventFilter} constructed by the Impact Analysis.
     */
    EventFilter getEventFilter();

}
