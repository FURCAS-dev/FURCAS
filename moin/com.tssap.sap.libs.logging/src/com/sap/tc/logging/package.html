<body>
    Provides the classes for emitting and controlling the output of trace and
    log messages, and the classes for organizing hierarchies of message kinds,
    origins and destinations.
  <p>
    There are two different classes for emitting messages to,
    {@link com.sap.tc.logging.Location} and {@link com.sap.tc.logging.Category},
    both of which are derived from the base class
    {@link com.sap.tc.logging.LogController}. Locations describe messages that
    <em>originate from delimited source code areas</em>, such as components,
    packages, classes and methods. This is typical of <em>traces</em>, and hence
    messages emitted to locations are classical trace messages. Therefore, if
    you are above all interested in writing traces, please take a look at the
    introduction to this {@link com.sap.tc.logging.Location class} first.
    Categories describe messages <em>specific to distinguished problem
    areas</em>, such as databases, networking, security auditing and others.
    This is typical of <em>logs</em>, and hence messages emitted to categories
    are classical log messages.
  </p>
  <p>
    Both kinds of log controllers control writing of messages, in addition to
    message <em>severities</em>, via filters which must implement the interface
    {@link com.sap.tc.logging.Filter}. Log controllers are automatically ordered
    into hierarchies, and severities and filters are among the properties that
    are passed on from parents to children unless overridden.
  </p>
  <p>
    Besides locations being proxies for traces and categories being proxies for
    logs, locations can also be used to describe the origin of log messages and,
    vice versa, categories to describe the nature of trace messages. This is
    used to take advantage of synergistic effects. For example, log messages
    that come from a given source code area can be emitted to both the
    responsible category and the corresponding location at the same time with a
    single method call. The messages in both the resulting log and trace sport
    the same identification which makes it much easier to find those trace
    messages that show the circumstances of particular problems described in log
    messages. It is also possible to set severities of controllers in relation
    to other controllers. This allows the enabling of logs for specific
    locations, for example packages or classes, or, vice versa, using categories
    to classify trace messages and enable writing messages of specific
    categories without affecting the outcome of other trace calls. It also lets
    us get rid of the need for custom severities.
  </p>
  <p>
    Log controllers themselves write messages to instances of various subclasses
    of {@link com.sap.tc.logging.Log}. Whereas these instances stand for
    different destinations, subclasses provide access to different kinds of
    destinations such as files  or sockets. Logs format messages using
    instances of {@link com.sap.tc.logging.Formatter}.
  </p>
  <p>
    A few words on fault tolerance: the usual mechanism for error handling in
    Java is throwing exceptions. However, in case of a component for logging and
    tracing, which among other things deals with locating errors and problems,
    throwing exceptions means creating a vicious circle. This matter is dealt
    with as follows. First of all, in general methods do not throw exceptions
    but instead make them available via other methods of the object at hand,
    called <code>getException()</code> and <code>throwException()</code>, which
    return, or throw, a potential exception from the preceeding normal call.
    This is true in particular of runtime exceptions such as
    <code>java.lang.NullPointerException</code>. However, care has to be taken
    because exceptions are not reset. To make sure that an exception had
    actually been caused by a call, either reset the exception store before the
    call with <code>resetException()</code> or compare the results of
    <code>getException()</code> before and after it. In addition to storing
    exceptions, methods themselves log problems to the dedicated category
    <code>/System/Logging</code>, except for calls emitting messages where this
    would generate too much output. In both cases, however, care has been taken
    for the implementation to act as meaningful as possible even in the face of
    errors. A notable deviation from the above are methods that are meant to be
    called in static field declarations and initializers. In most of these
    cases, exceptions lead to immediate program termination upon loading a
    class. It is therefore improbable for them to pass unnoticed until after
    distributing the software.
  </p>
</body>