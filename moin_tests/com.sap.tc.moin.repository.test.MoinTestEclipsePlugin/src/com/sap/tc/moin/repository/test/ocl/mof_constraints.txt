/****
[C-01] MustBeContainedUnlessPackage
format1: MUSTBECONTAINEDUNLESSPACKAGE
format2: mustbecontainedunlesspackage
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context ModelElement 
inv:
  not self.oclIsTypeOf(Package) implies
  self.container -> size() = 1
/****
[C-05] ContentNamesMustNotCollide
format1: CONTENTNAMESMUSTNOTCOLLIDE
format2: contentnamesmustnotcollide
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Namespace
inv: 
  self.contents->forAll(e1, e2 | e1.name = e2.name implies
  e1 = e2)
/****
[C-06] SupertypeMustNotBeSelf
format1: SUPERTYPEMUSTNOTBESELF
format2: supertypemustnotbeself
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context GeneralizableElement
inv:
  self.allSupertypes() -> forAll(s | s <> self)
/****
[C-08] ContentsMustNotCollideWithSupertypes
format1: CONTENTSMUSTNOTCOLLIDEWITHSUPERTYPES
format2: contentsmustnotcollidewithsupertypes
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context GeneralizableElement
inv:
  let superContents = self.allSupertypes() -> 
  collect(s | s.contents) in 
  self.contents -> 
  forAll(m1 | 
  superContents -> 
  forAll(m2 | 
  m1.name = m2.name implies m1 = m2))
/****
[C-09] DiamondRuleMustBeObeyed
format1: DIAMONDRULEMUSTBEOBEYED
format2: diamondrulemustbeobeyed
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context GeneralizableElement
inv:
let superNamespaces =
self.supertypes -> collect(s | s.extendedNamespace()) in
superNamespaces -> asSet() -> isUnique(s | s.name)
/****
[C-10] NoSupertypesAllowedForRoot
format1: NOSUPERTYPESALLOWEDFORROOT
format2: nosupertypesallowedforroot
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context GeneralizableElement
inv: 
  self.isRoot implies self.supertypes -> isEmpty()
/****
[C-12] NoSubtypesAllowedForLeaf
format1: NOSUBTYPESALLOWEDFORLEAF
format2: nosubtypesallowedforleaf
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context GeneralizableElement
inv: 
  self.supertypes -> forAll(s | not s.isLeaf)
/****
[C-13] AssociationsCannotBeTypes
format1: ASSOCIATIONSCANNOTBETYPES
format2: associationscannotbetypes
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context TypedElement
inv: 
  not self.type.oclIsKindOf(Association)
/****
[C-15] ClassContainmentRules
format1: CLASSCONTAINMENTRULES
format2: classcontainmentrules
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Class 
inv:
  self.contents->forAll(e | 
	 e.oclIsTypeOf(Class) or 
	 e.oclIsKindOf(DataType) or 
	 e.oclIsTypeOf(Attribute) or 
	 e.oclIsTypeOf(Reference) or 
	 e.oclIsTypeOf(Operation) or 
	 e.oclIsTypeOf(Exception) or 
	 e.oclIsTypeOf(Constant) or 
	 e.oclIsKindOf(Constraint) or 
	 e.oclIsTypeOf(Tag))
/****
[C-16] AbstractClassesCannotBeSingleton
format1: ABSTRACTCLASSESCANNOTBESINGLETON
format2: abstractclassescannotbesingleton
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Class 
inv: 
  self.isAbstract implies not self.isSingleton
/****
[C-17] DataTypeContainmentRules
format1: DATATYPECONTAINMENTRULES
format2: datatypecontainmentrules
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context DataType
inv: 
  if
    self.oclIsTypeOf(StructureType) 
  then
    self.contents->forAll(e | 
	 e.oclIsTypeOf(AliasType) or 
	 e.oclIsKindOf(Constraint) or 
	 e.oclIsTypeOf(Tag) or 
	 e.oclIsTypeOf(StructureField)) 
  else 
    if
      self.oclIsTypeOf(TupleType)
    then
      self.contents->forAll(e | 
  	 e.oclIsTypeOf(AliasType) or 
  	 e.oclIsKindOf(Constraint) or 
  	 e.oclIsTypeOf(Tag) or
                 e.oclIsTypeOf(Attribute))
    else
      self.contents->forAll(e | 
  	 e.oclIsTypeOf(AliasType) or 
  	 e.oclIsKindOf(Constraint) or 
  	 e.oclIsTypeOf(Tag)) 
    endif
  endif
/****
[C-19] DataTypesHaveNoSupertypes
format1: DATATYPESHAVENOSUPERTYPES
format2: datatypeshavenosupertypes
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context DataType
inv:
  self.supertypes -> isEmpty()
/****
[C-20] DataTypesCannotBeAbstract
format1: DATATYPESCANNOTBEABSTRACT
format2: datatypescannotbeabstract
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context DataType
inv:
  not self.isAbstract
/****
[C-21] ReferenceMultiplicityMustMatchEnd
format1: REFERENCEMULTIPLICITYMUSTMATCHEND
format2: referencemultiplicitymustmatchend
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Reference
inv:
  self.multiplicity.lower = self.referencedEnd.multiplicity.lower
  and
    self.multiplicity.upper = self.referencedEnd.multiplicity.upper
  and
    self.multiplicity.isOrdered = self.referencedEnd.multiplicity.isOrdered
  and 
    self.multiplicity.%isUnique = self.referencedEnd.multiplicity.%isUnique
/****
[C-22] ReferenceMustBeInstanceScoped
format1: REFERENCEMUSTBEINSTANCESCOPED
format2: referencemustbeinstancescoped
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Reference
inv:
  self.scope = ScopeKind::instance_level
/****
[C-23] ChangeableReferenceMustHaveChangeableEnd
format1: CHANGEABLEREFERENCEMUSTHAVECHANGEABLEEND
format2: changeablereferencemusthavechangeableend
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Reference
inv: 
  self.isChangeable = self.referencedEnd.isChangeable
/****
[C-24] ReferenceTypeMustMatchEndType
format1: REFERENCETYPEMUSTMATCHENDTYPE
format2: referencetypemustmatchendtype
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Reference
inv:
  self.type = self.referencedEnd.type
/****
[C-25] ReferencedEndMustBeNavigable
format1: REFERENCEDENDMUSTBENAVIGABLE
format2: referencedendmustbenavigable
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Reference
inv:
  self.referencedEnd.isNavigable
/****
[C-26] ContainerMustMatchExposedType
format1: CONTAINERMUSTMATCHEXPOSEDTYPE
format2: containermustmatchexposedtype
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Reference
inv:
  if (self.container.oclIsKindOf(GeneralizableElement))
  then
    let otherType = self.referencedEnd.otherEnd().type in 
      let superTypes = 
       self.container.oclAsType(GeneralizableElement).allSupertypes() in
         (self.container = otherType) or superTypes->includes(otherType) 
  else
    false
  endif
/****
[C-28] OperationContainmentRules
format1: OPERATIONCONTAINMENTRULES
format2: operationcontainmentrules
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Operation
inv:
  self.contents->forAll(e | 
	 e.oclIsTypeOf(Parameter) or 
	 e.oclIsKindOf(Constraint) or 
	 e.oclIsTypeOf(Tag))
/****
[C-29] OperationsHaveAtMostOneReturn
format1: OPERATIONSHAVEATMOSTONERETURN
format2: operationshaveatmostonereturn
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Operation
inv:
  self.contents -> 
    select(c | c.oclIsTypeOf(Parameter)) ->
      select(p : ModelElement | p.oclAsType(Parameter).direction =
      DirectionKind::return_dir) -> size() < 2
/****
[C-31] ExceptionContainmentRules
format1: EXCEPTIONCONTAINMENTRULES
format2: exceptioncontainmentrules
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Exception
inv: 
  self.contents->forAll(e | 
	 e.oclIsTypeOf(Parameter) or 
	 e.oclIsTypeOf(Tag))
/****
[C-32] ExceptionsHaveOnlyOutParameters
format1: EXCEPTIONSHAVEONLYOUTPARAMETERS
format2: exceptionshaveonlyoutparameters
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Exception
inv:
  self.contents -> 
    select(c | c.oclIsTypeOf(Parameter)) -> 
      forAll(p : ModelElement | p.oclAsType(Parameter).direction = 
      DirectionKind::out_dir)
/****
[C-33] AssociationContainmentRules
format1: ASSOCIATIONCONTAINMENTRULES
format2: associationcontainmentrules
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Association
inv:
  self.contents->forAll(e | 
	 e.oclIsTypeOf(AssociationEnd) or 
	 e.oclIsKindOf(Constraint) or 
	 e.oclIsTypeOf(Tag))
/****
[C-34] AssociationsHaveNoSupertypes
format1: ASSOCIATIONSHAVENOSUPERTYPES
format2: associationshavenosupertypes
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Association
inv:
  self.supertypes -> isEmpty()
/****
[C-35] AssociationMustBeRootAndLeaf
format1: ASSOCIATIONMUSTBEROOTANDLEAF
format2: associationmustberootandleaf
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Association
inv:
  self.isRoot and self.isLeaf
/****
[C-36] AssociationsCannotBeAbstract
format1: ASSOCIATIONSCANNOTBEABSTRACT
format2: associationscannotbeabstract
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Association
inv:
  not self.isAbstract
/****
[C-37] AssociationsMustBePublic
format1: ASSOCIATIONSMUSTBEPUBLIC
format2: associationsmustbepublic
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Association
inv:
  self.visibility = VisibilityKind::public_vis
/****
[C-38] AssociationsMustBeBinary
format1: ASSOCIATIONSMUSTBEBINARY
format2: associationsmustbebinary
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Association
inv:
  self.contents -> 
    select(c | c.oclIsTypeOf(AssociationEnd)) -> size() = 2
/****
[C-39] EndTypeMustBeClass
format1: ENDTYPEMUSTBECLASS
format2: endtypemustbeclass
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context AssociationEnd
inv:
  self.type.oclIsTypeOf(Class)
/****
[C-40] EndsMustBeUnique
format1: ENDSMUSTBEUNIQUE
format2: endsmustbeunique
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context AssociationEnd
inv:
  (self.multiplicity.upper > 1 or
  self.multiplicity.upper = Model::Unbounded) implies
  self.multiplicity.%isUnique
/****
[C-41] CannotHaveTwoOrderedEnds
format1: CANNOTHAVETWOORDEREDENDS
format2: cannothavetwoorderedends
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context AssociationEnd
inv:
  self.multiplicity.isOrdered implies
  not self.otherEnd().multiplicity.isOrdered
/****
[C-42] CannotHaveTwoAggregateEnds
format1: CANNOTHAVETWOAGGREGATEENDS
format2: cannothavetwoaggregateends
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context AssociationEnd
inv:
  self.aggregation <> AggregationKind::none implies
  self.otherEnd().aggregation = AggregationKind::none
/****
[C-43] PackageContainmentRules
format1: PACKAGECONTAINMENTRULES
format2: packagecontainmentrules
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Package
inv:
  self.contents->forAll(e | 
	 e.oclIsTypeOf(Package) or 
	 e.oclIsTypeOf(Class) or 
	 e.oclIsKindOf(DataType) or 
	 e.oclIsTypeOf(Association) or 
	 e.oclIsTypeOf(Exception) or 
	 e.oclIsTypeOf(Constant) or 
	 e.oclIsKindOf(Constraint) or 
	 e.oclIsTypeOf(Import) or 
	 e.oclIsKindOf(OCL::Expressions::OclExpression) or 
	 e.oclIsKindOf(OCL::Expressions::VariableDeclaration) or 
	 e.oclIsTypeOf(Tag))
/****
[C-44] PackagesCannotBeAbstract
format1: PACKAGESCANNOTBEABSTRACT
format2: packagescannotbeabstract
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Package
inv: 
  not self.isAbstract
/****
[C-46] CanOnlyImportPackagesAndClasses
format1: CANONLYIMPORTPACKAGESANDCLASSES
format2: canonlyimportpackagesandclasses
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Import
inv:
  self.imported.oclIsTypeOf(Class) or
  self.imported.oclIsTypeOf(Package)
/****
[C-47] CannotImportSelf
format1: CANNOTIMPORTSELF
format2: cannotimportself
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Import
inv:
  self.container <> self.imported
/****
[C-48] CannotImportNestedComponents
format1: CANNOTIMPORTNESTEDCOMPONENTS
format2: cannotimportnestedcomponents
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Import
inv:
  not self.container.contents -> includes(self.imported)
/****
[C-49] NestedPackagesCannotImport
format1: NESTEDPACKAGESCANNOTIMPORT
format2: nestedpackagescannotimport
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Import
inv:
         self.container -> notEmpty() implies
         self.container.container -> isEmpty()
/****
[C-50] CannotConstrainThisElement
format1: CANNOTCONSTRAINTHISELEMENT
format2: cannotconstrainthiselement
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Constraint
inv:
  self.constrainedElements ->
	 forAll(c | 
	 not ( 
	 c.oclIsKindOf(Constraint) or 
	 c.oclIsTypeOf(Tag) or 
	 c.oclIsTypeOf(Import) or 
	 c.oclIsTypeOf(Constant)))
/****
[C-51] ConstraintsLimitedToContainer
format1: CONSTRAINTSLIMITEDTOCONTAINER
format2: constraintslimitedtocontainer
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Constraint
inv:
self.constrainedElements ->
forAll(c | self.container = c or 
self.container.extendedNamespace() ->
includes(c))
/****
[C-53] ConstantsTypeMustBePrimitive
format1: CONSTANTSTYPEMUSTBEPRIMITIVE
format2: constantstypemustbeprimitive
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Constant
inv:
  self.type.oclIsTypeOf(PrimitiveType)
/****
[C-54] LowerCannotBeNegativeOrUnbounded
format1: LOWERCANNOTBENEGATIVEORUNBOUNDED
format2: lowercannotbenegativeorunbounded
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context MultiplicityType inv: self.lower >= 0 and self.lower <> Unbounded
/****
[C-55] LowerCannotExceedUpper
format1: LOWERCANNOTEXCEEDUPPER
format2: lowercannotexceedupper
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context MultiplicityType inv: self.lower <= self.upper or self.upper = Unbounded
/****
[C-56] UpperMustBePositive
format1: UPPERMUSTBEPOSITIVE
format2: uppermustbepositive
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context MultiplicityType inv: self.upper >= 1 or self.upper = Unbounded
/****
[C-57] MustBeUnorderedNonunique
format1: MUSTBEUNORDEREDNONUNIQUE
format2: mustbeunorderednonunique
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context MultiplicityType inv: 
         self.upper = 1 implies
         (not self.isOrdered and not self.%isUnique)
/****
[C-59] MustHaveFields
format1: MUSTHAVEFIELDS
format2: musthavefields
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context StructureType
inv:
  self.contents -> exists(c | c.oclIsTypeOf(StructureField))
/****
[MMC-01] StructureFieldsCannotBeObjectValued
format1: STRUCTUREFIELDSCANNOTBEOBJECTVALUED
format2: structurefieldscannotbeobjectvalued
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context StructureField
inv:
self.type.oclIsKindOf(PrimitiveType) or
self.type.oclIsKindOf(EnumerationType) or
self.type.oclIsKindOf(StructureType) or
self.type.oclIsKindOf(Constraint)
/****
[MMC-02] AttributesMustNotBeStatic
format1: ATTRIBUTESMUSTNOTBESTATIC
format2: attributesmustnotbestatic
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Attribute
inv:
self.scope = ScopeKind::instance_level
/****
[MMC-03] DerivedAssocEndsMustMatchChangeability
format1: DERIVEDASSOCENDSMUSTMATCHCHANGEABILITY
format2: derivedassocendsmustmatchchangeability
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Association
inv:

if self.isDerived
-- this check is only for derived associations
then
-- get the ends
    let ends: Sequence(ModelElement) =
        self.contents->
        select(t | t.oclIsKindOf(AssociationEnd))->asSequence()
    in
-- compare the changeability
    ends->at(1).oclAsType(AssociationEnd).isChangeable
        = ends->at(2).oclAsType(AssociationEnd).isChangeable
else
-- non-derived associations are not checked
    true
endif
/****
[MMC-05] CompositeAssociationEndsUpperBoundIs1
format1: COMPOSITEASSOCIATIONENDSUPPERBOUNDIS1
format2: compositeassociationendsupperboundis1
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context AssociationEnd
inv:
self.aggregation = AggregationKind::composite implies self.multiplicity.upper = 1
/****
[MMC-06] ExpressionMustBeBoolean
format1: EXPRESSIONMUSTBEBOOLEAN
format2: expressionmustbeboolean
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context OclConstraint
inv:
    self.language = 'OCL' 
      implies self.oclExpression.type = Boolean
    
/****
[MMC-07] OrderedEndsRequireStorageOnOtherEnd
format1: ORDEREDENDSREQUIRESTORAGEONOTHEREND
format2: orderedendsrequirestorageonotherend
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context AssociationEnd
inv:
if self.multiplicity.isOrdered then
-- an AssociationEnd may not be ordered if the other end does not have storage
-- he other end may become stored because
-- 1) explicitly: there is a \"Storage\" tag on the other end with value \"true\"
-- 2) the other end's type has a reference that has this end as referencedEnd AND
--     the \"Storage\" tag (on the other end) does not exist or it has value \"if_reference\"
-- First we get the other end's type, loop over its references and see if one of them expose this

let exposedEnds:Set(AssociationEnd) =
    self.otherEnd().type.contents->
        select(t | t.oclIsKindOf(Reference))->
            iterate(theElement: ModelElement;
                    theValues: Set(AssociationEnd) = Set{}
                    |
                     theValues->union
                        (theElement.oclAsType(Reference).referencedEnd.asSet())
                   )
in


let exposingReferenceFound = exposedEnds->includes(self) in

let tagFound: Boolean = false in
-- Now we check if the find the \"Storage\" tag and get the values
let values:Set(String) =
    self.otherEnd().tag->iterate(theTag: Tag; 
                      theValues:Set(String) = Set{} 
                      |
                      if theTag.tagId = 'org.omg.sap2mof.store'
                      then
                          let tagFound = true in
                          theValues->union(theTag.values->asSet())
                      else
                          theValues->union(theValues)
                      endif
                     )
in

let trueValueFound = values->exists(val | val='yes') in
let ifRefValueFound = values->exists(val | val='if_reference') in

trueValueFound
or
( exposingReferenceFound and not tagFound )
or
( exposingReferenceFound and ifRefValueFound )


else
-- not ordered, skip all other checks
true
endif
/****
[MMC-09] StructuralFeatureName
format1: STRUCTURALFEATURENAME
format2: structuralfeaturename
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context StructuralFeature
inv:
self.name.size() > 2 implies ( 
self.name.subString(1,2)<>('__') and
self.name.subString(1,3)<>('___') )
/****
[MMC-10] NoSingletonsAllowed
format1: NOSINGLETONSALLOWED
format2: nosingletonsallowed
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Class 
inv: 
  not self.isSingleton
/****
[MMC-11] AssociationsMustNotBeDerived
format1: ASSOCIATIONSMUSTNOTBEDERIVED
format2: associationsmustnotbederived
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Association
inv: not self.isDerived
/****
[MMC-12] AttributesMustNotBeDerived
format1: ATTRIBUTESMUSTNOTBEDERIVED
format2: attributesmustnotbederived
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Attribute
inv: not self.isDerived
/****
[MMC-13] PackageMustBeRootAndLeaf
format1: PACKAGEMUSTBEROOTANDLEAF
format2: packagemustberootandleaf
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context Package
inv:
  self.isRoot and self.isLeaf
/****
[MMC-14] DataTypeMustBeRootAndLeaf
format1: DATATYPEMUSTBEROOTANDLEAF
format2: datatypemustberootandleaf
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context DataType
inv:
  self.isRoot and self.isLeaf
/****
[MMC-15] InitExpressionMustBePrimitiveLiteral
format1: INITEXPRESSIONMUSTBEPRIMITIVELITERAL
format2: initexpressionmustbeprimitiveliteral
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context OclConstraint
inv:
    self.language = 'OCLInit' 
      implies self.oclExpression.oclIsKindOf(PrimitiveLiteralExp)
/****
[MMC-16] InitializedAttributeUpperBoundsMustBeOne
format1: INITIALIZEDATTRIBUTEUPPERBOUNDSMUSTBEONE
format2: initializedattributeupperboundsmustbeone
evaluation policy: Unknown
description: Unknown

original constraint:
****/
context OclConstraint
inv:
    self.language = 'OCLInit' 
      implies self.initializedAttribute.multiplicity.upper = 1

