/****
[O-1] allSupertypes2
description: Helper function for the allSupertypes operation.

original definition:

context GeneralizableElement::allSupertypes2(visited : Set(GeneralizableElement)) : Sequence(GeneralizableElement)
	post: 
		result = 
			if (visited -> includes(self)) then
				Sequence{}
			else
				let mySupers : Sequence(GeneralizableElement) = self.supertypes ->collect(s | s.allSupertypes2(visited ->including(self))) in
					mySupers ->iterate(s2 : GeneralizableElement; a : Sequence(GeneralizableElement) = Sequence{} |
						if a -> includes(s2) then
							a
						else
							a -> append(s2)
						endif)
						
modifications:
1. Removed, since we cannot extend frozen elements like GeneralizableElement

****/

/****
[O-2] extendedNamespace
description: The extendedNamespace of a Namespace is its contents, the contents
of its supertypes, and any Namespaces that it imports.

original definition:
context Namespace::extendedNamespace() : Set(ModelElement)
	post: 
		result = self.contents

modifications:
1. Rewrote into "def" expression.

****/

context Namespace
	def: extendedNamespace() : Set(ModelElement) = 
		self.contents->asSet()

/****
[O-2] extendedNamespace
description: The extendedNamespace of a GeneralizableElement is its contents, the contents
of its supertypes, and any Namespaces that it imports.

original definition:
context GeneralizableElement::extendedNamespace : Set(ModelElement)
	post: 
		result =self.contents ->union(self.allSupertypes() -> collect(s | s.contents))

modifications:
1. Rewrote into "def" expression.
2. OpCallExp needs parentheses.
3. Result type of collect is Bag and type of contents is OrderedSet. Turned both into Sets.
****/

context GeneralizableElement
	def: extendedNamespace() : Set(ModelElement) = 
		self.contents->asSet()->union(self.allSupertypes() -> collect(s | s.contents)->asSet())

/****
[O-2] extendedNamespace
description: The extendedNamespace of a Package is its contents, the contents
of its supertypes, and any Namespaces that it imports.

original definition:
context Package::extendedNamespace : Set(ModelElement)
	post: 
		result =
			let ens = self.contents ->union(self.allSupertypes() -> collect(s | s.contents)) in
				let imports = ens -> select(e | e.oclKindOf(Import)) ->collect(i : Import | i.imported) in
					ens -> union(imports)

modifications:
1. Rewrote into "def" expression.
2. OpCallExp needs parentheses.
3. Turned various collections into Set.
4. Fixed typo "oclKindOf" --> "oclIsKindOf" 
5. Result type of select is ModelElement. Thus, changed type of 
   iterator variable and added cast to proper type
****/
		
context Package
	def: extendedNamespace() : Set(ModelElement) =
			let ens = self.contents->asSet()->union(self.allSupertypes() -> collect(s | s.contents)->asSet()) in
				let imports = ens -> select(e | e.oclIsKindOf(Import)) ->collect(i | i.oclAsType(Import).imported)->asSet() in
					ens -> union(imports)

/****
[O-3] contentTypes
description: The set of OCL types for a Namespace's contents.

original definition:
context Namespace::contentTypes() : Set(OCLType)
	post: 
		result = self.contents -> collect(m | m.oclType()) -> asSet

modifications:
1. Removed since it uses oclType() (which has been removed from OCL 2.0)

****/

/****
[O-4] format1Name
description: The simple name of the element converted to words and reassembled
according to the 'format1' rules; see 'IDL Identifier Format 1' on
page 5-39.

original definition:
context ModelElement::format1Name() : string
	post: 
		result = ...

modifications:
1. Rewrote to "def" expression
2. Turned "..." into something parsable
3. Fixed typo "string" --> "String"

disabled for performance reasons

context ModelElement
	def: format1Name() : String =
		self.name
****/

/****
[O-5] repositoryId
description: The qualified name of the element converted into a standard CORBA
repositoryId string.

original definition:
context ModelElement::repositoryId() : string
	post: 
		result = ...

modifications:
1. Rewrote to "def" expression
2. Turned "..." into something parsable
3. Fixed typo "string" --> "String"

disabled for performance reasons

context ModelElement
	def:repositoryId() : String =
		'???'
****/

/****
[O-8] findDepsOfKind
description: The set of ModelElements that this one Depends on with 'kind'
dependency.

original definition:
context ModelElement::findDepsOfKind(kind : string) : Sequence(ModelElement)
	post: 
		result =
			if kind = 'constraint' then 
				self.constraints()
			else 
				if kind = 'container' then 
					self.container() 
				else 
					if kind = 'constrained elements' and self -> isOclTypeOf(Constraint) then 
						self -> oclAsType(Constraint) -> constrainedElements()
					else 
						if kind = 'specialization' and self -> isOclKindOf(GeneralizableElement) then 
							self -> oclAsType(GeneralizableElement) -> supertypes()
						else 
							if kind = 'import' and self -> isOclType(Import) then 
								self -> oclAsType(Import) -> importedNamespace()
							else 
								if kind = 'contents' and self -> isOclKindOf(Namespace) then 
									self -> oclAsType(Namespace) -> contents()
								else 
									if kind = 'signature' and self -> isOclTypeOf(Operation) then 
										self -> oclAsType(Operation) -> exceptions() 
									else 
										if kind = 'tagged elements' and self -> isOclTypeOf(Tag) then 
											self -> oclAsType(Tag) -> elements()
										else 
											if kind = 'type definition' and self -> isOclKindOf(TypedElement) then 
												self -> oclAsType(TypedElement) -> type() 
											else 
												if kind = 'referenced ends' and self -> isOclKindOf(Reference) then
													let ref = self -> asOclType(Reference) in
														ref -> referencedEnd() -> union(ref -> exposedEnd())
												else
													Set{}
												endif 
											endif 
										endif 
									endif 
								endif 
							endif 
						endif 
					endif 
				endif 
			endif

modifications:
1. Rewrote to "def" expression
2. Fixed typo "string" --> "String"
3. Removed parentheses from references and attributes
4. Turned "->" into "." for stuff in 3
5. Fixed typo "isOclTypeOf" --> "oclIsTypeOf"
6. Fixed typo "isOclKinfOf" --> "oclIsKindOf"
7. Fixed typo "asOclType" --> "oclAsType"
8. Fixed types for results (need to be Sequence)
9. Made OpCallExp to straight op calls

Currently diasbled since ModelElement is frozen

context ModelElement
	def: findDepsOfKind(kind : String) : Sequence(ModelElement) =
		if kind = 'constraint' then 
			self.constraints->asSequence()
		else 
			if kind = 'container' then 
				Sequence{self.container}
			else 
				if kind = 'constrained elements' and self.oclIsTypeOf(Constraint) then 
					self.oclAsType(Constraint).constrainedElements->asSequence()
				else 
					if kind = 'specialization' and self.oclIsKindOf(GeneralizableElement) then 
						self.oclAsType(GeneralizableElement).supertypes->asSequence()
					else 
						if kind = 'import' and self.oclIsTypeOf(Import) then 
							self.oclAsType(Import).importedNamespace->asSequence()
						else 
							if kind = 'contents' and self.oclIsKindOf(Namespace) then 
								self.oclAsType(Namespace).contents->asSequence()
							else 
								if kind = 'signature' and self.oclIsTypeOf(Operation) then 
									self.oclAsType(Operation).exceptions->asSequence()
								else 
									if kind = 'tagged elements' and self.oclIsTypeOf(Tag) then 
										self.oclAsType(Tag).elements->asSequence()
									else 
										if kind = 'type definition' and self.oclIsTypeOf(TypedElement) then 
											Sequence{self.oclAsType(TypedElement).type}
										else 
											if kind = 'referenced ends' and self.oclIsKindOf(Reference) then
												let ref = self.oclAsType(Reference) in
													Sequence{ref.referencedEnd, ref.exposedEnd}
											else
												Sequence{}
											endif 
										endif 
									endif 
								endif 
							endif 
						endif 
					endif 
				endif 
			endif 
		endif
****/

/****
[O-7] isDepOfKind
description: Returns true if this element depends on 'other' with a dependency of
'kind.'

original definition:
context ModelElement::isDepOfKind(kind : string, other : ModelElement) : boolean
	post: 
		result = 
			self -> findDepsOfKind(kind) -> includes(other)

modifications:
1. Rewrote to "def" expression
2. Fixed typo "string" --> "String"
3. Fixed typo "boolean" --> "Boolean"
4. Fixed typo in operation call "->" --> "."

Currently disabled since ModelElement is frozen

context ModelElement
	def: isDepOfKind(kind : String, other : ModelElement) : Boolean = 
		self.findDepsOfKind(kind) -> includes(other)
****/

/****
[S-1] allSupertypes
kind: query Operation
description: The value is the closure of the 'Generalizes' Association from the
perspective of a subtype. Note that the sequence of all supertypes has
a well defined order.

original definition:
context GeneralizableElement::allSupertypes() : Sequence(GeneralizableElement) 
	post: result = self.allSupertypes2(Set{})

modifications:
1. Removed since we cannot attach the body of the pre-defined operation since element is tagged as 
    "frozen" (i.e. unmodifiable)
 
context GeneralizableElement::allSupertypes() : Sequence(GeneralizableElement) 
body:
	self.allSupertypes2(Set{})

    
****/

/****
[S-2] otherEnd
kind: query Operation
description: The value is the other AssociationEnd for this Association.

original definition:
context AssociationEnd::otherEnd() : AssociationEnd
	post: result = self.container.contents ->
		select(c | c.oclIsKindOf(AssociationEnd) and c <> self)

modifications:
1. "select" may return a set, but we need one element. 
2. Rewrote to "body" expression
3. Cast result to AssociationEnd

disabled for performance reasons

context AssociationEnd::otherEnd() : AssociationEnd
	body: self.container.contents ->
		select(c | c.oclIsKindOf(AssociationEnd) and c <> self)->first()->oclAsType(AssociationEnd)
****/

/****
[S-3] isVisible
kind: query Operation
description: Determines whether or not 'otherElement' is visible for the definition
of this element. (Note: As an interim measure, the OCL states that
everything is visible!)

original definition:
context ModelElement::isVisible(otherElement : ModelElement): boolean 
	post: result = true

modification:
1. Fixed typo "boolean" --> "Boolean"
2. Rewrote to "body" expression

disabled for performance reasons

context ModelElement ::isVisible(otherElement : ModelElement): Boolean 
	body: true
****/

/****
[S-4] isRequiredBecause
kind: query Operation
description: Returns the DependencyKind that describes the dependency between
this element and 'other.'

original definition:
context ModelElement::isRequiredBecause(other : ModelElement, reason : out DependencyType) : boolean
	post: 
		-- NB, if there is more than one dependency between self
		-- and 'other', the selection of the 'reason' is defined
		-- to be non-deterministic ... not deterministic as a
		-- left to right evaluation of the OCL implies.
		reason = (
			if self -> isDepOfKind('constraint', other) then
				'constraint'
			else 
				if self -> isDepOfKind('container', other) then
					'container'
				else 
					if self -> isDepOfKind('constrained elements', other) then
						'constrained elements'
					else 
						if self -> isDepOfKind('specialization', other) then
							'specialization'
						else 
							if self -> isDepOfKind('import', other) then
								'import'
							else 
								if self -> isDepOfKind('contents', other) then
									'contents'
								else 
									if self -> isDepOfKind('signature', other) then
										'signature'
									else 
										if self -> isDepOfKind('tagged elements', other) then
											'tagged elements'
										else 
											if self -> isDepOfKind('type definition', other) then
												'type definition' 
											else 
												if self -> isDepOfKind('referenced ends', other) then
													'referenced ends'
												else 
													if self -> dependsOn() -> notEmpty() then
														'indirect'
													else 
														''
													endif
												endif
											endif
										endif
									endif
								endif
							endif
						endif
					endif
				endif
			endif) and result = (reason <> '')

modifications:
1. Wrong signature
2. Fixed typo "boolean" --> "Boolean"
3. Got rid of "reason" variable
4. Made OpCallExp straight 
5. Removed parentheses from references 
6. Changed "dependsOn" to "provider"

Disabled since isDepOfKind is not defined for ModelElement

context ModelElement::isRequiredBecause(other : ModelElement, reason : String) : Boolean
	post: 
		if self.isDepOfKind('constraint', other) then
			result = true
		else 
			if self.isDepOfKind('container', other) then
				result = true
			else 
				if self.isDepOfKind('constrained elements', other) then
					result = true
				else 
					if self.isDepOfKind('specialization', other) then
						result = true
					else 
						if self.isDepOfKind('import', other) then
							result = true
						else 
							if self.isDepOfKind('contents', other) then
								result = true
							else 
								if self.isDepOfKind('signature', other) then
									result = true
								else 
									if self.isDepOfKind('tagged elements', other) then
										result = true
									else 
										if self.isDepOfKind('type definition', other) then
											result = true 
										else 
											if self.isDepOfKind('referenced ends', other) then
												result = true
											else 
												if self.provider->notEmpty() then
													result = true
												else 
													result = false
												endif
											endif
										endif
									endif
								endif
							endif
						endif
					endif
				endif
			endif
		endif
****/
/****
[S-5] findRequiredElements
kind: query Operation
description: Selects a subset of a ModelElement's immediate or recursive
dependents.

original definition:
context ModelElement::findRequiredElements(kinds : Sequence(DependencyKind), recursive : boolean) : Sequence(ModelElement)
	post: result =
		if kinds -> includes('all') then
			self.findRequiredElements(Set{'constraint', 'container', 'constrained elements',
				'specialization', 'import', 'contents', 'signature',
				'tagged elements', 'type definition',
				'referenced ends'})
		else
			if recursive then
				self.recursiveFindDeps(kinds, Set{self})
			else
				kinds -> collect(k : self.findDepsOfKind(k)) -> asSet()
			endif 
		endif

modifications:
1. Wrong signature
2. Fixed typo ":" --> "|"
3. Fixed parameter type for recursive call
4. Fixed return type
5. Fixed typo boolean --> Boolean
6. Parameter type for kinds is Set, not Sequence

Disabled since recursiveFindDeps is not defined for frozen ModelElement


context ModelElement::findRequiredElements(kinds : Set(String), recursive : Boolean) : Sequence(ModelElement)
	post: result =
		if kinds ->includes('all')  then
			self.findRequiredElements(Set{'constraint', 'container', 'constrained elements',
				'specialization', 'import', 'contents', 'signature',
				'tagged elements', 'type definition',
				'referenced ends'}, true)
		else
			if recursive then
				self.recursiveFindDeps(kinds, Set{self})
			else
				kinds -> collect(k | self.findDepsOfKind(k)) -> asSequence()
			endif 
		endif
****/

/****
[S-6] lookupElement
kind: query Operation
description: Returns the ModelElement in the Namespace whose name is equal to
'name,' or raises an exception.

Disabled since if case does not have a valid statement

context Namespace::lookupElement(name : string) : ModelElement
	post: 
		result = let elems = self.contents -> select(m | m.name = name) in
			if elems -> size = 0 then
				-- Raise exception NameNotFound
			else
				elems -> first -- should only be one
			endif
****/

/****
[S-7] resolveQualifiedName
kind: query Operation
description: Returns the ModelElement that 'qualifiedName' resolves to or raises
an exception.

Disabled since if case does not have a valid statement

context Namespace::resolveQualifiedName(qualifiedName : Sequence(string)) : ModelElement
	pre: 
		qualifiedName -> size >= 1 
	post: 
		result = let elems = self.contents ->select(m | m.name = qualifiedName -> first) in
			if elems -> size = 0 then
				-- Raise exception NameNotResolved ...
			else
				if qualifiedName -> size = 1 then
					elems -> first -- there should only be one
				else
					if not elems -> first -> oclIsOfKind(Namespace) then
						-- Raise exception NameNotResolved ...
					else
						let rest = qualifiedName ->subSequence(2, qualifiedName -> size) in
							elems -> first -> resolveQualifiedName(rest)
					endif
				endif
			endif
****/

/****
[S-8] nameIsValid
kind: query Operation
description: Returns true if 'proposedName' is a valid name that could be used for
a new containedElement of this Namespace.

original definition:
context Namespace::nameIsValid(proposedName : string) : boolean
	post: 
		result =self.extendedNamespace ->forAll(e | not e.name = proposedName)

modifications:
1. Fixed typo boolean --> Boolean
2. Fixed typo string --> String
3. OperationCallExp need parentheses

Currently disabled since we are not yet able to attach operation definitions to model elements

context Namespace::nameIsValid(proposedName : String) : Boolean
	post: 
		result =self.extendedNamespace() ->forAll(e | not e.name = proposedName)
****/
/****
[S-9] findElementsByType
kind: query Operation
description: Returns a subset of the contained elements. If 'includeSubtypes' is
false, the result consists of instances of 'ofType'. If it is true, instances
of subClasses are included.

original definition:
context Namespace::findElementsByType(ofType : Class, includeSubtypes : boolean) : Sequence(ModelElement)
	post: 
		result =
			if includeSubtypes then
				self.contents -> select(m | m.oclIsOfKind(ofType))
			else
				self.contents -> select(m | m.oclIsOfType(ofType))
			endif

modifications:
1. Fixed typo boolean --> Boolean
2. Fixed typo oclIsOfKind --> oclIsKindOf
3. Fixed typo oclIsOfType --> oclIsTypeOf
4. Fixed return type

Disabled since oclIsKindOf/oclIsTypeOf cannot be called with a variable, parameter
must be a literal

context Namespace::findElementsByType(ofType : Class, includeSubtypes : Boolean) : OrderedSet(ModelElement)
	post: 
		result =
			if includeSubtypes then
				self.contents -> select(m | m.oclIsKindOf(ofType))
			else
				self.contents -> select(m | m.oclIsTypeOf(ofType))
			endif
****/

/****
[S-10] lookupElementExtended
kind: query Operation
description: Returns the ModelElement whose name is equal to 'name' in the
extended namespace of this GeneralizableElement, or raises an
exception.

Disabled since then clause does not have a valid subexpression
context Namespace::lookupElementExtended(name : string) : ModelElement
	post: 
		result = 
			let elems = self -> extendedNamespace ->select(m | m.name = name) in
				if elems -> size = 0 then
					-- Raise exception NameNotFound
				else
					elems -> first -- should only be one
				endif
****/


/****
[S-11] findElementsByTypeExtended
kind: query Operation
description: Returns a subset of the contained, inherited, or imported elements. If
'includeSubtypes' is false, the result consists of instances of
'ofType.' If it is true, instances of subClasses are included.

original definition:
context GeneralizeableElement::findElementsByTypeExtended(ofType : Class, includeSubtypes : boolean) : Sequence(ModelElement)
	post: 
		result = 
			if includeSubtypes then
				self.extendedNamespace -> select(m | m.oclIsOfKind(ofType))
			else 
				self.extendedNamespace -> select(m | m.oclIsOfType(ofType))
			endif

modifications:
1. Fixed typo boolean --> Boolean
2. OperationCallExp need parentheses

Currently disabled since we are not yet able to attach operation definitions to model elements

context GeneralizeableElement::findElementsByTypeExtended(ofType : Class, includeSubtypes : Boolean) : Sequence(ModelElement)
	post: 
		result = 
			if includeSubtypes then
				self.extendedNamespace() -> select(m | m.oclIsOfKind(ofType))
			else 
				self.extendedNamespace() -> select(m | m.oclIsOfType(ofType))
			endif
****/

/****
[S-12] qualifiedName
kind: readonly derived Attribute
description: The qualified name gives the sequence of names of the containers of
this ModelElement starting with the outermost.

original definition:
context ModelElement::qualifiedName() : Sequence(ModelElement)
	post: 
		result =
			if self.container -> notEmpty then
				self.container.qualifiedName() -> append(self.name)
			else
				self.name
			endif

modifications:
1. OperationCallExp need parentheses

Disabled since qualifiedName is an attribute, not an operation

context ModelElement::qualifiedName: Sequence(ModelElement)
	post: 
		result =
			if self.container -> notEmpty() then
				self.container.qualifiedName() -> append(self.name)
			else
				self.name
			endif
****/

/****
[S-13] Exposes
kind: derived Association
description: This association relates a Reference to the exposed AssociationEnd of
an Association that corresponds to its referencedEnd.

original definition:
context Reference
	inv: 
		AssociationEnd.allInstances ->forAll(a |self.references = a implies self.exposes = a.otherEnd and 
			not self.references = a implies self.exposes <> a.otherEnd)

modifications:
1. OperationCallExp need parentheses
2. Fixed typo reference --> referencedEnd
3. Fixed typo exposes --> exposedEnd
4. Inserted parentheses for disambiguing statement

MOVED TO CONSTRAINTS SINCE THIS IS AN INVARIANT!

context Reference
	inv: 
		AssociationEnd.allInstances() ->forAll(a |self.referencedEnd = a implies self.exposedEnd= a.otherEnd() and 
			not (self.referencedEnd = a implies self.exposedEnd <> a.otherEnd()))

****/

/****
[S-14] DependsOn
kind: derived Association
description: This association relates a ModelElement to the other ModelElements
whose definition it depends on.

MOVED TO CONSTRAINTS SINCE THIS IS AN INVARIANT!

context ModelElement
	inv: 
		self.findRequiredElements('all', true)
****/

/****
[O-6] recursiveFindDeps
description: The set of ModelElements that recursively depend on this one.

original definition:
context ModelElement::recursiveFindDeps(kinds : Sequence(string), seen : Set(ModelElement)) : Set(ModelElement)
	post: 
		result = 
			let seen2 = seen ->collect(m | kinds ->collect(k | m.findDepsOfKind(k)) -> asSet) in
				if seen2 = seen then
					seen
				else
					self.recursiveFindDeps(kinds, seen2)
				endif

modifications:
1. Rewrote into "def" expression
2. Fixed typo "string" --> "String"
3. OpCallExp needs parentheses

Disabled since ModelElement is frozen

context ModelElement
	def: recursiveFindDeps(kinds : Sequence(String), seen : Set(ModelElement)) : Set(ModelElement) = 
		let seen2 = seen ->collect(m | kinds ->collect(k | m.findDepsOfKind(k)) -> asSet()) in
				if seen2 = seen then
					seen
				else
					self.recursiveFindDeps(kinds, seen2)
				endif

****/