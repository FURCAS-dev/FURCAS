
Options in effect for C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MqlParser.g:

    ACTION-BLOCK=("MqlParserGen.java","/.","./")

    AST-DIRECTORY="./mqlAst"  AST-TYPE="Node"  NOATTRIBUTES  
    AUTOMATIC-AST=TOPLEVEL  NOBACKTRACK  BYTE  CONFLICTS  DAT-DIRECTORY="./"  
    DAT-FILE="MqlParserGendcl.data"  DCL-FILE="MqlParserGendcl.java"  NODEBUG  
    DEF-FILE="MqlParserGendef.java"  NOEDIT  ERROR-MAPS  ESCAPE='$'  
    EXPORT-TERMINALS=("MqlParserGenexp.java","","")  EXTENDS-PARSETABLE  
    FACTORY="new "  FILE-PREFIX="MqlParserGen"  FIRST  FOLLOW  NOGOTO-DEFAULT  
    GRM-FILE="C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MqlParser.g"
    FACTORY="new "  FILE-PREFIX="MqlParserGen"  FIRST  FOLLOW  NOGOTO-DEFAULT  
    IMP-FILE="MqlParserGenimp.java"  IMPORT-TERMINALS="MqlLexer.g"  
    INCLUDE-DIRECTORY="C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\"
    IMP-FILE="MqlParserGenimp.java"  IMPORT-TERMINALS="MqlLexer.g"  LALR=1  LIST
    MARGIN=4  MAX-CASES=1024  NAMES=OPTIMIZED  NONT-CHECK  OR_MARKER='|'  
    PACKAGE="org.eclipse.emf.query2.internal.moinql.parser.gen"  NOPARENT-SAVE  
    PARSETABLE-INTERFACES="lpg.lpgjavaruntime.ParseTable"  PREFIX="TK_"  
    PRIORITY  PROGRAMMING_LANGUAGE=JAVA  PRS-FILE="MqlParserGenprs.java"  
    NOQUIET  READ-REDUCE  REMAP-TERMINALS  SCOPES  NOSERIALIZE  NOSHIFT-DEFAULT
    NOSINGLE-PRODUCTIONS  NOSOFT-KEYWORDS  STATES  SUFFIX=""  
    SYM-FILE="MqlParserGensym.java"  TAB-FILE="MqlParser.t"  TABLE  
    TEMPLATE="dtParserTemplateD.g"  TRACE=CONFLICTS  VARIABLES=NONTERMINALS  
    VERBOSE  VISITOR=DEFAULT  VISITOR-TYPE="MqlAstVisitor"  WARNINGS  XREF  

The macro "$NON" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\dtParserTemplateD.g at line 240 is undefined. No susbtitution made
The macro "$" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\dtParserTemplateD.g at line 240 is undefined. No susbtitution made
The macro "$NON" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\dtParserTemplateD.g at line 322 is undefined. No susbtitution made
The macro "$" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\dtParserTemplateD.g at line 322 is undefined. No susbtitution made
The macro "$NON" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\dtParserTemplateD.g at line 330 is undefined. No susbtitution made
The macro "$" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\dtParserTemplateD.g at line 330 is undefined. No susbtitution made
The macro "$NON" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\dtParserTemplateD.g at line 330 is undefined. No susbtitution made
The macro "$" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\dtParserTemplateD.g at line 330 is undefined. No susbtitution made
The macro "$NON" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 223 is undefined. No susbtitution made
The macro "$" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 223 is undefined. No susbtitution made
The macro "$NON" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 231 is undefined. No susbtitution made
The macro "$" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 231 is undefined. No susbtitution made
The macro "$NON" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 235 is undefined. No susbtitution made
The macro "$" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 235 is undefined. No susbtitution made
The macro "$NON" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 235 is undefined. No susbtitution made
The macro "$" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 235 is undefined. No susbtitution made
The macro "$NON" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 313 is undefined. No susbtitution made
The macro "$" used in file C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MoinParserTemplate.g at line 313 is undefined. No susbtitution made

Predefined Macros:

    $rule_number
    $rule_text
    $rule_size
    $input_file
    $current_line
    $next_line
    $symbol_declarations
    $num_rules
    $num_terminals
    $num_nonterminals
    $num_non_terminals
    $num_symbols
    $template
    $file_prefix
    $package
    $ast_package
    $ast_type
    $exp_type
    $prs_type
    $sym_type
    $action_type
    $vititor_type



Defined Symbols:



    $Header
    /.    
                    //    
                    // Rule $rule_number:  $rule_text    
                    //./


    $BeginAction
    /. $Header    
                    case $rule_number: {./


    $EndAction
    /.          break;    
                    }./


    $BeginJava
    /.$BeginAction    
                        $symbol_declarations./


    $EndJava
    /.$EndAction./


    $NoAction
    /. $Header    
                    case $rule_number:    
                        break;./


    $BadAction
    /. $Header    
                    case $rule_number:    
                        throw new Error("No action specified for rule " + $rule_number);./


    $NullAction
    /. $Header    
                    case $rule_number:    
                        setResult(null);    
                        break;./


    $BeginActions
    /.    
            public void ruleAction(int ruleNumber)    
            {    
                switch (ruleNumber)    
                {./


    $SplitActions
    /.    
    	            default:    
    	                ruleAction$rule_number(ruleNumber);    
    	                break;    
    	        }    
    	        return;    
    	    }    
    	    
    	    public void ruleAction$rule_number(int ruleNumber)    
    	    {    
    	        switch (ruleNumber)    
    	        {./


    $EndActions
    /.    
                    default:    
                        break;    
                }    
                return;    
            }./


    $additional_interfaces
    /../


    $ast_class
    /.$ast_type./


    $setSym1
    /. // macro setSym1 is deprecated. Use function setResult    
                    getParser().setSym1./


    $setResult
    /. // macro setResult is deprecated. Use function setResult    
                     getParser().setSym1./


    $getSym
    /. // macro getSym is deprecated. Use function getRhsSym    
                  getParser().getSym./


    $getToken
    /. // macro getToken is deprecated. Use function getRhsTokenIndex    
                    getParser().getToken./


    $getIToken
    /. // macro getIToken is deprecated. Use function getRhsIToken    
                     super.getIToken./


    $getLeftSpan
    /. // macro getLeftSpan is deprecated. Use function getLeftSpan    
                       getParser().getFirstToken./


    $getRightSpan
    /. // macro getRightSpan is deprecated. Use function getRightSpan    
                        getParser().getLastToken./


Aliases:

    > ::= GREATER
    < ::= LESS
    = ::= EQUAL
    >= ::= GREATER_EQUAL
    <= ::= LESS_EQUAL
    <> ::= NOT_EQUAL
    ( ::= LPAREN
    ) ::= RPAREN
    { ::= LBRACE
    } ::= RBRACE
    [ ::= LBRACKET
    ] ::= RBRACKET
    , ::= COMMA
    : ::= COLON
    :: ::= COLONCOLON
    . ::= DOT
    ! ::= EXCLAMATION
    # ::= SHARP


Start:

    query

Identifier:

    IDENTIFIER

Eof:

    EOF_TOKEN

Error:

    ERROR_TOKEN

Terminals:

    STRING_LITERAL
    INTEGER_LITERAL
    REAL_LITERAL
    GREATER
    LESS
    EQUAL
    GREATER_EQUAL
    LESS_EQUAL
    NOT_EQUAL
    LPAREN
    RPAREN
    LBRACE
    RBRACE
    LBRACKET
    RBRACKET
    COMMA
    COLON
    COLONCOLON
    DOT
    EXCLAMATION
    SHARP
    select
    from
    type
    where
    as
    withoutsubtypes
    not
    in
    resources
    elements
    for
    or
    and
    like
    true
    false
    null
    EOF_TOKEN
    FRAGMENTADDRESS
    URI
    IDENTIFIER
    ERROR_TOKEN


Soft Keywords:



Rules:

1      identifierM ::= $Empty
2      identifierM -> identifierN
3      identifierN -> identifier
4      identifierN$IdentifierN ::= identifier , identifierN
5      identifier$Ident ::= IDENTIFIER
6      sPathName$PathNameIdent ::= identifier
7      pathName -> identifierWithOptContainerPrefix
8      identifierWithOptContainerPrefix -> sPathName
9      typePathName -> pathName
10     query$MqlQuery ::= selectClause fromClause whereClauseM
11     query ::= $Empty
12     selectClause$SelectClause ::= select selectEntryN
13     selectEntryN$SelectEntryN ::= selectEntry , selectEntryN
14     selectEntryN -> selectEntry
15     selectEntry$SelectAlias ::= identifier
16     selectEntry$SelectAttribute ::= identifier . identifier
17     fromClause$FromClause ::= from fromEntryN
18     fromEntryN$FromEntryN ::= fromEntry , fromEntryN
19     fromEntryN -> fromEntry
20     fromEntry$FromEntry ::= typeClause as identifier scopeClauseOpt
21     typeClause -> typeClauseQName
22     typeClauseQName$TypeQName ::= fragmentaddress withoutsubtypesOpt
23     withoutsubtypesOpt ::= $Empty
24     withoutsubtypesOpt$Withoutsubtypes ::= withoutsubtypes typeSetClauseOpt
25     typeSetClauseOpt ::= $Empty
26     typeSetClauseOpt$TypeSetClause ::= { typePathNameN }
27     typePathNameM ::= $Empty
28     typePathNameM -> typePathNameN
29     typePathNameN -> fragmentaddress
30     typePathNameN$TypePathNameN ::= fragmentaddress , typePathNameN
31     elementPathNameM ::= $Empty
32     elementPathNameM -> elementPathNameN
33     elementPathNameN -> fragmentaddress
34     elementPathNameN$ElementPathNameN ::= fragmentaddress , elementPathNameN
35     fragmentaddress$FragmentAddress ::= FRAGMENTADDRESS
36     uriM ::= $Empty
37     uriM -> uriN
38     uriN -> uri
39     uriN$UriN ::= uri , uriN
40     uri$Uri ::= URI
41     scopeClauseOpt ::= $Empty
42     scopeClauseOpt$ScopeClause ::= notOpt in scopeClause
43     scopeClause$PartitionScope ::= resources { uriM }
44     scopeClause$InElements ::= elements { elementPathNameM }
45     whereClauseM ::= $Empty
46     whereClauseM -> whereClauseN
47     whereClauseN -> whereClause
48     whereClauseN$WhereClauseN ::= whereClause whereClauseN
49     whereClause$WhereClause ::= where whereEntry
50     whereEntry -> localWhereEntry
51     whereEntry -> joinWhereEntry
52     localWhereEntry$LocalWhereEntry ::= for identifier ( localWhereCondition )
53     localWhereCondition -> negativeWhereCondition
54     localWhereCondition$AndWhereCondition ::= localWhereCondition and negativeWhereCondition
55     localWhereCondition$OrWhereCondition ::= localWhereCondition or negativeWhereCondition
56     negativeWhereCondition$NotWhereCondition ::= not negativeWhereCondition
57     negativeWhereCondition -> operationCondition
58     operationCondition$OperationCondition ::= identifier operationPart
59     operationCondition$ParenthesizedLocalWhereCondition ::= ( localWhereCondition )
60     operationPart$OpSmaller ::= < literal
61     operationPart$OpGreater ::= > literal
62     operationPart$OpSmallerEqual ::= <= literal
63     operationPart$OpGreaterEqual ::= >= literal
64     operationPart$OpEqual ::= = literal
65     operationPart$OpNotEqual ::= <> literal
66     operationPart$OpLike ::= like literal
67     operationPart$NotLike ::= not like literal
68     literal$IntegerLiteral ::= INTEGER_LITERAL
69     literal$RealLiteral ::= REAL_LITERAL
70     literal$StringLiteral ::= STRING_LITERAL
71     literal$TrueLiteral ::= true
72     literal$FalseLiteral ::= false
73     literal$NullLiteral ::= null
74     joinWhereEntry$JoinWhereEntry ::= identifier . navigationStep joinPart
75     joinWhereEntry$AliasComparisonClause ::= identifier = identifier
76     navigationStep$NameBasedNavigation ::= identifier
77     joinPart -> nonLinkPredicate
78     joinPart$LinkPredicate ::= notOpt in ( query )
79     nonLinkPredicate$AssocOrComparisonPredicate ::= = comparisonPostElementEquals
80     nonLinkPredicate$ComparisonSmallerPredicate ::= < comparisonPostElementOtherOperation
81     nonLinkPredicate$ComparisonGreaterPredicate ::= > comparisonPostElementOtherOperation
82     nonLinkPredicate$ComparisonSmallerEqualPredicate ::= <= comparisonPostElementOtherOperation
83     nonLinkPredicate$ComparisonGreaterEqualPredicate ::= >= comparisonPostElementOtherOperation
84     nonLinkPredicate$ComparisonNotEqualPredicate ::= <> comparisonPostElementOtherOperation
85     nonLinkPredicate$ComparisonLikePredicate ::= like literal
86     nonLinkPredicate$ComparisonNotLikePredicate ::= not like literal
87     comparisonPostElementEquals$LiteralEqualsComparisonInPredicate ::= literal
88     comparisonPostElementEquals$IdentifierEqualsComparisonInPredicate ::= identifier comparisonPostFix
89     comparisonPostElementOtherOperation$LiteralComparisonInPredicate ::= literal
90     comparisonPostElementOtherOperation$IdentifierComparisonInPredicate ::= identifier . identifier
91     comparisonPostFix ::= $Empty
92     comparisonPostFix$ComparisonPredicate ::= . identifier
93     notOpt ::= $Empty
94     notOpt$Not ::= not
*** The following Terminals are useless: 
        LBRACKET  RBRACKET  COLON  COLONCOLON  EXCLAMATION  SHARP  type  
*** The following Non-Terminals are useless: 
        identifierM identifierN sPathName pathName 
    identifierWithOptContainerPrefix typePathName typePathNameM 


 IBM LALR Parser Generator              1.00 (Oct  8 2008)



Cross-reference table:


COLON  ==>> 

COLONCOLON  ==>> 

COMMA  ==>> 4 13 18 30 34 39 

DOT  ==>> 16 74 90 92 

EQUAL  ==>> 64 75 79 

ERROR_TOKEN  ==>> 

EXCLAMATION  ==>> 

FRAGMENTADDRESS  ==>> 35 

GREATER  ==>> 61 81 

GREATER_EQUAL  ==>> 63 83 

IDENTIFIER  ==>> 5 

INTEGER_LITERAL  ==>> 68 

LBRACE  ==>> 26 43 44 

LBRACKET  ==>> 

LESS  ==>> 60 80 

LESS_EQUAL  ==>> 62 82 

LPAREN  ==>> 52 59 78 

NOT_EQUAL  ==>> 65 84 

RBRACE  ==>> 26 43 44 

RBRACKET  ==>> 

REAL_LITERAL  ==>> 69 

RPAREN  ==>> 52 59 78 

SHARP  ==>> 

STRING_LITERAL  ==>> 70 

URI  ==>> 40 

and  ==>> 54 

as  ==>> 20 

comparisonPostElementEquals  ==>> 87 88 

comparisonPostElementOtherOperation  ==>> 89 90 

comparisonPostFix  ==>> 91 92 

elementPathNameM  ==>> 31 32 

elementPathNameN  ==>> 33 34 

elements  ==>> 44 

false  ==>> 72 

for  ==>> 52 

fragmentaddress  ==>> 35 

from  ==>> 17 

fromClause  ==>> 17 

fromEntry  ==>> 20 

fromEntryN  ==>> 18 19 

identifier  ==>> 5 

identifierM  ==>> 1 2 

identifierN  ==>> 3 4 

identifierWithOptContainerPrefix  ==>> 8 

in  ==>> 42 78 

joinPart  ==>> 77 78 

joinWhereEntry  ==>> 74 75 

like  ==>> 66 67 85 86 

literal  ==>> 68 69 70 71 72 73 

localWhereCondition  ==>> 53 54 55 

localWhereEntry  ==>> 52 

navigationStep  ==>> 76 

negativeWhereCondition  ==>> 56 57 

nonLinkPredicate  ==>> 79 80 81 82 83 84 85 86 

not  ==>> 56 67 86 94 

notOpt  ==>> 93 94 

null  ==>> 73 

operationCondition  ==>> 58 59 

operationPart  ==>> 60 61 62 63 64 65 66 67 

or  ==>> 55 

pathName  ==>> 7 

query  ==>> 10 11 

resources  ==>> 43 

sPathName  ==>> 6 

scopeClause  ==>> 43 44 

scopeClauseOpt  ==>> 41 42 

select  ==>> 12 

selectClause  ==>> 12 

selectEntry  ==>> 15 16 

selectEntryN  ==>> 13 14 

true  ==>> 71 

type  ==>> 

typeClause  ==>> 21 

typeClauseQName  ==>> 22 

typePathName  ==>> 9 

typePathNameM  ==>> 27 28 

typePathNameN  ==>> 29 30 

typeSetClauseOpt  ==>> 25 26 

uri  ==>> 40 

uriM  ==>> 36 37 

uriN  ==>> 38 39 

where  ==>> 49 

whereClause  ==>> 49 

whereClauseM  ==>> 45 46 

whereClauseN  ==>> 47 48 

whereEntry  ==>> 50 51 

withoutsubtypes  ==>> 24 

withoutsubtypesOpt  ==>> 23 24 



 IBM LALR Parser Generator              1.00 (Oct  8 2008)


First map for non-terminals:


'$accept'  ==>> select EOF_TOKEN 

query  ==>> '$empty' select 

identifierM  ==>> '$empty' IDENTIFIER 

identifierN  ==>> IDENTIFIER 

identifier  ==>> IDENTIFIER 

sPathName  ==>> IDENTIFIER 

pathName  ==>> IDENTIFIER 

identifierWithOptContainerPrefix  ==>> IDENTIFIER 

typePathName  ==>> IDENTIFIER 

selectClause  ==>> select 

fromClause  ==>> from 

whereClauseM  ==>> '$empty' where 

selectEntryN  ==>> IDENTIFIER 

selectEntry  ==>> IDENTIFIER 

fromEntryN  ==>> FRAGMENTADDRESS 

fromEntry  ==>> FRAGMENTADDRESS 

typeClause  ==>> FRAGMENTADDRESS 

scopeClauseOpt  ==>> '$empty' not in 

typeClauseQName  ==>> FRAGMENTADDRESS 

fragmentaddress  ==>> FRAGMENTADDRESS 

withoutsubtypesOpt  ==>> '$empty' withoutsubtypes 

typeSetClauseOpt  ==>> '$empty' LBRACE 

typePathNameN  ==>> FRAGMENTADDRESS 

typePathNameM  ==>> '$empty' FRAGMENTADDRESS 

elementPathNameM  ==>> '$empty' FRAGMENTADDRESS 

elementPathNameN  ==>> FRAGMENTADDRESS 

uriM  ==>> '$empty' URI 

uriN  ==>> URI 

uri  ==>> URI 

notOpt  ==>> '$empty' not 

scopeClause  ==>> resources elements 

whereClauseN  ==>> where 

whereClause  ==>> where 

whereEntry  ==>> for IDENTIFIER 

localWhereEntry  ==>> for 

joinWhereEntry  ==>> IDENTIFIER 

localWhereCondition  ==>> LPAREN not IDENTIFIER 

negativeWhereCondition  ==>> LPAREN not IDENTIFIER 

operationCondition  ==>> LPAREN IDENTIFIER 

operationPart  ==>> GREATER LESS EQUAL GREATER_EQUAL LESS_EQUAL NOT_EQUAL not 
    like 

literal  ==>> STRING_LITERAL INTEGER_LITERAL REAL_LITERAL true false null 

navigationStep  ==>> IDENTIFIER 

joinPart  ==>> GREATER LESS EQUAL GREATER_EQUAL LESS_EQUAL NOT_EQUAL not in 
    like 

nonLinkPredicate  ==>> GREATER LESS EQUAL GREATER_EQUAL LESS_EQUAL NOT_EQUAL 
    not like 

comparisonPostElementEquals  ==>> STRING_LITERAL INTEGER_LITERAL REAL_LITERAL 
    true false null IDENTIFIER 

comparisonPostElementOtherOperation  ==>> STRING_LITERAL INTEGER_LITERAL 
    REAL_LITERAL true false null IDENTIFIER 

comparisonPostFix  ==>> '$empty' DOT 


 IBM LALR Parser Generator              1.00 (Oct  8 2008)


Follow Map:


'$accept'  ==>> EOF_TOKEN 

query  ==>> RPAREN EOF_TOKEN 

identifierM  ==>> 

identifierN  ==>> 

identifier  ==>> GREATER LESS EQUAL GREATER_EQUAL LESS_EQUAL NOT_EQUAL LPAREN 
    RPAREN COMMA DOT from where not in like EOF_TOKEN 

sPathName  ==>> 

pathName  ==>> 

identifierWithOptContainerPrefix  ==>> 

typePathName  ==>> 

selectClause  ==>> from 

fromClause  ==>> RPAREN where EOF_TOKEN 

whereClauseM  ==>> RPAREN EOF_TOKEN 

selectEntryN  ==>> from 

selectEntry  ==>> COMMA from 

fromEntryN  ==>> RPAREN where EOF_TOKEN 

fromEntry  ==>> RPAREN COMMA where EOF_TOKEN 

typeClause  ==>> as 

scopeClauseOpt  ==>> RPAREN COMMA where EOF_TOKEN 

typeClauseQName  ==>> as 

fragmentaddress  ==>> RBRACE COMMA as withoutsubtypes 

withoutsubtypesOpt  ==>> as 

typeSetClauseOpt  ==>> as 

typePathNameN  ==>> RBRACE 

typePathNameM  ==>> 

elementPathNameM  ==>> RBRACE 

elementPathNameN  ==>> RBRACE 

uriM  ==>> RBRACE 

uriN  ==>> RBRACE 

uri  ==>> RBRACE COMMA 

notOpt  ==>> in 

scopeClause  ==>> RPAREN COMMA where EOF_TOKEN 

whereClauseN  ==>> RPAREN EOF_TOKEN 

whereClause  ==>> RPAREN where EOF_TOKEN 

whereEntry  ==>> RPAREN where EOF_TOKEN 

localWhereEntry  ==>> RPAREN where EOF_TOKEN 

joinWhereEntry  ==>> RPAREN where EOF_TOKEN 

localWhereCondition  ==>> RPAREN or and 

negativeWhereCondition  ==>> RPAREN or and 

operationCondition  ==>> RPAREN or and 

operationPart  ==>> RPAREN or and 

literal  ==>> RPAREN where or and EOF_TOKEN 

navigationStep  ==>> GREATER LESS EQUAL GREATER_EQUAL LESS_EQUAL NOT_EQUAL not 
    in like 

joinPart  ==>> RPAREN where EOF_TOKEN 

nonLinkPredicate  ==>> RPAREN where EOF_TOKEN 

comparisonPostElementEquals  ==>> RPAREN where EOF_TOKEN 

comparisonPostElementOtherOperation  ==>> RPAREN where EOF_TOKEN 

comparisonPostFix  ==>> RPAREN where EOF_TOKEN 


 IBM LALR Parser Generator              1.00 (Oct  8 2008)


Name map:

'$empty' ::= '$empty'
STRING_LITERAL ::= STRING_LITERAL
INTEGER_LITERAL ::= INTEGER_LITERAL
REAL_LITERAL ::= REAL_LITERAL
GREATER ::= >
LESS ::= <
EQUAL ::= =
GREATER_EQUAL ::= >=
LESS_EQUAL ::= <=
NOT_EQUAL ::= <>
LPAREN ::= (
RPAREN ::= )
LBRACE ::= {
RBRACE ::= }
LBRACKET ::= [
RBRACKET ::= ]
COMMA ::= ,
COLON ::= :
COLONCOLON ::= ::
DOT ::= .
EXCLAMATION ::= !
SHARP ::= #
select ::= select
from ::= from
type ::= type
where ::= where
as ::= as
withoutsubtypes ::= withoutsubtypes
not ::= not
in ::= in
resources ::= resources
elements ::= elements
for ::= for
or ::= or
and ::= and
like ::= like
true ::= true
false ::= false
null ::= null
EOF_TOKEN ::= EOF_TOKEN
FRAGMENTADDRESS ::= FRAGMENTADDRESS
URI ::= URI
IDENTIFIER ::= IDENTIFIER
ERROR_TOKEN ::= ERROR_TOKEN
identifier ::= identifier
selectClause ::= selectClause
fromClause ::= fromClause
selectEntryN ::= selectEntryN
selectEntry ::= selectEntry
fromEntryN ::= fromEntryN
fromEntry ::= fromEntry
typeClause ::= typeClause
fragmentaddress ::= fragmentaddress
typePathNameN ::= typePathNameN
elementPathNameN ::= elementPathNameN
uriN ::= uriN
uri ::= uri
scopeClause ::= scopeClause
whereClauseN ::= whereClauseN
whereClause ::= whereClause
whereEntry ::= whereEntry
localWhereCondition ::= localWhereCondition
negativeWhereCondition ::= negativeWhereCondition
operationPart ::= operationPart
literal ::= literal
navigationStep ::= navigationStep
joinPart ::= joinPart
comparisonPostElementEquals ::= comparisonPostElementEquals
comparisonPostElementOtherOperation ::= comparisonPostElementOtherOperation
query ::= 
identifierM ::= 
identifierN ::= 
sPathName ::= 
pathName ::= 
identifierWithOptContainerPrefix ::= 
typePathName ::= 
whereClauseM ::= 
scopeClauseOpt ::= 
typeClauseQName ::= 
withoutsubtypesOpt ::= 
typeSetClauseOpt ::= 
typePathNameM ::= 
elementPathNameM ::= 
uriM ::= 
notOpt ::= 
localWhereEntry ::= 
joinWhereEntry ::= 
operationCondition ::= 
nonLinkPredicate ::= 
comparisonPostFix ::= 

 IBM LALR Parser Generator              1.00 (Oct  8 2008)


Scopes:

operationCondition ::= LPAREN localWhereCondition  .RPAREN 


C:\MOIN\japro\EMF_dev\emf\emf.core\dev\src\_com.sap.tc.emf.query\ecp\api\com\sap\tc\emf\query\internal\moinql\parser\grammar\MqlParser.g is LALR(1).


Number of Terminals: 43
Number of Nonterminals: 46
Number of Productions: 95
Number of Items: 257
Number of Scopes: 2
Number of States: 75
Number of Shift actions: 59
Number of Goto actions: 45
Number of Shift/Reduce actions: 132
Number of Goto/Reduce actions: 62
Number of Reduce actions: 30
Number of Shift-Reduce conflicts: 0
Number of Reduce-Reduce conflicts: 0


 IBM LALR Parser Generator              1.00 (Oct  8 2008)

Shift STATES: 


STATE 1 ------------------------------------------------------------------------
( )

'$accept' ::= .query 

query ::= .selectClause fromClause whereClauseM 
query ::= . (11)
selectClause ::= .select selectEntryN 

select          Shift  4

query           Goto   2
selectClause    Goto   3

EOF_TOKEN       Reduce 11

Default reduction to rule  11


STATE 2 ------------------------------------------------------------------------
( 1 )

'$accept' ::= query . (0)

EOF_TOKEN    Accept


STATE 3 ------------------------------------------------------------------------
( 1 63 )

query ::= selectClause  .fromClause whereClauseM 

fromClause ::= .from fromEntryN 

from          Shift  6

fromClause    Goto   5



STATE 4 ------------------------------------------------------------------------
( 1 63 )

selectClause ::= select  .selectEntryN 

identifier ::= .IDENTIFIER 
selectEntryN ::= .selectEntry COMMA selectEntryN 
selectEntryN -> .selectEntry 
selectEntry ::= .identifier 
selectEntry ::= .identifier DOT identifier 

IDENTIFIER      Sh/Rd  5

selectEntryN    Gt/Rd  12
selectEntry     Goto   7
identifier      Goto   8



STATE 5 ------------------------------------------------------------------------
( 3 )

query ::= selectClause fromClause  .whereClauseM 

whereClauseM ::= . (45)
whereClauseM -> .whereClauseN 
whereClauseN -> .whereClause 
whereClauseN ::= .whereClause whereClauseN 
whereClause ::= .where whereEntry 

where           Shift  9

whereClauseM    Gt/Rd  10
whereClauseN    Gt/Rd  46
whereClause     Goto   10

EOF_TOKEN       Reduce 45
RPAREN          Reduce 45

Default reduction to rule  45


STATE 6 ------------------------------------------------------------------------
( 3 )

fromClause ::= from  .fromEntryN 

fromEntryN ::= .fromEntry COMMA fromEntryN 
fromEntryN -> .fromEntry 
fromEntry ::= .typeClause as identifier scopeClauseOpt 
typeClause -> .typeClauseQName 
typeClauseQName ::= .fragmentaddress withoutsubtypesOpt 
fragmentaddress ::= .FRAGMENTADDRESS 

FRAGMENTADDRESS    Sh/Rd  35

fromEntryN         Gt/Rd  17
fromEntry          Goto   11
typeClauseQName    Gt/Rd  21
fragmentaddress    Goto   12
typeClause         Goto   13



STATE 7 ------------------------------------------------------------------------
( 4 14 )

selectEntryN ::= selectEntry  .COMMA selectEntryN 
selectEntryN -> selectEntry . (14)

COMMA    Shift  14

from     Reduce 14

Default reduction to rule  14


STATE 8 ------------------------------------------------------------------------
( 4 14 )

selectEntry ::= identifier . (15)
selectEntry ::= identifier  .DOT identifier 

DOT      Shift  15

from     Reduce 15
COMMA    Reduce 15

Default reduction to rule  15


STATE 9 ------------------------------------------------------------------------
( 5 10 )

whereClause ::= where  .whereEntry 

identifier ::= .IDENTIFIER 
whereEntry -> .localWhereEntry 
whereEntry -> .joinWhereEntry 
localWhereEntry ::= .for identifier LPAREN localWhereCondition RPAREN 
joinWhereEntry ::= .identifier DOT navigationStep joinPart 
joinWhereEntry ::= .identifier EQUAL identifier 

IDENTIFIER         Sh/Rd  5
for                Shift  17

whereEntry         Gt/Rd  49
joinWhereEntry     Gt/Rd  51
localWhereEntry    Gt/Rd  50
identifier         Goto   16



STATE 10 -----------------------------------------------------------------------
( 5 10 )

whereClauseN -> whereClause . (47)
whereClauseN ::= whereClause  .whereClauseN 

whereClauseN -> .whereClause 
whereClauseN ::= .whereClause whereClauseN 
whereClause ::= .where whereEntry 

where           Shift  9

whereClauseN    Gt/Rd  48
whereClause     Goto   10

EOF_TOKEN       Reduce 47
RPAREN          Reduce 47

Default reduction to rule  47


STATE 11 -----------------------------------------------------------------------
( 6 18 )

fromEntryN ::= fromEntry  .COMMA fromEntryN 
fromEntryN -> fromEntry . (19)

COMMA        Shift  18

EOF_TOKEN    Reduce 19
where        Reduce 19
RPAREN       Reduce 19

Default reduction to rule  19


STATE 12 -----------------------------------------------------------------------
( 6 18 )

typeClauseQName ::= fragmentaddress  .withoutsubtypesOpt 

withoutsubtypesOpt ::= . (23)
withoutsubtypesOpt ::= .withoutsubtypes typeSetClauseOpt 

withoutsubtypes       Shift  19

withoutsubtypesOpt    Gt/Rd  22

as                    Reduce 23

Default reduction to rule  23


STATE 13 -----------------------------------------------------------------------
( 6 18 )

fromEntry ::= typeClause  .as identifier scopeClauseOpt 

as    Shift  20



STATE 14 -----------------------------------------------------------------------
( 7 )

selectEntryN ::= selectEntry COMMA  .selectEntryN 

identifier ::= .IDENTIFIER 
selectEntryN ::= .selectEntry COMMA selectEntryN 
selectEntryN -> .selectEntry 
selectEntry ::= .identifier 
selectEntry ::= .identifier DOT identifier 

IDENTIFIER      Sh/Rd  5

selectEntryN    Gt/Rd  13
selectEntry     Goto   7
identifier      Goto   8



STATE 15 -----------------------------------------------------------------------
( 8 )

selectEntry ::= identifier DOT  .identifier 

identifier ::= .IDENTIFIER 

IDENTIFIER    Sh/Rd  5

identifier    Gt/Rd  16



STATE 16 -----------------------------------------------------------------------
( 9 )

joinWhereEntry ::= identifier  .DOT navigationStep joinPart 
joinWhereEntry ::= identifier  .EQUAL identifier 

EQUAL    Shift  21
DOT      Shift  22



STATE 17 -----------------------------------------------------------------------
( 9 )

localWhereEntry ::= for  .identifier LPAREN localWhereCondition RPAREN 

identifier ::= .IDENTIFIER 

IDENTIFIER    Sh/Rd  5

identifier    Goto   23



STATE 18 -----------------------------------------------------------------------
( 11 )

fromEntryN ::= fromEntry COMMA  .fromEntryN 

fromEntryN ::= .fromEntry COMMA fromEntryN 
fromEntryN -> .fromEntry 
fromEntry ::= .typeClause as identifier scopeClauseOpt 
typeClause -> .typeClauseQName 
typeClauseQName ::= .fragmentaddress withoutsubtypesOpt 
fragmentaddress ::= .FRAGMENTADDRESS 

FRAGMENTADDRESS    Sh/Rd  35

fromEntryN         Gt/Rd  18
fromEntry          Goto   11
typeClauseQName    Gt/Rd  21
fragmentaddress    Goto   12
typeClause         Goto   13



STATE 19 -----------------------------------------------------------------------
( 12 )

withoutsubtypesOpt ::= withoutsubtypes  .typeSetClauseOpt 

typeSetClauseOpt ::= . (25)
typeSetClauseOpt ::= .LBRACE typePathNameN RBRACE 

LBRACE              Shift  24

typeSetClauseOpt    Gt/Rd  24

as                  Reduce 25

Default reduction to rule  25


STATE 20 -----------------------------------------------------------------------
( 13 )

fromEntry ::= typeClause as  .identifier scopeClauseOpt 

identifier ::= .IDENTIFIER 

IDENTIFIER    Sh/Rd  5

identifier    Goto   25



STATE 21 -----------------------------------------------------------------------
( 16 )

joinWhereEntry ::= identifier EQUAL  .identifier 

identifier ::= .IDENTIFIER 

IDENTIFIER    Sh/Rd  5

identifier    Gt/Rd  75



STATE 22 -----------------------------------------------------------------------
( 16 )

joinWhereEntry ::= identifier DOT  .navigationStep joinPart 

identifier ::= .IDENTIFIER 
navigationStep ::= .identifier 

IDENTIFIER        Sh/Rd  5

navigationStep    Goto   26
identifier        Gt/Rd  76



STATE 23 -----------------------------------------------------------------------
( 17 )

localWhereEntry ::= for identifier  .LPAREN localWhereCondition RPAREN 

LPAREN    Shift  27



STATE 24 -----------------------------------------------------------------------
( 19 )

typeSetClauseOpt ::= LBRACE  .typePathNameN RBRACE 

typePathNameN -> .fragmentaddress 
typePathNameN ::= .fragmentaddress COMMA typePathNameN 
fragmentaddress ::= .FRAGMENTADDRESS 

FRAGMENTADDRESS    Sh/Rd  35

typePathNameN      Goto   28
fragmentaddress    Goto   29



STATE 25 -----------------------------------------------------------------------
( 20 )

fromEntry ::= typeClause as identifier  .scopeClauseOpt 

scopeClauseOpt ::= . (41)
scopeClauseOpt ::= .notOpt in scopeClause 
notOpt ::= . (93)
notOpt ::= .not 

not               Sh/Rd  94

scopeClauseOpt    Gt/Rd  20
notOpt            Goto   30

in                Reduce 93
EOF_TOKEN         Reduce 41
where             Reduce 41
COMMA             Reduce 41
RPAREN            Reduce 41

Default reduction to rule  41


STATE 26 -----------------------------------------------------------------------
( 22 )

joinWhereEntry ::= identifier DOT navigationStep  .joinPart 

joinPart -> .nonLinkPredicate 
joinPart ::= .notOpt in LPAREN query RPAREN 
nonLinkPredicate ::= .EQUAL comparisonPostElementEquals 
nonLinkPredicate ::= .LESS comparisonPostElementOtherOperation 
nonLinkPredicate ::= .GREATER comparisonPostElementOtherOperation 
nonLinkPredicate ::= .LESS_EQUAL comparisonPostElementOtherOperation 
nonLinkPredicate ::= .GREATER_EQUAL comparisonPostElementOtherOperation 
nonLinkPredicate ::= .NOT_EQUAL comparisonPostElementOtherOperation 
nonLinkPredicate ::= .like literal 
nonLinkPredicate ::= .not like literal 
notOpt ::= . (93)
notOpt ::= .not 

not                 Shift  32
like                Shift  33
NOT_EQUAL           Shift  34
GREATER_EQUAL       Shift  35
LESS_EQUAL          Shift  36
GREATER             Shift  37
LESS                Shift  38
EQUAL               Shift  39

joinPart            Gt/Rd  74
notOpt              Goto   31
nonLinkPredicate    Gt/Rd  77

in                  Reduce 93

Default reduction to rule  93


STATE 27 -----------------------------------------------------------------------
( 23 )

localWhereEntry ::= for identifier LPAREN  .localWhereCondition RPAREN 

identifier ::= .IDENTIFIER 
localWhereCondition -> .negativeWhereCondition 
localWhereCondition ::= .localWhereCondition and negativeWhereCondition 
localWhereCondition ::= .localWhereCondition or negativeWhereCondition 
negativeWhereCondition ::= .not negativeWhereCondition 
negativeWhereCondition -> .operationCondition 
operationCondition ::= .identifier operationPart 
operationCondition ::= .LPAREN localWhereCondition RPAREN 

LPAREN                    Shift  41
IDENTIFIER                Sh/Rd  5
not                       Shift  43

localWhereCondition       Goto   40
negativeWhereCondition    Gt/Rd  53
identifier                Goto   42
operationCondition        Gt/Rd  57



STATE 28 -----------------------------------------------------------------------
( 24 )

typeSetClauseOpt ::= LBRACE typePathNameN  .RBRACE 

RBRACE    Sh/Rd  26



STATE 29 -----------------------------------------------------------------------
( 24 44 )

typePathNameN -> fragmentaddress . (29)
typePathNameN ::= fragmentaddress  .COMMA typePathNameN 

COMMA     Shift  44

RBRACE    Reduce 29

Default reduction to rule  29


STATE 30 -----------------------------------------------------------------------
( 25 )

scopeClauseOpt ::= notOpt  .in scopeClause 

in    Shift  45



STATE 31 -----------------------------------------------------------------------
( 26 )

joinPart ::= notOpt  .in LPAREN query RPAREN 

in    Shift  46



STATE 32 -----------------------------------------------------------------------
( 26 )

nonLinkPredicate ::= not  .like literal 
notOpt ::= not . (94)

like    Shift  47

in      Reduce 94

Default reduction to rule  94


STATE 33 -----------------------------------------------------------------------
( 26 )

nonLinkPredicate ::= like  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  85



STATE 34 -----------------------------------------------------------------------
( 26 )

nonLinkPredicate ::= NOT_EQUAL  .comparisonPostElementOtherOperation 

identifier ::= .IDENTIFIER 
literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 
comparisonPostElementOtherOperation ::= .literal 
comparisonPostElementOtherOperation ::= .identifier DOT identifier 

IDENTIFIER                             Sh/Rd  5
null                                   Sh/Rd  73
false                                  Sh/Rd  72
true                                   Sh/Rd  71
STRING_LITERAL                         Sh/Rd  70
REAL_LITERAL                           Sh/Rd  69
INTEGER_LITERAL                        Sh/Rd  68

comparisonPostElementOtherOperation    Gt/Rd  84
identifier                             Goto   48
literal                                Gt/Rd  89



STATE 35 -----------------------------------------------------------------------
( 26 )

nonLinkPredicate ::= GREATER_EQUAL  .comparisonPostElementOtherOperation 

identifier ::= .IDENTIFIER 
literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 
comparisonPostElementOtherOperation ::= .literal 
comparisonPostElementOtherOperation ::= .identifier DOT identifier 

IDENTIFIER                             Sh/Rd  5
null                                   Sh/Rd  73
false                                  Sh/Rd  72
true                                   Sh/Rd  71
STRING_LITERAL                         Sh/Rd  70
REAL_LITERAL                           Sh/Rd  69
INTEGER_LITERAL                        Sh/Rd  68

comparisonPostElementOtherOperation    Gt/Rd  83
identifier                             Goto   48
literal                                Gt/Rd  89



STATE 36 -----------------------------------------------------------------------
( 26 )

nonLinkPredicate ::= LESS_EQUAL  .comparisonPostElementOtherOperation 

identifier ::= .IDENTIFIER 
literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 
comparisonPostElementOtherOperation ::= .literal 
comparisonPostElementOtherOperation ::= .identifier DOT identifier 

IDENTIFIER                             Sh/Rd  5
null                                   Sh/Rd  73
false                                  Sh/Rd  72
true                                   Sh/Rd  71
STRING_LITERAL                         Sh/Rd  70
REAL_LITERAL                           Sh/Rd  69
INTEGER_LITERAL                        Sh/Rd  68

comparisonPostElementOtherOperation    Gt/Rd  82
identifier                             Goto   48
literal                                Gt/Rd  89



STATE 37 -----------------------------------------------------------------------
( 26 )

nonLinkPredicate ::= GREATER  .comparisonPostElementOtherOperation 

identifier ::= .IDENTIFIER 
literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 
comparisonPostElementOtherOperation ::= .literal 
comparisonPostElementOtherOperation ::= .identifier DOT identifier 

IDENTIFIER                             Sh/Rd  5
null                                   Sh/Rd  73
false                                  Sh/Rd  72
true                                   Sh/Rd  71
STRING_LITERAL                         Sh/Rd  70
REAL_LITERAL                           Sh/Rd  69
INTEGER_LITERAL                        Sh/Rd  68

comparisonPostElementOtherOperation    Gt/Rd  81
identifier                             Goto   48
literal                                Gt/Rd  89



STATE 38 -----------------------------------------------------------------------
( 26 )

nonLinkPredicate ::= LESS  .comparisonPostElementOtherOperation 

identifier ::= .IDENTIFIER 
literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 
comparisonPostElementOtherOperation ::= .literal 
comparisonPostElementOtherOperation ::= .identifier DOT identifier 

IDENTIFIER                             Sh/Rd  5
null                                   Sh/Rd  73
false                                  Sh/Rd  72
true                                   Sh/Rd  71
STRING_LITERAL                         Sh/Rd  70
REAL_LITERAL                           Sh/Rd  69
INTEGER_LITERAL                        Sh/Rd  68

comparisonPostElementOtherOperation    Gt/Rd  80
identifier                             Goto   48
literal                                Gt/Rd  89



STATE 39 -----------------------------------------------------------------------
( 26 )

nonLinkPredicate ::= EQUAL  .comparisonPostElementEquals 

identifier ::= .IDENTIFIER 
literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 
comparisonPostElementEquals ::= .literal 
comparisonPostElementEquals ::= .identifier comparisonPostFix 

IDENTIFIER                     Sh/Rd  5
null                           Sh/Rd  73
false                          Sh/Rd  72
true                           Sh/Rd  71
STRING_LITERAL                 Sh/Rd  70
REAL_LITERAL                   Sh/Rd  69
INTEGER_LITERAL                Sh/Rd  68

comparisonPostElementEquals    Gt/Rd  79
identifier                     Goto   49
literal                        Gt/Rd  87



STATE 40 -----------------------------------------------------------------------
( 27 )

localWhereEntry ::= for identifier LPAREN localWhereCondition  .RPAREN 
localWhereCondition ::= localWhereCondition  .and negativeWhereCondition 
localWhereCondition ::= localWhereCondition  .or negativeWhereCondition 

or        Shift  50
and       Shift  51
RPAREN    Sh/Rd  52



STATE 41 -----------------------------------------------------------------------
( 27 41 43 50 51 )

operationCondition ::= LPAREN  .localWhereCondition RPAREN 

identifier ::= .IDENTIFIER 
localWhereCondition -> .negativeWhereCondition 
localWhereCondition ::= .localWhereCondition and negativeWhereCondition 
localWhereCondition ::= .localWhereCondition or negativeWhereCondition 
negativeWhereCondition ::= .not negativeWhereCondition 
negativeWhereCondition -> .operationCondition 
operationCondition ::= .identifier operationPart 
operationCondition ::= .LPAREN localWhereCondition RPAREN 

LPAREN                    Shift  41
IDENTIFIER                Sh/Rd  5
not                       Shift  43

localWhereCondition       Goto   52
negativeWhereCondition    Gt/Rd  53
identifier                Goto   42
operationCondition        Gt/Rd  57



STATE 42 -----------------------------------------------------------------------
( 27 41 43 50 51 )

operationCondition ::= identifier  .operationPart 

operationPart ::= .LESS literal 
operationPart ::= .GREATER literal 
operationPart ::= .LESS_EQUAL literal 
operationPart ::= .GREATER_EQUAL literal 
operationPart ::= .EQUAL literal 
operationPart ::= .NOT_EQUAL literal 
operationPart ::= .like literal 
operationPart ::= .not like literal 

not              Shift  53
like             Shift  54
NOT_EQUAL        Shift  55
EQUAL            Shift  56
GREATER_EQUAL    Shift  57
LESS_EQUAL       Shift  58
GREATER          Shift  59
LESS             Shift  60

operationPart    Gt/Rd  58



STATE 43 -----------------------------------------------------------------------
( 27 41 43 50 51 )

negativeWhereCondition ::= not  .negativeWhereCondition 

identifier ::= .IDENTIFIER 
negativeWhereCondition ::= .not negativeWhereCondition 
negativeWhereCondition -> .operationCondition 
operationCondition ::= .identifier operationPart 
operationCondition ::= .LPAREN localWhereCondition RPAREN 

LPAREN                    Shift  41
IDENTIFIER                Sh/Rd  5
not                       Shift  43

negativeWhereCondition    Gt/Rd  56
operationCondition        Gt/Rd  57
identifier                Goto   42



STATE 44 -----------------------------------------------------------------------
( 29 )

typePathNameN ::= fragmentaddress COMMA  .typePathNameN 

typePathNameN -> .fragmentaddress 
typePathNameN ::= .fragmentaddress COMMA typePathNameN 
fragmentaddress ::= .FRAGMENTADDRESS 

FRAGMENTADDRESS    Sh/Rd  35

typePathNameN      Gt/Rd  30
fragmentaddress    Goto   29



STATE 45 -----------------------------------------------------------------------
( 30 )

scopeClauseOpt ::= notOpt in  .scopeClause 

scopeClause ::= .resources LBRACE uriM RBRACE 
scopeClause ::= .elements LBRACE elementPathNameM RBRACE 

elements       Shift  61
resources      Shift  62

scopeClause    Gt/Rd  42



STATE 46 -----------------------------------------------------------------------
( 31 )

joinPart ::= notOpt in  .LPAREN query RPAREN 

LPAREN    Shift  63



STATE 47 -----------------------------------------------------------------------
( 32 )

nonLinkPredicate ::= not like  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  86



STATE 48 -----------------------------------------------------------------------
( 34 35 36 37 38 )

comparisonPostElementOtherOperation ::= identifier  .DOT identifier 

DOT    Shift  64



STATE 49 -----------------------------------------------------------------------
( 39 )

comparisonPostElementEquals ::= identifier  .comparisonPostFix 

comparisonPostFix ::= . (91)
comparisonPostFix ::= .DOT identifier 

DOT                  Shift  65

comparisonPostFix    Gt/Rd  88

EOF_TOKEN            Reduce 91
where                Reduce 91
RPAREN               Reduce 91

Default reduction to rule  91


STATE 50 -----------------------------------------------------------------------
( 40 52 )

localWhereCondition ::= localWhereCondition or  .negativeWhereCondition 

identifier ::= .IDENTIFIER 
negativeWhereCondition ::= .not negativeWhereCondition 
negativeWhereCondition -> .operationCondition 
operationCondition ::= .identifier operationPart 
operationCondition ::= .LPAREN localWhereCondition RPAREN 

LPAREN                    Shift  41
IDENTIFIER                Sh/Rd  5
not                       Shift  43

negativeWhereCondition    Gt/Rd  55
operationCondition        Gt/Rd  57
identifier                Goto   42



STATE 51 -----------------------------------------------------------------------
( 40 52 )

localWhereCondition ::= localWhereCondition and  .negativeWhereCondition 

identifier ::= .IDENTIFIER 
negativeWhereCondition ::= .not negativeWhereCondition 
negativeWhereCondition -> .operationCondition 
operationCondition ::= .identifier operationPart 
operationCondition ::= .LPAREN localWhereCondition RPAREN 

LPAREN                    Shift  41
IDENTIFIER                Sh/Rd  5
not                       Shift  43

negativeWhereCondition    Gt/Rd  54
operationCondition        Gt/Rd  57
identifier                Goto   42



STATE 52 -----------------------------------------------------------------------
( 41 )

localWhereCondition ::= localWhereCondition  .and negativeWhereCondition 
localWhereCondition ::= localWhereCondition  .or negativeWhereCondition 
operationCondition ::= LPAREN localWhereCondition  .RPAREN 

RPAREN    Sh/Rd  59
or        Shift  50
and       Shift  51



STATE 53 -----------------------------------------------------------------------
( 42 )

operationPart ::= not  .like literal 

like    Shift  66



STATE 54 -----------------------------------------------------------------------
( 42 )

operationPart ::= like  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  66



STATE 55 -----------------------------------------------------------------------
( 42 )

operationPart ::= NOT_EQUAL  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  65



STATE 56 -----------------------------------------------------------------------
( 42 )

operationPart ::= EQUAL  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  64



STATE 57 -----------------------------------------------------------------------
( 42 )

operationPart ::= GREATER_EQUAL  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  63



STATE 58 -----------------------------------------------------------------------
( 42 )

operationPart ::= LESS_EQUAL  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  62



STATE 59 -----------------------------------------------------------------------
( 42 )

operationPart ::= GREATER  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  61



STATE 60 -----------------------------------------------------------------------
( 42 )

operationPart ::= LESS  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  60



STATE 61 -----------------------------------------------------------------------
( 45 )

scopeClause ::= elements  .LBRACE elementPathNameM RBRACE 

LBRACE    Shift  67



STATE 62 -----------------------------------------------------------------------
( 45 )

scopeClause ::= resources  .LBRACE uriM RBRACE 

LBRACE    Shift  68



STATE 63 -----------------------------------------------------------------------
( 46 )

joinPart ::= notOpt in LPAREN  .query RPAREN 

query ::= .selectClause fromClause whereClauseM 
query ::= . (11)
selectClause ::= .select selectEntryN 

select          Shift  4

query           Goto   69
selectClause    Goto   3

RPAREN          Reduce 11

Default reduction to rule  11


STATE 64 -----------------------------------------------------------------------
( 48 )

comparisonPostElementOtherOperation ::= identifier DOT  .identifier 

identifier ::= .IDENTIFIER 

IDENTIFIER    Sh/Rd  5

identifier    Gt/Rd  90



STATE 65 -----------------------------------------------------------------------
( 49 )

comparisonPostFix ::= DOT  .identifier 

identifier ::= .IDENTIFIER 

IDENTIFIER    Sh/Rd  5

identifier    Gt/Rd  92



STATE 66 -----------------------------------------------------------------------
( 53 )

operationPart ::= not like  .literal 

literal ::= .INTEGER_LITERAL 
literal ::= .REAL_LITERAL 
literal ::= .STRING_LITERAL 
literal ::= .true 
literal ::= .false 
literal ::= .null 

null               Sh/Rd  73
false              Sh/Rd  72
true               Sh/Rd  71
STRING_LITERAL     Sh/Rd  70
REAL_LITERAL       Sh/Rd  69
INTEGER_LITERAL    Sh/Rd  68

literal            Gt/Rd  67



STATE 67 -----------------------------------------------------------------------
( 61 )

scopeClause ::= elements LBRACE  .elementPathNameM RBRACE 

elementPathNameM ::= . (31)
elementPathNameM -> .elementPathNameN 
elementPathNameN -> .fragmentaddress 
elementPathNameN ::= .fragmentaddress COMMA elementPathNameN 
fragmentaddress ::= .FRAGMENTADDRESS 

FRAGMENTADDRESS     Sh/Rd  35

elementPathNameM    Goto   70
elementPathNameN    Gt/Rd  32
fragmentaddress     Goto   71

RBRACE              Reduce 31

Default reduction to rule  31


STATE 68 -----------------------------------------------------------------------
( 62 )

scopeClause ::= resources LBRACE  .uriM RBRACE 

uriM ::= . (36)
uriM -> .uriN 
uriN -> .uri 
uriN ::= .uri COMMA uriN 
uri ::= .URI 

URI       Sh/Rd  40

uriM      Goto   72
uriN      Gt/Rd  37
uri       Goto   73

RBRACE    Reduce 36

Default reduction to rule  36


STATE 69 -----------------------------------------------------------------------
( 63 )

joinPart ::= notOpt in LPAREN query  .RPAREN 

RPAREN    Sh/Rd  78



STATE 70 -----------------------------------------------------------------------
( 67 )

scopeClause ::= elements LBRACE elementPathNameM  .RBRACE 

RBRACE    Sh/Rd  44



STATE 71 -----------------------------------------------------------------------
( 67 74 )

elementPathNameN -> fragmentaddress . (33)
elementPathNameN ::= fragmentaddress  .COMMA elementPathNameN 

COMMA     Shift  74

RBRACE    Reduce 33

Default reduction to rule  33


STATE 72 -----------------------------------------------------------------------
( 68 )

scopeClause ::= resources LBRACE uriM  .RBRACE 

RBRACE    Sh/Rd  43



STATE 73 -----------------------------------------------------------------------
( 68 75 )

uriN -> uri . (38)
uriN ::= uri  .COMMA uriN 

COMMA     Shift  75

RBRACE    Reduce 38

Default reduction to rule  38


STATE 74 -----------------------------------------------------------------------
( 71 )

elementPathNameN ::= fragmentaddress COMMA  .elementPathNameN 

elementPathNameN -> .fragmentaddress 
elementPathNameN ::= .fragmentaddress COMMA elementPathNameN 
fragmentaddress ::= .FRAGMENTADDRESS 

FRAGMENTADDRESS     Sh/Rd  35

elementPathNameN    Gt/Rd  34
fragmentaddress     Goto   71



STATE 75 -----------------------------------------------------------------------
( 73 )

uriN ::= uri COMMA  .uriN 

uriN -> .uri 
uriN ::= .uri COMMA uriN 
uri ::= .URI 

URI     Sh/Rd  40

uriN    Gt/Rd  39
uri     Goto   73


Number of entries in base Action Table: 182
Additional space required for compaction of Action Table: 0.5%

Number of unique terminal states: 44
Number of Shift actions saved by merging: 114
Number of Conflict points saved by merging: 0
Number of Reduce actions saved by merging: 0
Number of Reduce saved by default: 28

Number of entries in Terminal Action Table: 123
Additional space required for compaction of Terminal Table: 17.0%


 IBM LALR Parser Generator              1.00 (Oct  8 2008)


Mapping of new state numbers into original numbers:

   95  ==>>      6
   96  ==>>      9
   99  ==>>     18
  100  ==>>     27
  103  ==>>      2
  114  ==>>     41
  116  ==>>      4
  120  ==>>      5
  121  ==>>     19
  123  ==>>     14
  130  ==>>     26
  131  ==>>      7
  134  ==>>     15
  137  ==>>     34
  142  ==>>      3
  145  ==>>     35
  150  ==>>      8
  152  ==>>     36
  155  ==>>     37
  159  ==>>     22
  162  ==>>     38
  169  ==>>     39
  172  ==>>     43
  174  ==>>     50
  180  ==>>     51
  182  ==>>      1
  183  ==>>     67
  187  ==>>     68
  188  ==>>     10
  191  ==>>     17
  193  ==>>     25
  195  ==>>     24
  196  ==>>     12
  197  ==>>     42
  200  ==>>     44
  201  ==>>     20
  206  ==>>     63
  217  ==>>     74
  219  ==>>     75
  221  ==>>     45
  223  ==>>     21
  225  ==>>     33
  226  ==>>     47
  229  ==>>     49
  230  ==>>     54
  234  ==>>     64
  238  ==>>     55
  239  ==>>     56
  242  ==>>     57
  243  ==>>     58
  246  ==>>     59
  247  ==>>     60
  250  ==>>     11
  252  ==>>     65
  254  ==>>     66
  255  ==>>     13
  257  ==>>     16
  258  ==>>     23
  259  ==>>     28
  260  ==>>     29
  261  ==>>     30
  262  ==>>     31
  263  ==>>     32
  264  ==>>     40
  265  ==>>     46
  266  ==>>     48
  267  ==>>     52
  269  ==>>     53
  270  ==>>     61
  271  ==>>     62
  272  ==>>     69
  273  ==>>     70
  274  ==>>     71
  275  ==>>     72
  276  ==>>     73

Actions in Compressed Tables:
     Number of Shifts: 50
     Number of Shift/Reduces: 27
     Number of Gotos: 45
     Number of Goto/Reduces: 62
     Number of Reduces: 2
     Number of Defaults: 17

Parsing Tables storage:
    Storage required for BASE_CHECK: 278 Bytes
    Storage required for BASE_ACTION: 558 Bytes
    Storage required for TERM_CHECK: 161 Bytes
    Storage required for TERM_ACTION: 290 Bytes

Error maps storage:
    Storage required for ACTION_SYMBOLS_BASE map: 76 Bytes
    Storage required for ACTION_SYMBOLS_RANGE map: 78 Bytes
    Storage required for NACTION_SYMBOLS_BASE map: 76 Bytes
    Storage required for NACTION_SYMBOLS_RANGE map: 45 Bytes
    Storage required for TERMINAL_INDEX map: 44 Bytes
    Storage required for NON_TERMINAL_INDEX map: 48 Bytes

    Storage required for SCOPE_PREFIX map: 2 Bytes
    Storage required for SCOPE_SUFFIX map: 2 Bytes
    Storage required for SCOPE_LHS_SYMBOL map: 2 Bytes
    Storage required for SCOPE_LOOK_AHEAD map: 2 Bytes
    Storage required for SCOPE_STATE_SET map: 2 Bytes
    Storage required for SCOPE_RIGHT_SIDE map: 11 Bytes
    Storage required for SCOPE_STATE map: 18 Bytes
    Storage required for IN_SYMB map: 76 Bytes

    Number of names: 71
    Number of characters in name: 524
