/*
* generated by Xtext
*/
package org.eclipse.ocl.examples.xtext.oclstdlib.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.ocl.examples.xtext.oclstdlib.services.OCLstdlibGrammarAccess;

import com.google.inject.Inject;

public class OCLstdlibParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private OCLstdlibGrammarAccess grammarAccess;
	
	@Override	
	public OCLstdlibGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Library_Group(this, this, 0, inst);
			case 1: return new LibImportCS_Group(this, this, 1, inst);
			case 2: return new LibClassCS_Group(this, this, 2, inst);
			case 3: return new LibClassifierCS_LibClassCSParserRuleCall(this, this, 3, inst);
			case 4: return new LibIterationCS_Group(this, this, 4, inst);
			case 5: return new LibOperationCS_Group(this, this, 5, inst);
			case 6: return new LibPackageCS_Group(this, this, 6, inst);
			case 7: return new LibParameterCS_Group(this, this, 7, inst);
			case 8: return new LibPropertyCS_Group(this, this, 8, inst);
			case 9: return new LibQualifiedTypeRefCS_Group(this, this, 9, inst);
			case 10: return new LibTypeParameterCS_Group(this, this, 10, inst);
			case 11: return new LibTypeRefCS_Alternatives(this, this, 11, inst);
			case 12: return new LibTypedRefCS_Alternatives(this, this, 12, inst);
			case 13: return new LibTypedTypeRefCS_Group(this, this, 13, inst);
			case 14: return new LibWildcardTypeRefCS_Group(this, this, 14, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Library ****************
 *
 * Library returns LibDocumentCS:
 *   "library" name=Identifier imports+=LibImportCS* "{" packages+=LibPackageCS* "}"; 
 * //generate OCLstdlib "http://www.eclipse.org/ocl/examples/xtext/oclstdlib/OCLstdlibCST"
 *
 **/

// "library" name=Identifier imports+=LibImportCS* "{" packages+=LibPackageCS* "}"
protected class Library_Group extends GroupToken {
	
	public Library_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibraryAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Library_RightCurlyBracketKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibraryRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "library"
protected class Library_LibraryKeyword_0 extends KeywordToken  {
	
	public Library_LibraryKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibraryAccess().getLibraryKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Identifier
protected class Library_NameAssignment_1 extends AssignmentToken  {
	
	public Library_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibraryAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Library_LibraryKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibraryAccess().getNameIdentifierParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// imports+=LibImportCS*
protected class Library_ImportsAssignment_2 extends AssignmentToken  {
	
	public Library_ImportsAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibraryAccess().getImportsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibImportCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("imports",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("imports");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibImportCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibraryAccess().getImportsLibImportCSParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Library_ImportsAssignment_2(parent, next, actIndex, consumed);
			case 1: return new Library_NameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "{"
protected class Library_LeftCurlyBracketKeyword_3 extends KeywordToken  {
	
	public Library_LeftCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibraryAccess().getLeftCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Library_ImportsAssignment_2(parent, this, 0, inst);
			case 1: return new Library_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// packages+=LibPackageCS*
protected class Library_PackagesAssignment_4 extends AssignmentToken  {
	
	public Library_PackagesAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibraryAccess().getPackagesAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPackageCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("packages",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("packages");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibPackageCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibraryAccess().getPackagesLibPackageCSParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Library_PackagesAssignment_4(parent, next, actIndex, consumed);
			case 1: return new Library_LeftCurlyBracketKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Library_RightCurlyBracketKeyword_5 extends KeywordToken  {
	
	public Library_RightCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibraryAccess().getRightCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Library_PackagesAssignment_4(parent, this, 0, inst);
			case 1: return new Library_LeftCurlyBracketKeyword_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Library ****************/






/************ begin Rule LibImportCS ****************
 *
 * LibImportCS returns base::ImportCS:
 *   "import" (name=Identifier ":")? namespace=[base::NamespaceCS|SINGLE_QUOTED_STRING];
 *
 **/

// "import" (name=Identifier ":")? namespace=[base::NamespaceCS|SINGLE_QUOTED_STRING]
protected class LibImportCS_Group extends GroupToken {
	
	public LibImportCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibImportCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibImportCS_NamespaceAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibImportCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "import"
protected class LibImportCS_ImportKeyword_0 extends KeywordToken  {
	
	public LibImportCS_ImportKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibImportCSAccess().getImportKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// (name=Identifier ":")?
protected class LibImportCS_Group_1 extends GroupToken {
	
	public LibImportCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibImportCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibImportCS_ColonKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=Identifier
protected class LibImportCS_NameAssignment_1_0 extends AssignmentToken  {
	
	public LibImportCS_NameAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibImportCSAccess().getNameAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibImportCS_ImportKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibImportCSAccess().getNameIdentifierParserRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// ":"
protected class LibImportCS_ColonKeyword_1_1 extends KeywordToken  {
	
	public LibImportCS_ColonKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibImportCSAccess().getColonKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibImportCS_NameAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// namespace=[base::NamespaceCS|SINGLE_QUOTED_STRING]
protected class LibImportCS_NamespaceAssignment_2 extends AssignmentToken  {
	
	public LibImportCS_NamespaceAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibImportCSAccess().getNamespaceAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibImportCS_Group_1(parent, this, 0, inst);
			case 1: return new LibImportCS_ImportKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("namespace",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("namespace");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibImportCSAccess().getNamespaceNamespaceCSCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getLibImportCSAccess().getNamespaceNamespaceCSCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule LibImportCS ****************/


/************ begin Rule LibClassCS ****************
 *
 * LibClassCS:
 *   "type" name=Identifier ("<" typeParameters+=LibTypeParameterCS ("," typeParameters+=
 *   LibTypeParameterCS)* ">")? ("conformsTo" conformsTo+=LibTypedRefCS ("," conformsTo+=
 *   LibTypedRefCS)*)? "{" (iterations+=LibIterationCS|operations+=LibOperationCS|
 *   structuralFeatures+=LibPropertyCS)* "}";
 *
 **/

// "type" name=Identifier ("<" typeParameters+=LibTypeParameterCS ("," typeParameters+=
// LibTypeParameterCS)* ">")? ("conformsTo" conformsTo+=LibTypedRefCS ("," conformsTo+=
// LibTypedRefCS)*)? "{" (iterations+=LibIterationCS|operations+=LibOperationCS|
// structuralFeatures+=LibPropertyCS)* "}"
protected class LibClassCS_Group extends GroupToken {
	
	public LibClassCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_RightCurlyBracketKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibClassCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "type"
protected class LibClassCS_TypeKeyword_0 extends KeywordToken  {
	
	public LibClassCS_TypeKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getTypeKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Identifier
protected class LibClassCS_NameAssignment_1 extends AssignmentToken  {
	
	public LibClassCS_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_TypeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibClassCSAccess().getNameIdentifierParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("<" typeParameters+=LibTypeParameterCS ("," typeParameters+=LibTypeParameterCS)*
// ">")?
protected class LibClassCS_Group_2 extends GroupToken {
	
	public LibClassCS_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_GreaterThanSignKeyword_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class LibClassCS_LessThanSignKeyword_2_0 extends KeywordToken  {
	
	public LibClassCS_LessThanSignKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getLessThanSignKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeParameters+=LibTypeParameterCS
protected class LibClassCS_TypeParametersAssignment_2_1 extends AssignmentToken  {
	
	public LibClassCS_TypeParametersAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getTypeParametersAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypeParameterCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibClassCSAccess().getTypeParametersLibTypeParameterCSParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibClassCS_LessThanSignKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," typeParameters+=LibTypeParameterCS)*
protected class LibClassCS_Group_2_2 extends GroupToken {
	
	public LibClassCS_Group_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getGroup_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_TypeParametersAssignment_2_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LibClassCS_CommaKeyword_2_2_0 extends KeywordToken  {
	
	public LibClassCS_CommaKeyword_2_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getCommaKeyword_2_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_Group_2_2(parent, this, 0, inst);
			case 1: return new LibClassCS_TypeParametersAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// typeParameters+=LibTypeParameterCS
protected class LibClassCS_TypeParametersAssignment_2_2_1 extends AssignmentToken  {
	
	public LibClassCS_TypeParametersAssignment_2_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getTypeParametersAssignment_2_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParameters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypeParameterCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibClassCSAccess().getTypeParametersLibTypeParameterCSParserRuleCall_2_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibClassCS_CommaKeyword_2_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ">"
protected class LibClassCS_GreaterThanSignKeyword_2_3 extends KeywordToken  {
	
	public LibClassCS_GreaterThanSignKeyword_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getGreaterThanSignKeyword_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_Group_2_2(parent, this, 0, inst);
			case 1: return new LibClassCS_TypeParametersAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// ("conformsTo" conformsTo+=LibTypedRefCS ("," conformsTo+=LibTypedRefCS)*)?
protected class LibClassCS_Group_3 extends GroupToken {
	
	public LibClassCS_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_Group_3_2(parent, this, 0, inst);
			case 1: return new LibClassCS_ConformsToAssignment_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "conformsTo"
protected class LibClassCS_ConformsToKeyword_3_0 extends KeywordToken  {
	
	public LibClassCS_ConformsToKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getConformsToKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_Group_2(parent, this, 0, inst);
			case 1: return new LibClassCS_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// conformsTo+=LibTypedRefCS
protected class LibClassCS_ConformsToAssignment_3_1 extends AssignmentToken  {
	
	public LibClassCS_ConformsToAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getConformsToAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("conformsTo",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("conformsTo");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibClassCSAccess().getConformsToLibTypedRefCSParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibClassCS_ConformsToKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," conformsTo+=LibTypedRefCS)*
protected class LibClassCS_Group_3_2 extends GroupToken {
	
	public LibClassCS_Group_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getGroup_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_ConformsToAssignment_3_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LibClassCS_CommaKeyword_3_2_0 extends KeywordToken  {
	
	public LibClassCS_CommaKeyword_3_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getCommaKeyword_3_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_Group_3_2(parent, this, 0, inst);
			case 1: return new LibClassCS_ConformsToAssignment_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// conformsTo+=LibTypedRefCS
protected class LibClassCS_ConformsToAssignment_3_2_1 extends AssignmentToken  {
	
	public LibClassCS_ConformsToAssignment_3_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getConformsToAssignment_3_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("conformsTo",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("conformsTo");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibClassCSAccess().getConformsToLibTypedRefCSParserRuleCall_3_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibClassCS_CommaKeyword_3_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "{"
protected class LibClassCS_LeftCurlyBracketKeyword_4 extends KeywordToken  {
	
	public LibClassCS_LeftCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getLeftCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_Group_3(parent, this, 0, inst);
			case 1: return new LibClassCS_Group_2(parent, this, 1, inst);
			case 2: return new LibClassCS_NameAssignment_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// (iterations+=LibIterationCS|operations+=LibOperationCS|structuralFeatures+=
// LibPropertyCS)*
protected class LibClassCS_Alternatives_5 extends AlternativesToken {

	public LibClassCS_Alternatives_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getAlternatives_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_IterationsAssignment_5_0(parent, this, 0, inst);
			case 1: return new LibClassCS_OperationsAssignment_5_1(parent, this, 1, inst);
			case 2: return new LibClassCS_StructuralFeaturesAssignment_5_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// iterations+=LibIterationCS
protected class LibClassCS_IterationsAssignment_5_0 extends AssignmentToken  {
	
	public LibClassCS_IterationsAssignment_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getIterationsAssignment_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("iterations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("iterations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibIterationCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibClassCSAccess().getIterationsLibIterationCSParserRuleCall_5_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibClassCS_Alternatives_5(parent, next, actIndex, consumed);
			case 1: return new LibClassCS_LeftCurlyBracketKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// operations+=LibOperationCS
protected class LibClassCS_OperationsAssignment_5_1 extends AssignmentToken  {
	
	public LibClassCS_OperationsAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getOperationsAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operations",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibOperationCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibClassCSAccess().getOperationsLibOperationCSParserRuleCall_5_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibClassCS_Alternatives_5(parent, next, actIndex, consumed);
			case 1: return new LibClassCS_LeftCurlyBracketKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// structuralFeatures+=LibPropertyCS
protected class LibClassCS_StructuralFeaturesAssignment_5_2 extends AssignmentToken  {
	
	public LibClassCS_StructuralFeaturesAssignment_5_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getStructuralFeaturesAssignment_5_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPropertyCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("structuralFeatures",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("structuralFeatures");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibPropertyCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibClassCSAccess().getStructuralFeaturesLibPropertyCSParserRuleCall_5_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibClassCS_Alternatives_5(parent, next, actIndex, consumed);
			case 1: return new LibClassCS_LeftCurlyBracketKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class LibClassCS_RightCurlyBracketKeyword_6 extends KeywordToken  {
	
	public LibClassCS_RightCurlyBracketKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibClassCSAccess().getRightCurlyBracketKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_Alternatives_5(parent, this, 0, inst);
			case 1: return new LibClassCS_LeftCurlyBracketKeyword_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule LibClassCS ****************/


/************ begin Rule LibClassifierCS ****************
 *
 * LibClassifierCS returns base::ClassifierCS:
 *   LibClassCS;
 *
 **/

// LibClassCS
protected class LibClassifierCS_LibClassCSParserRuleCall extends RuleCallToken {
	
	public LibClassifierCS_LibClassCSParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLibClassifierCSAccess().getLibClassCSParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibClassifierCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LibClassCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLibClassCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule LibClassifierCS ****************/


/************ begin Rule LibIterationCS ****************
 *
 * LibIterationCS:
 *   "iteration" name=Identifier "(" iterators+=Identifier ("," iterators+=Identifier)*
 *   iterators+="..."? ")" ":" type=LibTypedRefCS "=>" class=SINGLE_QUOTED_STRING ";"; 
 * 
 *     
 * 	  
 * 	           
 * 	   
 * 	  
 * //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
 *
 **/

// "iteration" name=Identifier "(" iterators+=Identifier ("," iterators+=Identifier)*
// iterators+="..."? ")" ":" type=LibTypedRefCS "=>" class=SINGLE_QUOTED_STRING ";" 
// 	  
// 	           
// 	   
// 	  
// //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
protected class LibIterationCS_Group extends GroupToken {
	
	public LibIterationCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_SemicolonKeyword_11(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibIterationCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "iteration"
protected class LibIterationCS_IterationKeyword_0 extends KeywordToken  {
	
	public LibIterationCS_IterationKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getIterationKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Identifier
protected class LibIterationCS_NameAssignment_1 extends AssignmentToken  {
	
	public LibIterationCS_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_IterationKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibIterationCSAccess().getNameIdentifierParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class LibIterationCS_LeftParenthesisKeyword_2 extends KeywordToken  {
	
	public LibIterationCS_LeftParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getLeftParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// iterators+=Identifier
protected class LibIterationCS_IteratorsAssignment_3 extends AssignmentToken  {
	
	public LibIterationCS_IteratorsAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getIteratorsAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_LeftParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("iterators",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("iterators");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibIterationCSAccess().getIteratorsIdentifierParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// ("," iterators+=Identifier)*
protected class LibIterationCS_Group_4 extends GroupToken {
	
	public LibIterationCS_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_IteratorsAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LibIterationCS_CommaKeyword_4_0 extends KeywordToken  {
	
	public LibIterationCS_CommaKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getCommaKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_Group_4(parent, this, 0, inst);
			case 1: return new LibIterationCS_IteratorsAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// iterators+=Identifier
protected class LibIterationCS_IteratorsAssignment_4_1 extends AssignmentToken  {
	
	public LibIterationCS_IteratorsAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getIteratorsAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_CommaKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("iterators",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("iterators");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibIterationCSAccess().getIteratorsIdentifierParserRuleCall_4_1_0();
			return obj;
		}
		return null;
	}

}


// iterators+="..."?
protected class LibIterationCS_IteratorsAssignment_5 extends AssignmentToken  {
	
	public LibIterationCS_IteratorsAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getIteratorsAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_Group_4(parent, this, 0, inst);
			case 1: return new LibIterationCS_IteratorsAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("iterators",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("iterators");
		if("...".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getLibIterationCSAccess().getIteratorsFullStopFullStopFullStopKeyword_5_0();
			return obj;
		}
		return null;
	}

}

// ")"
protected class LibIterationCS_RightParenthesisKeyword_6 extends KeywordToken  {
	
	public LibIterationCS_RightParenthesisKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getRightParenthesisKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_IteratorsAssignment_5(parent, this, 0, inst);
			case 1: return new LibIterationCS_Group_4(parent, this, 1, inst);
			case 2: return new LibIterationCS_IteratorsAssignment_3(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class LibIterationCS_ColonKeyword_7 extends KeywordToken  {
	
	public LibIterationCS_ColonKeyword_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getColonKeyword_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_RightParenthesisKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=LibTypedRefCS
protected class LibIterationCS_TypeAssignment_8 extends AssignmentToken  {
	
	public LibIterationCS_TypeAssignment_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getTypeAssignment_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibIterationCSAccess().getTypeLibTypedRefCSParserRuleCall_8_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibIterationCS_ColonKeyword_7(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "=>"
protected class LibIterationCS_EqualsSignGreaterThanSignKeyword_9 extends KeywordToken  {
	
	public LibIterationCS_EqualsSignGreaterThanSignKeyword_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getEqualsSignGreaterThanSignKeyword_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_TypeAssignment_8(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// class=SINGLE_QUOTED_STRING   
// //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
protected class LibIterationCS_ClassAssignment_10 extends AssignmentToken  {
	
	public LibIterationCS_ClassAssignment_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getClassAssignment_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_EqualsSignGreaterThanSignKeyword_9(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("class",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("class");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getLibIterationCSAccess().getClassSINGLE_QUOTED_STRINGTerminalRuleCall_10_0();
			return obj;
		}
		return null;
	}

}

// ";" 
// //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
protected class LibIterationCS_SemicolonKeyword_11 extends KeywordToken  {
	
	public LibIterationCS_SemicolonKeyword_11(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibIterationCSAccess().getSemicolonKeyword_11();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibIterationCS_ClassAssignment_10(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule LibIterationCS ****************/


/************ begin Rule LibOperationCS ****************
 *
 * LibOperationCS:
 *   isStatic?="static"? "operation" name=Identifier ("<" typeParameters+=
 *   LibTypeParameterCS ("," typeParameters+=LibTypeParameterCS)* ">")? "(" (parameters+=
 *   LibParameterCS ("," parameters+=LibParameterCS)*)? ")" ":" type=LibTypedRefCS "=>"
 *   class=SINGLE_QUOTED_STRING ";"; 
 * 
 *     
 * 	    
 * 	  
 * 	         
 * 	         
 * 	   
 * 	  
 * //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
 *
 **/

// isStatic?="static"? "operation" name=Identifier ("<" typeParameters+=
// LibTypeParameterCS ("," typeParameters+=LibTypeParameterCS)* ">")? "(" (parameters+=
// LibParameterCS ("," parameters+=LibParameterCS)*)? ")" ":" type=LibTypedRefCS "=>"
// class=SINGLE_QUOTED_STRING ";" 
// 	    
// 	  
// 	         
// 	         
// 	   
// 	  
// //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
protected class LibOperationCS_Group extends GroupToken {
	
	public LibOperationCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_SemicolonKeyword_11(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibOperationCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// isStatic?="static"?
protected class LibOperationCS_IsStaticAssignment_0 extends AssignmentToken  {
	
	public LibOperationCS_IsStaticAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getIsStaticAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("isStatic",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("isStatic");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getLibOperationCSAccess().getIsStaticStaticKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// "operation"
protected class LibOperationCS_OperationKeyword_1 extends KeywordToken  {
	
	public LibOperationCS_OperationKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getOperationKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_IsStaticAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// name=Identifier
protected class LibOperationCS_NameAssignment_2 extends AssignmentToken  {
	
	public LibOperationCS_NameAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getNameAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_OperationKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibOperationCSAccess().getNameIdentifierParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// ("<" typeParameters+=LibTypeParameterCS ("," typeParameters+=LibTypeParameterCS)*
// ">")?
protected class LibOperationCS_Group_3 extends GroupToken {
	
	public LibOperationCS_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_GreaterThanSignKeyword_3_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class LibOperationCS_LessThanSignKeyword_3_0 extends KeywordToken  {
	
	public LibOperationCS_LessThanSignKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getLessThanSignKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_NameAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeParameters+=LibTypeParameterCS
protected class LibOperationCS_TypeParametersAssignment_3_1 extends AssignmentToken  {
	
	public LibOperationCS_TypeParametersAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getTypeParametersAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypeParameterCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibOperationCSAccess().getTypeParametersLibTypeParameterCSParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibOperationCS_LessThanSignKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," typeParameters+=LibTypeParameterCS)*
protected class LibOperationCS_Group_3_2 extends GroupToken {
	
	public LibOperationCS_Group_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getGroup_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_TypeParametersAssignment_3_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LibOperationCS_CommaKeyword_3_2_0 extends KeywordToken  {
	
	public LibOperationCS_CommaKeyword_3_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getCommaKeyword_3_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_Group_3_2(parent, this, 0, inst);
			case 1: return new LibOperationCS_TypeParametersAssignment_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// typeParameters+=LibTypeParameterCS
protected class LibOperationCS_TypeParametersAssignment_3_2_1 extends AssignmentToken  {
	
	public LibOperationCS_TypeParametersAssignment_3_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getTypeParametersAssignment_3_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParameters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypeParameterCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibOperationCSAccess().getTypeParametersLibTypeParameterCSParserRuleCall_3_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibOperationCS_CommaKeyword_3_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ">"
protected class LibOperationCS_GreaterThanSignKeyword_3_3 extends KeywordToken  {
	
	public LibOperationCS_GreaterThanSignKeyword_3_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getGreaterThanSignKeyword_3_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_Group_3_2(parent, this, 0, inst);
			case 1: return new LibOperationCS_TypeParametersAssignment_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// "("
protected class LibOperationCS_LeftParenthesisKeyword_4 extends KeywordToken  {
	
	public LibOperationCS_LeftParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getLeftParenthesisKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_Group_3(parent, this, 0, inst);
			case 1: return new LibOperationCS_NameAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// (parameters+=LibParameterCS ("," parameters+=LibParameterCS)*)?
protected class LibOperationCS_Group_5 extends GroupToken {
	
	public LibOperationCS_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_Group_5_1(parent, this, 0, inst);
			case 1: return new LibOperationCS_ParametersAssignment_5_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=LibParameterCS
protected class LibOperationCS_ParametersAssignment_5_0 extends AssignmentToken  {
	
	public LibOperationCS_ParametersAssignment_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getParametersAssignment_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibParameterCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibOperationCSAccess().getParametersLibParameterCSParserRuleCall_5_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibOperationCS_LeftParenthesisKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," parameters+=LibParameterCS)*
protected class LibOperationCS_Group_5_1 extends GroupToken {
	
	public LibOperationCS_Group_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getGroup_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_ParametersAssignment_5_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LibOperationCS_CommaKeyword_5_1_0 extends KeywordToken  {
	
	public LibOperationCS_CommaKeyword_5_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getCommaKeyword_5_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_Group_5_1(parent, this, 0, inst);
			case 1: return new LibOperationCS_ParametersAssignment_5_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// parameters+=LibParameterCS
protected class LibOperationCS_ParametersAssignment_5_1_1 extends AssignmentToken  {
	
	public LibOperationCS_ParametersAssignment_5_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getParametersAssignment_5_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parameters",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parameters");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibParameterCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibOperationCSAccess().getParametersLibParameterCSParserRuleCall_5_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibOperationCS_CommaKeyword_5_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class LibOperationCS_RightParenthesisKeyword_6 extends KeywordToken  {
	
	public LibOperationCS_RightParenthesisKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getRightParenthesisKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_Group_5(parent, this, 0, inst);
			case 1: return new LibOperationCS_LeftParenthesisKeyword_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class LibOperationCS_ColonKeyword_7 extends KeywordToken  {
	
	public LibOperationCS_ColonKeyword_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getColonKeyword_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_RightParenthesisKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=LibTypedRefCS
protected class LibOperationCS_TypeAssignment_8 extends AssignmentToken  {
	
	public LibOperationCS_TypeAssignment_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getTypeAssignment_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibOperationCSAccess().getTypeLibTypedRefCSParserRuleCall_8_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibOperationCS_ColonKeyword_7(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "=>"
protected class LibOperationCS_EqualsSignGreaterThanSignKeyword_9 extends KeywordToken  {
	
	public LibOperationCS_EqualsSignGreaterThanSignKeyword_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getEqualsSignGreaterThanSignKeyword_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_TypeAssignment_8(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// class=SINGLE_QUOTED_STRING   
// //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
protected class LibOperationCS_ClassAssignment_10 extends AssignmentToken  {
	
	public LibOperationCS_ClassAssignment_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getClassAssignment_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_EqualsSignGreaterThanSignKeyword_9(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("class",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("class");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getLibOperationCSAccess().getClassSINGLE_QUOTED_STRINGTerminalRuleCall_10_0();
			return obj;
		}
		return null;
	}

}

// ";" 
// //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
protected class LibOperationCS_SemicolonKeyword_11 extends KeywordToken  {
	
	public LibOperationCS_SemicolonKeyword_11(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibOperationCSAccess().getSemicolonKeyword_11();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibOperationCS_ClassAssignment_10(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule LibOperationCS ****************/


/************ begin Rule LibPackageCS ****************
 *
 * LibPackageCS:
 *   "package" name=Identifier "{" (subpackages+=LibPackageCS|classifiers+=
 *   LibClassifierCS)* "}";
 *
 **/

// "package" name=Identifier "{" (subpackages+=LibPackageCS|classifiers+=
// LibClassifierCS)* "}"
protected class LibPackageCS_Group extends GroupToken {
	
	public LibPackageCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibPackageCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPackageCS_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibPackageCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "package"
protected class LibPackageCS_PackageKeyword_0 extends KeywordToken  {
	
	public LibPackageCS_PackageKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibPackageCSAccess().getPackageKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Identifier
protected class LibPackageCS_NameAssignment_1 extends AssignmentToken  {
	
	public LibPackageCS_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibPackageCSAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPackageCS_PackageKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibPackageCSAccess().getNameIdentifierParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class LibPackageCS_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public LibPackageCS_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibPackageCSAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPackageCS_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (subpackages+=LibPackageCS|classifiers+=LibClassifierCS)*
protected class LibPackageCS_Alternatives_3 extends AlternativesToken {

	public LibPackageCS_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLibPackageCSAccess().getAlternatives_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPackageCS_SubpackagesAssignment_3_0(parent, this, 0, inst);
			case 1: return new LibPackageCS_ClassifiersAssignment_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// subpackages+=LibPackageCS
protected class LibPackageCS_SubpackagesAssignment_3_0 extends AssignmentToken  {
	
	public LibPackageCS_SubpackagesAssignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibPackageCSAccess().getSubpackagesAssignment_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPackageCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subpackages",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subpackages");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibPackageCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibPackageCSAccess().getSubpackagesLibPackageCSParserRuleCall_3_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibPackageCS_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new LibPackageCS_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// classifiers+=LibClassifierCS
protected class LibPackageCS_ClassifiersAssignment_3_1 extends AssignmentToken  {
	
	public LibPackageCS_ClassifiersAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibPackageCSAccess().getClassifiersAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibClassifierCS_LibClassCSParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("classifiers",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("classifiers");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibClassifierCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibPackageCSAccess().getClassifiersLibClassifierCSParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibPackageCS_Alternatives_3(parent, next, actIndex, consumed);
			case 1: return new LibPackageCS_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class LibPackageCS_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public LibPackageCS_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibPackageCSAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPackageCS_Alternatives_3(parent, this, 0, inst);
			case 1: return new LibPackageCS_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule LibPackageCS ****************/


/************ begin Rule LibParameterCS ****************
 *
 * LibParameterCS returns base::ParameterCS:
 *   name=Identifier ":" type=LibTypedRefCS ("[" (lower=LOWER (".." upper=UPPER)?|
 *   multiplicity=( "*" | "+" | "?" )) "]")?;
 *
 **/

// name=Identifier ":" type=LibTypedRefCS ("[" (lower=LOWER (".." upper=UPPER)?|
// multiplicity=( "*" | "+" | "?" )) "]")?
protected class LibParameterCS_Group extends GroupToken {
	
	public LibParameterCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_Group_3(parent, this, 0, inst);
			case 1: return new LibParameterCS_TypeAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibParameterCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=Identifier
protected class LibParameterCS_NameAssignment_0 extends AssignmentToken  {
	
	public LibParameterCS_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibParameterCSAccess().getNameIdentifierParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ":"
protected class LibParameterCS_ColonKeyword_1 extends KeywordToken  {
	
	public LibParameterCS_ColonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getColonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=LibTypedRefCS
protected class LibParameterCS_TypeAssignment_2 extends AssignmentToken  {
	
	public LibParameterCS_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibParameterCSAccess().getTypeLibTypedRefCSParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibParameterCS_ColonKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("[" (lower=LOWER (".." upper=UPPER)?|multiplicity=( "*" | "+" | "?" )) "]")?
protected class LibParameterCS_Group_3 extends GroupToken {
	
	public LibParameterCS_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_RightSquareBracketKeyword_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "["
protected class LibParameterCS_LeftSquareBracketKeyword_3_0 extends KeywordToken  {
	
	public LibParameterCS_LeftSquareBracketKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getLeftSquareBracketKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_TypeAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// lower=LOWER (".." upper=UPPER)?|multiplicity=( "*" | "+" | "?" )
protected class LibParameterCS_Alternatives_3_1 extends AlternativesToken {

	public LibParameterCS_Alternatives_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getAlternatives_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_Group_3_1_0(parent, this, 0, inst);
			case 1: return new LibParameterCS_MultiplicityAssignment_3_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// lower=LOWER (".." upper=UPPER)?
protected class LibParameterCS_Group_3_1_0 extends GroupToken {
	
	public LibParameterCS_Group_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getGroup_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_Group_3_1_0_1(parent, this, 0, inst);
			case 1: return new LibParameterCS_LowerAssignment_3_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// lower=LOWER
protected class LibParameterCS_LowerAssignment_3_1_0_0 extends AssignmentToken  {
	
	public LibParameterCS_LowerAssignment_3_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getLowerAssignment_3_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_LeftSquareBracketKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("lower",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("lower");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibParameterCSAccess().getLowerLOWERParserRuleCall_3_1_0_0_0();
			return obj;
		}
		return null;
	}

}

// (".." upper=UPPER)?
protected class LibParameterCS_Group_3_1_0_1 extends GroupToken {
	
	public LibParameterCS_Group_3_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getGroup_3_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_UpperAssignment_3_1_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ".."
protected class LibParameterCS_FullStopFullStopKeyword_3_1_0_1_0 extends KeywordToken  {
	
	public LibParameterCS_FullStopFullStopKeyword_3_1_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getFullStopFullStopKeyword_3_1_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_LowerAssignment_3_1_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// upper=UPPER
protected class LibParameterCS_UpperAssignment_3_1_0_1_1 extends AssignmentToken  {
	
	public LibParameterCS_UpperAssignment_3_1_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getUpperAssignment_3_1_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_FullStopFullStopKeyword_3_1_0_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("upper",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("upper");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibParameterCSAccess().getUpperUPPERParserRuleCall_3_1_0_1_1_0();
			return obj;
		}
		return null;
	}

}



// multiplicity=( "*" | "+" | "?" )
protected class LibParameterCS_MultiplicityAssignment_3_1_1 extends AssignmentToken  {
	
	public LibParameterCS_MultiplicityAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getMultiplicityAssignment_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_LeftSquareBracketKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("multiplicity",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("multiplicity");
		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getLibParameterCSAccess().getMultiplicityAsteriskKeyword_3_1_1_0_0();
			return obj;
		}
		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getLibParameterCSAccess().getMultiplicityPlusSignKeyword_3_1_1_0_1();
			return obj;
		}
		if("?".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getLibParameterCSAccess().getMultiplicityQuestionMarkKeyword_3_1_1_0_2();
			return obj;
		}
		return null;
	}

}


// "]"
protected class LibParameterCS_RightSquareBracketKeyword_3_2 extends KeywordToken  {
	
	public LibParameterCS_RightSquareBracketKeyword_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibParameterCSAccess().getRightSquareBracketKeyword_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibParameterCS_Alternatives_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule LibParameterCS ****************/


/************ begin Rule LibPropertyCS ****************
 *
 * LibPropertyCS:
 *   isStatic?="static"? "property" name=Identifier ":" type=LibTypedRefCS "=>" class=
 *   SINGLE_QUOTED_STRING ";"; 
 * 
 *     
 * 	    
 * 	  
 * 	  
 * 	  
 * //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
 *
 **/

// isStatic?="static"? "property" name=Identifier ":" type=LibTypedRefCS "=>" class=
// SINGLE_QUOTED_STRING ";" 
// 	    
// 	  
// 	  
// 	  
// //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
protected class LibPropertyCS_Group extends GroupToken {
	
	public LibPropertyCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibPropertyCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPropertyCS_SemicolonKeyword_7(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibPropertyCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// isStatic?="static"?
protected class LibPropertyCS_IsStaticAssignment_0 extends AssignmentToken  {
	
	public LibPropertyCS_IsStaticAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibPropertyCSAccess().getIsStaticAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("isStatic",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("isStatic");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getLibPropertyCSAccess().getIsStaticStaticKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// "property"
protected class LibPropertyCS_PropertyKeyword_1 extends KeywordToken  {
	
	public LibPropertyCS_PropertyKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibPropertyCSAccess().getPropertyKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPropertyCS_IsStaticAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// name=Identifier
protected class LibPropertyCS_NameAssignment_2 extends AssignmentToken  {
	
	public LibPropertyCS_NameAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibPropertyCSAccess().getNameAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPropertyCS_PropertyKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibPropertyCSAccess().getNameIdentifierParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// ":"
protected class LibPropertyCS_ColonKeyword_3 extends KeywordToken  {
	
	public LibPropertyCS_ColonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibPropertyCSAccess().getColonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPropertyCS_NameAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=LibTypedRefCS
protected class LibPropertyCS_TypeAssignment_4 extends AssignmentToken  {
	
	public LibPropertyCS_TypeAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibPropertyCSAccess().getTypeAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibPropertyCSAccess().getTypeLibTypedRefCSParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibPropertyCS_ColonKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "=>"
protected class LibPropertyCS_EqualsSignGreaterThanSignKeyword_5 extends KeywordToken  {
	
	public LibPropertyCS_EqualsSignGreaterThanSignKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibPropertyCSAccess().getEqualsSignGreaterThanSignKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPropertyCS_TypeAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// class=SINGLE_QUOTED_STRING   
// //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
protected class LibPropertyCS_ClassAssignment_6 extends AssignmentToken  {
	
	public LibPropertyCS_ClassAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibPropertyCSAccess().getClassAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPropertyCS_EqualsSignGreaterThanSignKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("class",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("class");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getLibPropertyCSAccess().getClassSINGLE_QUOTED_STRINGTerminalRuleCall_6_0();
			return obj;
		}
		return null;
	}

}

// ";" 
// //	'=>' class=[ecore::EJavaClass|DOUBLE_QUOTED_STRING]
protected class LibPropertyCS_SemicolonKeyword_7 extends KeywordToken  {
	
	public LibPropertyCS_SemicolonKeyword_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibPropertyCSAccess().getSemicolonKeyword_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibPropertyCS_ClassAssignment_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule LibPropertyCS ****************/


/************ begin Rule LibQualifiedTypeRefCS ****************
 *
 * LibQualifiedTypeRefCS returns base::QualifiedTypeRefCS:
 *   namespace=[base::NamespaceCS|Identifier] ("<" typeArguments+=LibTypeRefCS (","
 *   typeArguments+=LibTypeRefCS)* ">")? "::" type=LibTypedRefCS;
 *
 **/

// namespace=[base::NamespaceCS|Identifier] ("<" typeArguments+=LibTypeRefCS (","
// typeArguments+=LibTypeRefCS)* ">")? "::" type=LibTypedRefCS
protected class LibQualifiedTypeRefCS_Group extends GroupToken {
	
	public LibQualifiedTypeRefCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_TypeAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibQualifiedTypeRefCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// namespace=[base::NamespaceCS|Identifier]
protected class LibQualifiedTypeRefCS_NamespaceAssignment_0 extends AssignmentToken  {
	
	public LibQualifiedTypeRefCS_NamespaceAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getNamespaceAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("namespace",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("namespace");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibQualifiedTypeRefCSAccess().getNamespaceNamespaceCSCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getLibQualifiedTypeRefCSAccess().getNamespaceNamespaceCSCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("<" typeArguments+=LibTypeRefCS ("," typeArguments+=LibTypeRefCS)* ">")?
protected class LibQualifiedTypeRefCS_Group_1 extends GroupToken {
	
	public LibQualifiedTypeRefCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_GreaterThanSignKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class LibQualifiedTypeRefCS_LessThanSignKeyword_1_0 extends KeywordToken  {
	
	public LibQualifiedTypeRefCS_LessThanSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getLessThanSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_NamespaceAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeArguments+=LibTypeRefCS
protected class LibQualifiedTypeRefCS_TypeArgumentsAssignment_1_1 extends AssignmentToken  {
	
	public LibQualifiedTypeRefCS_TypeArgumentsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getTypeArgumentsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeArguments",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeArguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypeRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibQualifiedTypeRefCSAccess().getTypeArgumentsLibTypeRefCSParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_LessThanSignKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," typeArguments+=LibTypeRefCS)*
protected class LibQualifiedTypeRefCS_Group_1_2 extends GroupToken {
	
	public LibQualifiedTypeRefCS_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_TypeArgumentsAssignment_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LibQualifiedTypeRefCS_CommaKeyword_1_2_0 extends KeywordToken  {
	
	public LibQualifiedTypeRefCS_CommaKeyword_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getCommaKeyword_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_Group_1_2(parent, this, 0, inst);
			case 1: return new LibQualifiedTypeRefCS_TypeArgumentsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// typeArguments+=LibTypeRefCS
protected class LibQualifiedTypeRefCS_TypeArgumentsAssignment_1_2_1 extends AssignmentToken  {
	
	public LibQualifiedTypeRefCS_TypeArgumentsAssignment_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getTypeArgumentsAssignment_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeArguments",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeArguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypeRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibQualifiedTypeRefCSAccess().getTypeArgumentsLibTypeRefCSParserRuleCall_1_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_CommaKeyword_1_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ">"
protected class LibQualifiedTypeRefCS_GreaterThanSignKeyword_1_3 extends KeywordToken  {
	
	public LibQualifiedTypeRefCS_GreaterThanSignKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getGreaterThanSignKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_Group_1_2(parent, this, 0, inst);
			case 1: return new LibQualifiedTypeRefCS_TypeArgumentsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// "::"
protected class LibQualifiedTypeRefCS_ColonColonKeyword_2 extends KeywordToken  {
	
	public LibQualifiedTypeRefCS_ColonColonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getColonColonKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_Group_1(parent, this, 0, inst);
			case 1: return new LibQualifiedTypeRefCS_NamespaceAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// type=LibTypedRefCS
protected class LibQualifiedTypeRefCS_TypeAssignment_3 extends AssignmentToken  {
	
	public LibQualifiedTypeRefCS_TypeAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibQualifiedTypeRefCSAccess().getTypeAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibQualifiedTypeRefCSAccess().getTypeLibTypedRefCSParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_ColonColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule LibQualifiedTypeRefCS ****************/


/************ begin Rule LibTypeParameterCS ****************
 *
 * LibTypeParameterCS returns base::TypeParameterCS:
 *   name=Identifier ("extends" extends+=LibTypedRefCS ("&&" extends+=LibTypedRefCS)*|
 *   "super" super=LibTypedRefCS)?;
 *
 **/

// name=Identifier ("extends" extends+=LibTypedRefCS ("&&" extends+=LibTypedRefCS)*|
// "super" super=LibTypedRefCS)?
protected class LibTypeParameterCS_Group extends GroupToken {
	
	public LibTypeParameterCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_Alternatives_1(parent, this, 0, inst);
			case 1: return new LibTypeParameterCS_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibTypeParameterCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=Identifier
protected class LibTypeParameterCS_NameAssignment_0 extends AssignmentToken  {
	
	public LibTypeParameterCS_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLibTypeParameterCSAccess().getNameIdentifierParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("extends" extends+=LibTypedRefCS ("&&" extends+=LibTypedRefCS)*|"super" super=
// LibTypedRefCS)?
protected class LibTypeParameterCS_Alternatives_1 extends AlternativesToken {

	public LibTypeParameterCS_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_Group_1_0(parent, this, 0, inst);
			case 1: return new LibTypeParameterCS_Group_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends" extends+=LibTypedRefCS ("&&" extends+=LibTypedRefCS)*
protected class LibTypeParameterCS_Group_1_0 extends GroupToken {
	
	public LibTypeParameterCS_Group_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_Group_1_0_2(parent, this, 0, inst);
			case 1: return new LibTypeParameterCS_ExtendsAssignment_1_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class LibTypeParameterCS_ExtendsKeyword_1_0_0 extends KeywordToken  {
	
	public LibTypeParameterCS_ExtendsKeyword_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getExtendsKeyword_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// extends+=LibTypedRefCS
protected class LibTypeParameterCS_ExtendsAssignment_1_0_1 extends AssignmentToken  {
	
	public LibTypeParameterCS_ExtendsAssignment_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getExtendsAssignment_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibTypeParameterCSAccess().getExtendsLibTypedRefCSParserRuleCall_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibTypeParameterCS_ExtendsKeyword_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("&&" extends+=LibTypedRefCS)*
protected class LibTypeParameterCS_Group_1_0_2 extends GroupToken {
	
	public LibTypeParameterCS_Group_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getGroup_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_ExtendsAssignment_1_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "&&"
protected class LibTypeParameterCS_AmpersandAmpersandKeyword_1_0_2_0 extends KeywordToken  {
	
	public LibTypeParameterCS_AmpersandAmpersandKeyword_1_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getAmpersandAmpersandKeyword_1_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_Group_1_0_2(parent, this, 0, inst);
			case 1: return new LibTypeParameterCS_ExtendsAssignment_1_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// extends+=LibTypedRefCS
protected class LibTypeParameterCS_ExtendsAssignment_1_0_2_1 extends AssignmentToken  {
	
	public LibTypeParameterCS_ExtendsAssignment_1_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getExtendsAssignment_1_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibTypeParameterCSAccess().getExtendsLibTypedRefCSParserRuleCall_1_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibTypeParameterCS_AmpersandAmpersandKeyword_1_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "super" super=LibTypedRefCS
protected class LibTypeParameterCS_Group_1_1 extends GroupToken {
	
	public LibTypeParameterCS_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_SuperAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "super"
protected class LibTypeParameterCS_SuperKeyword_1_1_0 extends KeywordToken  {
	
	public LibTypeParameterCS_SuperKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getSuperKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeParameterCS_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// super=LibTypedRefCS
protected class LibTypeParameterCS_SuperAssignment_1_1_1 extends AssignmentToken  {
	
	public LibTypeParameterCS_SuperAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibTypeParameterCSAccess().getSuperAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("super",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("super");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibTypeParameterCSAccess().getSuperLibTypedRefCSParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibTypeParameterCS_SuperKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule LibTypeParameterCS ****************/


/************ begin Rule LibTypeRefCS ****************
 *
 * LibTypeRefCS returns base::TypeRefCS:
 *   LibTypedRefCS|LibWildcardTypeRefCS;
 *
 **/

// LibTypedRefCS|LibWildcardTypeRefCS
protected class LibTypeRefCS_Alternatives extends AlternativesToken {

	public LibTypeRefCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLibTypeRefCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeRefCS_LibTypedRefCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new LibTypeRefCS_LibWildcardTypeRefCSParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibTypeRefCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// LibTypedRefCS
protected class LibTypeRefCS_LibTypedRefCSParserRuleCall_0 extends RuleCallToken {
	
	public LibTypeRefCS_LibTypedRefCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLibTypeRefCSAccess().getLibTypedRefCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LibTypedRefCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// LibWildcardTypeRefCS
protected class LibTypeRefCS_LibWildcardTypeRefCSParserRuleCall_1 extends RuleCallToken {
	
	public LibTypeRefCS_LibWildcardTypeRefCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLibTypeRefCSAccess().getLibWildcardTypeRefCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LibWildcardTypeRefCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLibWildcardTypeRefCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule LibTypeRefCS ****************/


/************ begin Rule LibTypedRefCS ****************
 *
 * LibTypedRefCS returns base::TypedRefCS:
 *   LibQualifiedTypeRefCS|LibTypedTypeRefCS;
 *
 **/

// LibQualifiedTypeRefCS|LibTypedTypeRefCS
protected class LibTypedRefCS_Alternatives extends AlternativesToken {

	public LibTypedRefCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLibTypedRefCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_LibQualifiedTypeRefCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new LibTypedRefCS_LibTypedTypeRefCSParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// LibQualifiedTypeRefCS
protected class LibTypedRefCS_LibQualifiedTypeRefCSParserRuleCall_0 extends RuleCallToken {
	
	public LibTypedRefCS_LibQualifiedTypeRefCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLibTypedRefCSAccess().getLibQualifiedTypeRefCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibQualifiedTypeRefCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LibQualifiedTypeRefCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLibQualifiedTypeRefCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// LibTypedTypeRefCS
protected class LibTypedRefCS_LibTypedTypeRefCSParserRuleCall_1 extends RuleCallToken {
	
	public LibTypedRefCS_LibTypedTypeRefCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLibTypedRefCSAccess().getLibTypedTypeRefCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedTypeRefCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LibTypedTypeRefCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLibTypedTypeRefCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule LibTypedRefCS ****************/


/************ begin Rule LibTypedTypeRefCS ****************
 *
 * LibTypedTypeRefCS returns base::TypedTypeRefCS:
 *   type=[base::TypeCS|Identifier] ("<" typeArguments+=LibTypeRefCS ("," typeArguments+=
 *   LibTypeRefCS)* ">")?;
 *
 **/

// type=[base::TypeCS|Identifier] ("<" typeArguments+=LibTypeRefCS ("," typeArguments+=
// LibTypeRefCS)* ">")?
protected class LibTypedTypeRefCS_Group extends GroupToken {
	
	public LibTypedTypeRefCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibTypedTypeRefCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedTypeRefCS_Group_1(parent, this, 0, inst);
			case 1: return new LibTypedTypeRefCS_TypeAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibTypedTypeRefCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type=[base::TypeCS|Identifier]
protected class LibTypedTypeRefCS_TypeAssignment_0 extends AssignmentToken  {
	
	public LibTypedTypeRefCS_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibTypedTypeRefCSAccess().getTypeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedTypeRefCSAccess().getTypeTypeCSCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getLibTypedTypeRefCSAccess().getTypeTypeCSCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("<" typeArguments+=LibTypeRefCS ("," typeArguments+=LibTypeRefCS)* ">")?
protected class LibTypedTypeRefCS_Group_1 extends GroupToken {
	
	public LibTypedTypeRefCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibTypedTypeRefCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedTypeRefCS_GreaterThanSignKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class LibTypedTypeRefCS_LessThanSignKeyword_1_0 extends KeywordToken  {
	
	public LibTypedTypeRefCS_LessThanSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibTypedTypeRefCSAccess().getLessThanSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedTypeRefCS_TypeAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeArguments+=LibTypeRefCS
protected class LibTypedTypeRefCS_TypeArgumentsAssignment_1_1 extends AssignmentToken  {
	
	public LibTypedTypeRefCS_TypeArgumentsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibTypedTypeRefCSAccess().getTypeArgumentsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeArguments",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeArguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypeRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibTypedTypeRefCSAccess().getTypeArgumentsLibTypeRefCSParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibTypedTypeRefCS_LessThanSignKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," typeArguments+=LibTypeRefCS)*
protected class LibTypedTypeRefCS_Group_1_2 extends GroupToken {
	
	public LibTypedTypeRefCS_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibTypedTypeRefCSAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedTypeRefCS_TypeArgumentsAssignment_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LibTypedTypeRefCS_CommaKeyword_1_2_0 extends KeywordToken  {
	
	public LibTypedTypeRefCS_CommaKeyword_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibTypedTypeRefCSAccess().getCommaKeyword_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedTypeRefCS_Group_1_2(parent, this, 0, inst);
			case 1: return new LibTypedTypeRefCS_TypeArgumentsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// typeArguments+=LibTypeRefCS
protected class LibTypedTypeRefCS_TypeArgumentsAssignment_1_2_1 extends AssignmentToken  {
	
	public LibTypedTypeRefCS_TypeArgumentsAssignment_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibTypedTypeRefCSAccess().getTypeArgumentsAssignment_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypeRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeArguments",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeArguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypeRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibTypedTypeRefCSAccess().getTypeArgumentsLibTypeRefCSParserRuleCall_1_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibTypedTypeRefCS_CommaKeyword_1_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ">"
protected class LibTypedTypeRefCS_GreaterThanSignKeyword_1_3 extends KeywordToken  {
	
	public LibTypedTypeRefCS_GreaterThanSignKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibTypedTypeRefCSAccess().getGreaterThanSignKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedTypeRefCS_Group_1_2(parent, this, 0, inst);
			case 1: return new LibTypedTypeRefCS_TypeArgumentsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule LibTypedTypeRefCS ****************/


/************ begin Rule LibWildcardTypeRefCS ****************
 *
 * LibWildcardTypeRefCS returns base::WildcardTypeRefCS:
 *   {base::WildcardTypeRefCS} "?" ("extends" extends=LibTypedRefCS|"super" super=
 *   LibTypedRefCS)?;
 *
 **/

// {base::WildcardTypeRefCS} "?" ("extends" extends=LibTypedRefCS|"super" super=
// LibTypedRefCS)?
protected class LibWildcardTypeRefCS_Group extends GroupToken {
	
	public LibWildcardTypeRefCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_Alternatives_2(parent, this, 0, inst);
			case 1: return new LibWildcardTypeRefCS_QuestionMarkKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLibWildcardTypeRefCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {base::WildcardTypeRefCS}
protected class LibWildcardTypeRefCS_WildcardTypeRefCSAction_0 extends ActionToken  {

	public LibWildcardTypeRefCS_WildcardTypeRefCSAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getWildcardTypeRefCSAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getLibWildcardTypeRefCSAccess().getWildcardTypeRefCSAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "?"
protected class LibWildcardTypeRefCS_QuestionMarkKeyword_1 extends KeywordToken  {
	
	public LibWildcardTypeRefCS_QuestionMarkKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getQuestionMarkKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_WildcardTypeRefCSAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("extends" extends=LibTypedRefCS|"super" super=LibTypedRefCS)?
protected class LibWildcardTypeRefCS_Alternatives_2 extends AlternativesToken {

	public LibWildcardTypeRefCS_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_Group_2_0(parent, this, 0, inst);
			case 1: return new LibWildcardTypeRefCS_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends" extends=LibTypedRefCS
protected class LibWildcardTypeRefCS_Group_2_0 extends GroupToken {
	
	public LibWildcardTypeRefCS_Group_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getGroup_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_ExtendsAssignment_2_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class LibWildcardTypeRefCS_ExtendsKeyword_2_0_0 extends KeywordToken  {
	
	public LibWildcardTypeRefCS_ExtendsKeyword_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getExtendsKeyword_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_QuestionMarkKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// extends=LibTypedRefCS
protected class LibWildcardTypeRefCS_ExtendsAssignment_2_0_1 extends AssignmentToken  {
	
	public LibWildcardTypeRefCS_ExtendsAssignment_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getExtendsAssignment_2_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibWildcardTypeRefCSAccess().getExtendsLibTypedRefCSParserRuleCall_2_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_ExtendsKeyword_2_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "super" super=LibTypedRefCS
protected class LibWildcardTypeRefCS_Group_2_1 extends GroupToken {
	
	public LibWildcardTypeRefCS_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_SuperAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "super"
protected class LibWildcardTypeRefCS_SuperKeyword_2_1_0 extends KeywordToken  {
	
	public LibWildcardTypeRefCS_SuperKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getSuperKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_QuestionMarkKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// super=LibTypedRefCS
protected class LibWildcardTypeRefCS_SuperAssignment_2_1_1 extends AssignmentToken  {
	
	public LibWildcardTypeRefCS_SuperAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLibWildcardTypeRefCSAccess().getSuperAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LibTypedRefCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("super",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("super");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLibTypedRefCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLibWildcardTypeRefCSAccess().getSuperLibTypedRefCSParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LibWildcardTypeRefCS_SuperKeyword_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule LibWildcardTypeRefCS ****************/

}
