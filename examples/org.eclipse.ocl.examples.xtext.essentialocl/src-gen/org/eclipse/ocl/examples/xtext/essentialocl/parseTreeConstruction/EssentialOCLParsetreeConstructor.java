/*
* generated by Xtext
*/
package org.eclipse.ocl.examples.xtext.essentialocl.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.ocl.examples.xtext.essentialocl.services.EssentialOCLGrammarAccess;

import com.google.inject.Inject;

public class EssentialOCLParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private EssentialOCLGrammarAccess grammarAccess;
	
	@Override	
	public EssentialOCLGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_OclExpressionCSParserRuleCall(this, this, 0, inst);
			case 1: return new ReservedKeywordCS_Alternatives(this, this, 1, inst);
			case 2: return new TupleKeywordCS_ValueAssignment(this, this, 2, inst);
			case 3: return new RestrictedKeywordCS_Alternatives(this, this, 3, inst);
			case 4: return new SelfKeywordCS_ValueAssignment(this, this, 4, inst);
			case 5: return new SimpleNameCS_ValueAssignment(this, this, 5, inst);
			case 6: return new UnreservedSimpleNameCS_Alternatives(this, this, 6, inst);
			case 7: return new PathNameCS_Group(this, this, 7, inst);
			case 8: return new PrimitiveTypeCS_Alternatives(this, this, 8, inst);
			case 9: return new CollectionTypeIdentifierCS_Alternatives(this, this, 9, inst);
			case 10: return new TypeCS_Alternatives(this, this, 10, inst);
			case 11: return new CollectionTypeCS_Group(this, this, 11, inst);
			case 12: return new TupleTypeCS_Group(this, this, 12, inst);
			case 13: return new TuplePartCS_Group(this, this, 13, inst);
			case 14: return new LiteralExpCS_Alternatives(this, this, 14, inst);
			case 15: return new CollectionLiteralExpCS_Group(this, this, 15, inst);
			case 16: return new CollectionLiteralPartCS_Group(this, this, 16, inst);
			case 17: return new PrimitiveLiteralExpCS_Alternatives(this, this, 17, inst);
			case 18: return new TupleLiteralExpCS_Group(this, this, 18, inst);
			case 19: return new TupleLiteralPartCS_Group(this, this, 19, inst);
			case 20: return new IntegerLiteralExpCS_IntegerSymbolAssignment(this, this, 20, inst);
			case 21: return new RealLiteralExpCS_RealSymbolAssignment(this, this, 21, inst);
			case 22: return new StringLiteralExpCS_StringSymbolAssignment(this, this, 22, inst);
			case 23: return new BooleanLiteralExpCS_Alternatives(this, this, 23, inst);
			case 24: return new UnlimitedNaturalLiteralExpCS_Group(this, this, 24, inst);
			case 25: return new InvalidLiteralExpCS_Group(this, this, 25, inst);
			case 26: return new NullLiteralExpCS_Group(this, this, 26, inst);
			case 27: return new TypeLiteralExpCS_Alternatives(this, this, 27, inst);
			case 28: return new OclExpressionCS_Alternatives(this, this, 28, inst);
			case 29: return new ImpliesCS_Group(this, this, 29, inst);
			case 30: return new XorCS_Group(this, this, 30, inst);
			case 31: return new OrCS_Group(this, this, 31, inst);
			case 32: return new AndCS_Group(this, this, 32, inst);
			case 33: return new EqualityCS_Group(this, this, 33, inst);
			case 34: return new RelationalCS_Group(this, this, 34, inst);
			case 35: return new AdditiveCS_Group(this, this, 35, inst);
			case 36: return new MultiplicativeCS_Group(this, this, 36, inst);
			case 37: return new UnaryCS_Alternatives(this, this, 37, inst);
			case 38: return new CallingExpCS_Group(this, this, 38, inst);
			case 39: return new IteratorVariableCS_Group(this, this, 39, inst);
			case 40: return new IteratorAccumulatorCS_Group(this, this, 40, inst);
			case 41: return new CallExpCS_Group(this, this, 41, inst);
			case 42: return new PreExpCS_IndexExpCSParserRuleCall(this, this, 42, inst);
			case 43: return new IndexExpCS_Group(this, this, 43, inst);
			case 44: return new MessageExpCS_PrimaryExpCSParserRuleCall(this, this, 44, inst);
			case 45: return new PrimaryExpCS_Alternatives(this, this, 45, inst);
			case 46: return new IfExpCS_Group(this, this, 46, inst);
			case 47: return new LetExpCS_Group(this, this, 47, inst);
			case 48: return new LetVariableCS_Group(this, this, 48, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Model ****************
 *
 * Model returns OclExpressionCS:
 *   OclExpressionCS;  
 * //generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
 *
 **/

// OclExpressionCS
protected class Model_OclExpressionCSParserRuleCall extends RuleCallToken {
	
	public Model_OclExpressionCSParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getModelAccess().getOclExpressionCSParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OclExpressionCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule Model ****************/




/************ begin Rule reservedKeywordCS ****************
 *
 * reservedKeywordCS returns SimpleNameCS:
 *   value="and"|value="else"|value="endif"|value="if"|value="implies"|value="in"|
 *   value="let"|value="not"|value="or"|value="then"|value="xor"; 
 * 	
 * //---------------------------------------------------------------------
 * //  Names
 * //---------------------------------------------------------------------
 * / *  Temporary backward compatibility support for 7.4.8 conceptual usage 
 * conceptualOperationName returns SimpleNameCS:
 * 	value='and'
 * 	| value='implies'
 * 	| value='not'
 * 	| value='or'
 * 	| value='xor'
 * 	| value='<'
 * 	| value='<='
 * 	| value='>='
 * 	| value='>'
 * 	| value='='
 * 	| value='<>'
 * 	| value='+'
 * 	| value='-'
 * 	| value='*'
 * 	| value='/';
 * conceptualOperationNameCS returns SimpleNameCS:
 * 	conceptualOperationName; * /
 *
 **/

// value="and"|value="else"|value="endif"|value="if"|value="implies"|value="in"|
// value="let"|value="not"|value="or"|value="then"|value="xor" 
// 	
// //---------------------------------------------------------------------
// //  Names
// //---------------------------------------------------------------------
// / *  Temporary backward compatibility support for 7.4.8 conceptual usage 
// conceptualOperationName returns SimpleNameCS:
// 	value='and'
// 	| value='implies'
// 	| value='not'
// 	| value='or'
// 	| value='xor'
// 	| value='<'
// 	| value='<='
// 	| value='>='
// 	| value='>'
// 	| value='='
// 	| value='<>'
// 	| value='+'
// 	| value='-'
// 	| value='*'
// 	| value='/';
// conceptualOperationNameCS returns SimpleNameCS:
// 	conceptualOperationName; * /
protected class ReservedKeywordCS_Alternatives extends AlternativesToken {

	public ReservedKeywordCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ReservedKeywordCS_ValueAssignment_0(parent, this, 0, inst);
			case 1: return new ReservedKeywordCS_ValueAssignment_1(parent, this, 1, inst);
			case 2: return new ReservedKeywordCS_ValueAssignment_2(parent, this, 2, inst);
			case 3: return new ReservedKeywordCS_ValueAssignment_3(parent, this, 3, inst);
			case 4: return new ReservedKeywordCS_ValueAssignment_4(parent, this, 4, inst);
			case 5: return new ReservedKeywordCS_ValueAssignment_5(parent, this, 5, inst);
			case 6: return new ReservedKeywordCS_ValueAssignment_6(parent, this, 6, inst);
			case 7: return new ReservedKeywordCS_ValueAssignment_7(parent, this, 7, inst);
			case 8: return new ReservedKeywordCS_ValueAssignment_8(parent, this, 8, inst);
			case 9: return new ReservedKeywordCS_ValueAssignment_9(parent, this, 9, inst);
			case 10: return new ReservedKeywordCS_ValueAssignment_10(parent, this, 10, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getReservedKeywordCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// value="and"
protected class ReservedKeywordCS_ValueAssignment_0 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("and".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueAndKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// value="else"
protected class ReservedKeywordCS_ValueAssignment_1 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("else".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueElseKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// value="endif"
protected class ReservedKeywordCS_ValueAssignment_2 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("endif".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueEndifKeyword_2_0();
			return obj;
		}
		return null;
	}

}

// value="if"
protected class ReservedKeywordCS_ValueAssignment_3 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("if".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueIfKeyword_3_0();
			return obj;
		}
		return null;
	}

}

// value="implies"
protected class ReservedKeywordCS_ValueAssignment_4 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("implies".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueImpliesKeyword_4_0();
			return obj;
		}
		return null;
	}

}

// value="in"
protected class ReservedKeywordCS_ValueAssignment_5 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("in".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueInKeyword_5_0();
			return obj;
		}
		return null;
	}

}

// value="let"
protected class ReservedKeywordCS_ValueAssignment_6 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("let".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueLetKeyword_6_0();
			return obj;
		}
		return null;
	}

}

// value="not"
protected class ReservedKeywordCS_ValueAssignment_7 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("not".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueNotKeyword_7_0();
			return obj;
		}
		return null;
	}

}

// value="or"
protected class ReservedKeywordCS_ValueAssignment_8 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("or".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueOrKeyword_8_0();
			return obj;
		}
		return null;
	}

}

// value="then"
protected class ReservedKeywordCS_ValueAssignment_9 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("then".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueThenKeyword_9_0();
			return obj;
		}
		return null;
	}

}

// value="xor"
protected class ReservedKeywordCS_ValueAssignment_10 extends AssignmentToken  {
	
	public ReservedKeywordCS_ValueAssignment_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReservedKeywordCSAccess().getValueAssignment_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("xor".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getReservedKeywordCSAccess().getValueXorKeyword_10_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule reservedKeywordCS ****************/


/************ begin Rule tupleKeywordCS ****************
 *
 * tupleKeywordCS returns SimpleNameCS:
 *   value="Tuple";
 *
 **/

// value="Tuple"
protected class TupleKeywordCS_ValueAssignment extends AssignmentToken  {
	
	public TupleKeywordCS_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTupleKeywordCSAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTupleKeywordCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("Tuple".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTupleKeywordCSAccess().getValueTupleKeyword_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule tupleKeywordCS ****************/


/************ begin Rule restrictedKeywordCS ****************
 *
 * restrictedKeywordCS returns SimpleNameCS:
 *   CollectionTypeIdentifierCS|primitiveTypeCS|tupleKeywordCS; 
 * 
 *      
 * 	
 * //  restrictedKeywordCS -> BooleanLiteralExpCS
 * //  restrictedKeywordCS -> InvalidLiteralExpCS
 * //  restrictedKeywordCS -> NullLiteralExpCS
 * //-  restrictedKeywordCS -> selfKeywordCS
 *
 **/

// CollectionTypeIdentifierCS|primitiveTypeCS|tupleKeywordCS 
// 
//      
// 	
// //  restrictedKeywordCS -> BooleanLiteralExpCS
// //  restrictedKeywordCS -> InvalidLiteralExpCS
// //  restrictedKeywordCS -> NullLiteralExpCS
// //-  restrictedKeywordCS -> selfKeywordCS
protected class RestrictedKeywordCS_Alternatives extends AlternativesToken {

	public RestrictedKeywordCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRestrictedKeywordCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RestrictedKeywordCS_CollectionTypeIdentifierCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new RestrictedKeywordCS_PrimitiveTypeCSParserRuleCall_1(parent, this, 1, inst);
			case 2: return new RestrictedKeywordCS_TupleKeywordCSParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRestrictedKeywordCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// CollectionTypeIdentifierCS  
// 	
// //  restrictedKeywordCS -> BooleanLiteralExpCS
// //  restrictedKeywordCS -> InvalidLiteralExpCS
// //  restrictedKeywordCS -> NullLiteralExpCS
// //-  restrictedKeywordCS -> selfKeywordCS
protected class RestrictedKeywordCS_CollectionTypeIdentifierCSParserRuleCall_0 extends RuleCallToken {
	
	public RestrictedKeywordCS_CollectionTypeIdentifierCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRestrictedKeywordCSAccess().getCollectionTypeIdentifierCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionTypeIdentifierCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CollectionTypeIdentifierCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCollectionTypeIdentifierCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// primitiveTypeCS
protected class RestrictedKeywordCS_PrimitiveTypeCSParserRuleCall_1 extends RuleCallToken {
	
	public RestrictedKeywordCS_PrimitiveTypeCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRestrictedKeywordCSAccess().getPrimitiveTypeCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimitiveTypeCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrimitiveTypeCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrimitiveTypeCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// tupleKeywordCS
protected class RestrictedKeywordCS_TupleKeywordCSParserRuleCall_2 extends RuleCallToken {
	
	public RestrictedKeywordCS_TupleKeywordCSParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRestrictedKeywordCSAccess().getTupleKeywordCSParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleKeywordCS_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TupleKeywordCS_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTupleKeywordCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule restrictedKeywordCS ****************/


/************ begin Rule selfKeywordCS ****************
 *
 * selfKeywordCS returns SimpleNameCS:
 *   value="self";
 *
 **/

// value="self"
protected class SelfKeywordCS_ValueAssignment extends AssignmentToken  {
	
	public SelfKeywordCS_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSelfKeywordCSAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSelfKeywordCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("self".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getSelfKeywordCSAccess().getValueSelfKeyword_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule selfKeywordCS ****************/


/************ begin Rule simpleNameCS ****************
 *
 * simpleNameCS returns SimpleNameCS:
 *   value=ID;
 *
 **/

// value=ID
protected class SimpleNameCS_ValueAssignment extends AssignmentToken  {
	
	public SimpleNameCS_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleNameCSAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSimpleNameCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getSimpleNameCSAccess().getValueIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule simpleNameCS ****************/


/************ begin Rule unreservedSimpleNameCS ****************
 *
 * unreservedSimpleNameCS returns SimpleNameCS:
 *   simpleNameCS|restrictedKeywordCS;
 *
 **/

// simpleNameCS|restrictedKeywordCS
protected class UnreservedSimpleNameCS_Alternatives extends AlternativesToken {

	public UnreservedSimpleNameCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getUnreservedSimpleNameCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnreservedSimpleNameCS_SimpleNameCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new UnreservedSimpleNameCS_RestrictedKeywordCSParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnreservedSimpleNameCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// simpleNameCS
protected class UnreservedSimpleNameCS_SimpleNameCSParserRuleCall_0 extends RuleCallToken {
	
	public UnreservedSimpleNameCS_SimpleNameCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnreservedSimpleNameCSAccess().getSimpleNameCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleNameCS_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SimpleNameCS_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSimpleNameCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// restrictedKeywordCS
protected class UnreservedSimpleNameCS_RestrictedKeywordCSParserRuleCall_1 extends RuleCallToken {
	
	public UnreservedSimpleNameCS_RestrictedKeywordCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnreservedSimpleNameCSAccess().getRestrictedKeywordCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RestrictedKeywordCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RestrictedKeywordCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRestrictedKeywordCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule unreservedSimpleNameCS ****************/


/************ begin Rule pathNameCS ****************
 *
 * pathNameCS returns PathNameCS:
 *   simpleNames+=simpleNameCS ("::" simpleNames+=unreservedSimpleNameCS)*; 
 * 
 *     
 * 	    
 * 
 *         
 * //---------------------------------------------------------------------
 * //  Types
 * //---------------------------------------------------------------------
 *
 **/

// simpleNames+=simpleNameCS ("::" simpleNames+=unreservedSimpleNameCS)*
protected class PathNameCS_Group extends GroupToken {
	
	public PathNameCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPathNameCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathNameCS_Group_1(parent, this, 0, inst);
			case 1: return new PathNameCS_SimpleNamesAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPathNameCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// simpleNames+=simpleNameCS
protected class PathNameCS_SimpleNamesAssignment_0 extends AssignmentToken  {
	
	public PathNameCS_SimpleNamesAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPathNameCSAccess().getSimpleNamesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleNameCS_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("simpleNames",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("simpleNames");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleNameCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPathNameCSAccess().getSimpleNamesSimpleNameCSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("::" simpleNames+=unreservedSimpleNameCS)*
protected class PathNameCS_Group_1 extends GroupToken {
	
	public PathNameCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPathNameCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathNameCS_SimpleNamesAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "::"
protected class PathNameCS_ColonColonKeyword_1_0 extends KeywordToken  {
	
	public PathNameCS_ColonColonKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPathNameCSAccess().getColonColonKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathNameCS_Group_1(parent, this, 0, inst);
			case 1: return new PathNameCS_SimpleNamesAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// simpleNames+=unreservedSimpleNameCS
protected class PathNameCS_SimpleNamesAssignment_1_1 extends AssignmentToken  {
	
	public PathNameCS_SimpleNamesAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPathNameCSAccess().getSimpleNamesAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnreservedSimpleNameCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("simpleNames",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("simpleNames");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnreservedSimpleNameCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPathNameCSAccess().getSimpleNamesUnreservedSimpleNameCSParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PathNameCS_ColonColonKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule pathNameCS ****************/


/************ begin Rule primitiveTypeCS ****************
 *
 * primitiveTypeCS returns SimpleNameCS:
 *   value="Boolean"|value="Integer"|value="Real"|value="String"|value=
 *   "UnlimitedNatural"|value="OclAny"|value="OclInvalid"|value="OclVoid"; 
 * 
 *         
 * //---------------------------------------------------------------------
 * //  Types
 * //---------------------------------------------------------------------
 *
 **/

// value="Boolean"|value="Integer"|value="Real"|value="String"|value=
// "UnlimitedNatural"|value="OclAny"|value="OclInvalid"|value="OclVoid" 
// 
//         
// //---------------------------------------------------------------------
// //  Types
// //---------------------------------------------------------------------
protected class PrimitiveTypeCS_Alternatives extends AlternativesToken {

	public PrimitiveTypeCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimitiveTypeCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimitiveTypeCS_ValueAssignment_0(parent, this, 0, inst);
			case 1: return new PrimitiveTypeCS_ValueAssignment_1(parent, this, 1, inst);
			case 2: return new PrimitiveTypeCS_ValueAssignment_2(parent, this, 2, inst);
			case 3: return new PrimitiveTypeCS_ValueAssignment_3(parent, this, 3, inst);
			case 4: return new PrimitiveTypeCS_ValueAssignment_4(parent, this, 4, inst);
			case 5: return new PrimitiveTypeCS_ValueAssignment_5(parent, this, 5, inst);
			case 6: return new PrimitiveTypeCS_ValueAssignment_6(parent, this, 6, inst);
			case 7: return new PrimitiveTypeCS_ValueAssignment_7(parent, this, 7, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimitiveTypeCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// value="Boolean"
protected class PrimitiveTypeCS_ValueAssignment_0 extends AssignmentToken  {
	
	public PrimitiveTypeCS_ValueAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimitiveTypeCSAccess().getValueAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("Boolean".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPrimitiveTypeCSAccess().getValueBooleanKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// value="Integer"
protected class PrimitiveTypeCS_ValueAssignment_1 extends AssignmentToken  {
	
	public PrimitiveTypeCS_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimitiveTypeCSAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("Integer".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPrimitiveTypeCSAccess().getValueIntegerKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// value="Real"
protected class PrimitiveTypeCS_ValueAssignment_2 extends AssignmentToken  {
	
	public PrimitiveTypeCS_ValueAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimitiveTypeCSAccess().getValueAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("Real".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPrimitiveTypeCSAccess().getValueRealKeyword_2_0();
			return obj;
		}
		return null;
	}

}

// value="String"
protected class PrimitiveTypeCS_ValueAssignment_3 extends AssignmentToken  {
	
	public PrimitiveTypeCS_ValueAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimitiveTypeCSAccess().getValueAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("String".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPrimitiveTypeCSAccess().getValueStringKeyword_3_0();
			return obj;
		}
		return null;
	}

}

// value="UnlimitedNatural"
protected class PrimitiveTypeCS_ValueAssignment_4 extends AssignmentToken  {
	
	public PrimitiveTypeCS_ValueAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimitiveTypeCSAccess().getValueAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("UnlimitedNatural".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPrimitiveTypeCSAccess().getValueUnlimitedNaturalKeyword_4_0();
			return obj;
		}
		return null;
	}

}

// value="OclAny"
protected class PrimitiveTypeCS_ValueAssignment_5 extends AssignmentToken  {
	
	public PrimitiveTypeCS_ValueAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimitiveTypeCSAccess().getValueAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("OclAny".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPrimitiveTypeCSAccess().getValueOclAnyKeyword_5_0();
			return obj;
		}
		return null;
	}

}

// value="OclInvalid"
protected class PrimitiveTypeCS_ValueAssignment_6 extends AssignmentToken  {
	
	public PrimitiveTypeCS_ValueAssignment_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimitiveTypeCSAccess().getValueAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("OclInvalid".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPrimitiveTypeCSAccess().getValueOclInvalidKeyword_6_0();
			return obj;
		}
		return null;
	}

}

// value="OclVoid"
protected class PrimitiveTypeCS_ValueAssignment_7 extends AssignmentToken  {
	
	public PrimitiveTypeCS_ValueAssignment_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimitiveTypeCSAccess().getValueAssignment_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("OclVoid".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPrimitiveTypeCSAccess().getValueOclVoidKeyword_7_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule primitiveTypeCS ****************/


/************ begin Rule CollectionTypeIdentifierCS ****************
 *
 * CollectionTypeIdentifierCS returns SimpleNameCS:
 *   value="Set"|value="Bag"|value="Sequence"|value="Collection"|value="OrderedSet";
 *
 **/

// value="Set"|value="Bag"|value="Sequence"|value="Collection"|value="OrderedSet"
protected class CollectionTypeIdentifierCS_Alternatives extends AlternativesToken {

	public CollectionTypeIdentifierCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCollectionTypeIdentifierCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionTypeIdentifierCS_ValueAssignment_0(parent, this, 0, inst);
			case 1: return new CollectionTypeIdentifierCS_ValueAssignment_1(parent, this, 1, inst);
			case 2: return new CollectionTypeIdentifierCS_ValueAssignment_2(parent, this, 2, inst);
			case 3: return new CollectionTypeIdentifierCS_ValueAssignment_3(parent, this, 3, inst);
			case 4: return new CollectionTypeIdentifierCS_ValueAssignment_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCollectionTypeIdentifierCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// value="Set"
protected class CollectionTypeIdentifierCS_ValueAssignment_0 extends AssignmentToken  {
	
	public CollectionTypeIdentifierCS_ValueAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionTypeIdentifierCSAccess().getValueAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("Set".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getCollectionTypeIdentifierCSAccess().getValueSetKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// value="Bag"
protected class CollectionTypeIdentifierCS_ValueAssignment_1 extends AssignmentToken  {
	
	public CollectionTypeIdentifierCS_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionTypeIdentifierCSAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("Bag".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getCollectionTypeIdentifierCSAccess().getValueBagKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// value="Sequence"
protected class CollectionTypeIdentifierCS_ValueAssignment_2 extends AssignmentToken  {
	
	public CollectionTypeIdentifierCS_ValueAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionTypeIdentifierCSAccess().getValueAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("Sequence".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getCollectionTypeIdentifierCSAccess().getValueSequenceKeyword_2_0();
			return obj;
		}
		return null;
	}

}

// value="Collection"
protected class CollectionTypeIdentifierCS_ValueAssignment_3 extends AssignmentToken  {
	
	public CollectionTypeIdentifierCS_ValueAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionTypeIdentifierCSAccess().getValueAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("Collection".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getCollectionTypeIdentifierCSAccess().getValueCollectionKeyword_3_0();
			return obj;
		}
		return null;
	}

}

// value="OrderedSet"
protected class CollectionTypeIdentifierCS_ValueAssignment_4 extends AssignmentToken  {
	
	public CollectionTypeIdentifierCS_ValueAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionTypeIdentifierCSAccess().getValueAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("OrderedSet".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getCollectionTypeIdentifierCSAccess().getValueOrderedSetKeyword_4_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule CollectionTypeIdentifierCS ****************/


/************ begin Rule typeCS ****************
 *
 * typeCS returns TypeCS:
 *   primitiveTypeCS|pathNameCS|collectionTypeCS|tupleTypeCS;
 *
 **/

// primitiveTypeCS|pathNameCS|collectionTypeCS|tupleTypeCS
protected class TypeCS_Alternatives extends AlternativesToken {

	public TypeCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeCS_PrimitiveTypeCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TypeCS_PathNameCSParserRuleCall_1(parent, this, 1, inst);
			case 2: return new TypeCS_CollectionTypeCSParserRuleCall_2(parent, this, 2, inst);
			case 3: return new TypeCS_TupleTypeCSParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// primitiveTypeCS
protected class TypeCS_PrimitiveTypeCSParserRuleCall_0 extends RuleCallToken {
	
	public TypeCS_PrimitiveTypeCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeCSAccess().getPrimitiveTypeCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimitiveTypeCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrimitiveTypeCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrimitiveTypeCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// pathNameCS
protected class TypeCS_PathNameCSParserRuleCall_1 extends RuleCallToken {
	
	public TypeCS_PathNameCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeCSAccess().getPathNameCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathNameCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PathNameCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPathNameCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// collectionTypeCS
protected class TypeCS_CollectionTypeCSParserRuleCall_2 extends RuleCallToken {
	
	public TypeCS_CollectionTypeCSParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeCSAccess().getCollectionTypeCSParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionTypeCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CollectionTypeCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCollectionTypeCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// tupleTypeCS
protected class TypeCS_TupleTypeCSParserRuleCall_3 extends RuleCallToken {
	
	public TypeCS_TupleTypeCSParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeCSAccess().getTupleTypeCSParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleTypeCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TupleTypeCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTupleTypeCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule typeCS ****************/


/************ begin Rule collectionTypeCS ****************
 *
 * collectionTypeCS returns CollectionTypeCS:
 *   value=CollectionTypeIdentifierCS ("(" typeCS=typeCS ")")?;
 *
 **/

// value=CollectionTypeIdentifierCS ("(" typeCS=typeCS ")")?
protected class CollectionTypeCS_Group extends GroupToken {
	
	public CollectionTypeCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCollectionTypeCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionTypeCS_Group_1(parent, this, 0, inst);
			case 1: return new CollectionTypeCS_ValueAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCollectionTypeCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// value=CollectionTypeIdentifierCS
protected class CollectionTypeCS_ValueAssignment_0 extends AssignmentToken  {
	
	public CollectionTypeCS_ValueAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionTypeCSAccess().getValueAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionTypeIdentifierCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCollectionTypeIdentifierCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCollectionTypeCSAccess().getValueCollectionTypeIdentifierCSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("(" typeCS=typeCS ")")?
protected class CollectionTypeCS_Group_1 extends GroupToken {
	
	public CollectionTypeCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCollectionTypeCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionTypeCS_RightParenthesisKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class CollectionTypeCS_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public CollectionTypeCS_LeftParenthesisKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCollectionTypeCSAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionTypeCS_ValueAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeCS=typeCS
protected class CollectionTypeCS_TypeCSAssignment_1_1 extends AssignmentToken  {
	
	public CollectionTypeCS_TypeCSAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionTypeCSAccess().getTypeCSAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeCS",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeCS");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCollectionTypeCSAccess().getTypeCSTypeCSParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CollectionTypeCS_LeftParenthesisKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class CollectionTypeCS_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public CollectionTypeCS_RightParenthesisKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCollectionTypeCSAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionTypeCS_TypeCSAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule collectionTypeCS ****************/


/************ begin Rule tupleTypeCS ****************
 *
 * tupleTypeCS returns TupleTypeCS:
 *   value="Tuple" "(" (part+=tuplePartCS ("," part+=tuplePartCS)*)? ")";
 *
 **/

// value="Tuple" "(" (part+=tuplePartCS ("," part+=tuplePartCS)*)? ")"
protected class TupleTypeCS_Group extends GroupToken {
	
	public TupleTypeCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTupleTypeCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleTypeCS_RightParenthesisKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTupleTypeCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// value="Tuple"
protected class TupleTypeCS_ValueAssignment_0 extends AssignmentToken  {
	
	public TupleTypeCS_ValueAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTupleTypeCSAccess().getValueAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("Tuple".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTupleTypeCSAccess().getValueTupleKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class TupleTypeCS_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public TupleTypeCS_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTupleTypeCSAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleTypeCS_ValueAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (part+=tuplePartCS ("," part+=tuplePartCS)*)?
protected class TupleTypeCS_Group_2 extends GroupToken {
	
	public TupleTypeCS_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTupleTypeCSAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleTypeCS_Group_2_1(parent, this, 0, inst);
			case 1: return new TupleTypeCS_PartAssignment_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// part+=tuplePartCS
protected class TupleTypeCS_PartAssignment_2_0 extends AssignmentToken  {
	
	public TupleTypeCS_PartAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTupleTypeCSAccess().getPartAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TuplePartCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("part",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("part");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTuplePartCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTupleTypeCSAccess().getPartTuplePartCSParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TupleTypeCS_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," part+=tuplePartCS)*
protected class TupleTypeCS_Group_2_1 extends GroupToken {
	
	public TupleTypeCS_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTupleTypeCSAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleTypeCS_PartAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class TupleTypeCS_CommaKeyword_2_1_0 extends KeywordToken  {
	
	public TupleTypeCS_CommaKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTupleTypeCSAccess().getCommaKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleTypeCS_Group_2_1(parent, this, 0, inst);
			case 1: return new TupleTypeCS_PartAssignment_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// part+=tuplePartCS
protected class TupleTypeCS_PartAssignment_2_1_1 extends AssignmentToken  {
	
	public TupleTypeCS_PartAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTupleTypeCSAccess().getPartAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TuplePartCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("part",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("part");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTuplePartCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTupleTypeCSAccess().getPartTuplePartCSParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TupleTypeCS_CommaKeyword_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class TupleTypeCS_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public TupleTypeCS_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTupleTypeCSAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleTypeCS_Group_2(parent, this, 0, inst);
			case 1: return new TupleTypeCS_LeftParenthesisKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule tupleTypeCS ****************/


/************ begin Rule tuplePartCS ****************
 *
 * tuplePartCS returns VariableCS:
 *   name=simpleNameCS ":" type=typeCS; 
 *         
 *     
 * 	    
 * 
 * 
 * //---------------------------------------------------------------------
 * //  Literals
 * //---------------------------------------------------------------------
 * // EnumLiteralExpCS is parsed as a PropertyCallExpCS[C]
 * //  LiteralExpCS -> EnumLiteralExpCS
 *
 **/

// name=simpleNameCS ":" type=typeCS
protected class TuplePartCS_Group extends GroupToken {
	
	public TuplePartCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTuplePartCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TuplePartCS_TypeAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTuplePartCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=simpleNameCS
protected class TuplePartCS_NameAssignment_0 extends AssignmentToken  {
	
	public TuplePartCS_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTuplePartCSAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleNameCS_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleNameCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTuplePartCSAccess().getNameSimpleNameCSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ":"
protected class TuplePartCS_ColonKeyword_1 extends KeywordToken  {
	
	public TuplePartCS_ColonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTuplePartCSAccess().getColonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TuplePartCS_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=typeCS
protected class TuplePartCS_TypeAssignment_2 extends AssignmentToken  {
	
	public TuplePartCS_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTuplePartCSAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTuplePartCSAccess().getTypeTypeCSParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TuplePartCS_ColonKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule tuplePartCS ****************/


/************ begin Rule LiteralExpCS ****************
 *
 * LiteralExpCS:
 *   CollectionLiteralExpCS|TupleLiteralExpCS|PrimitiveLiteralExpCS|TypeLiteralExpCS; 
 * 
 * //---------------------------------------------------------------------
 * //  Literals
 * //---------------------------------------------------------------------
 * // EnumLiteralExpCS is parsed as a PropertyCallExpCS[C]
 * //  LiteralExpCS -> EnumLiteralExpCS
 *
 **/

// CollectionLiteralExpCS|TupleLiteralExpCS|PrimitiveLiteralExpCS|TypeLiteralExpCS 
// 
// //---------------------------------------------------------------------
// //  Literals
// //---------------------------------------------------------------------
// // EnumLiteralExpCS is parsed as a PropertyCallExpCS[C]
// //  LiteralExpCS -> EnumLiteralExpCS
protected class LiteralExpCS_Alternatives extends AlternativesToken {

	public LiteralExpCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLiteralExpCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralExpCS_CollectionLiteralExpCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new LiteralExpCS_TupleLiteralExpCSParserRuleCall_1(parent, this, 1, inst);
			case 2: return new LiteralExpCS_PrimitiveLiteralExpCSParserRuleCall_2(parent, this, 2, inst);
			case 3: return new LiteralExpCS_TypeLiteralExpCSParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// CollectionLiteralExpCS
protected class LiteralExpCS_CollectionLiteralExpCSParserRuleCall_0 extends RuleCallToken {
	
	public LiteralExpCS_CollectionLiteralExpCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralExpCSAccess().getCollectionLiteralExpCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CollectionLiteralExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCollectionLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// TupleLiteralExpCS
protected class LiteralExpCS_TupleLiteralExpCSParserRuleCall_1 extends RuleCallToken {
	
	public LiteralExpCS_TupleLiteralExpCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralExpCSAccess().getTupleLiteralExpCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TupleLiteralExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTupleLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// PrimitiveLiteralExpCS
protected class LiteralExpCS_PrimitiveLiteralExpCSParserRuleCall_2 extends RuleCallToken {
	
	public LiteralExpCS_PrimitiveLiteralExpCSParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralExpCSAccess().getPrimitiveLiteralExpCSParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimitiveLiteralExpCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrimitiveLiteralExpCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrimitiveLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// TypeLiteralExpCS
protected class LiteralExpCS_TypeLiteralExpCSParserRuleCall_3 extends RuleCallToken {
	
	public LiteralExpCS_TypeLiteralExpCSParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralExpCSAccess().getTypeLiteralExpCSParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeLiteralExpCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypeLiteralExpCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule LiteralExpCS ****************/


/************ begin Rule CollectionLiteralExpCS ****************
 *
 * CollectionLiteralExpCS:
 *   collectionTypeCS ("{" (collectionLiteralParts+=CollectionLiteralPartCS (","
 *   collectionLiteralParts+=CollectionLiteralPartCS)*)? "}")?; 
 * 
 *     	 // or CollectionTypeLiteral
 *
 **/

// collectionTypeCS ("{" (collectionLiteralParts+=CollectionLiteralPartCS (","
// collectionLiteralParts+=CollectionLiteralPartCS)*)? "}")? 	 // or CollectionTypeLiteral
protected class CollectionLiteralExpCS_Group extends GroupToken {
	
	public CollectionLiteralExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralExpCS_Group_1(parent, this, 0, inst);
			case 1: return new CollectionLiteralExpCS_CollectionTypeCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCollectionLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// collectionTypeCS 	 // or CollectionTypeLiteral
protected class CollectionLiteralExpCS_CollectionTypeCSParserRuleCall_0 extends RuleCallToken {
	
	public CollectionLiteralExpCS_CollectionTypeCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getCollectionTypeCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionTypeCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CollectionTypeCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCollectionTypeCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ("{" (collectionLiteralParts+=CollectionLiteralPartCS ("," collectionLiteralParts+=
// CollectionLiteralPartCS)*)? "}")?
protected class CollectionLiteralExpCS_Group_1 extends GroupToken {
	
	public CollectionLiteralExpCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralExpCS_RightCurlyBracketKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class CollectionLiteralExpCS_LeftCurlyBracketKeyword_1_0 extends KeywordToken  {
	
	public CollectionLiteralExpCS_LeftCurlyBracketKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getLeftCurlyBracketKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralExpCS_CollectionTypeCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (collectionLiteralParts+=CollectionLiteralPartCS ("," collectionLiteralParts+=
// CollectionLiteralPartCS)*)?
protected class CollectionLiteralExpCS_Group_1_1 extends GroupToken {
	
	public CollectionLiteralExpCS_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralExpCS_Group_1_1_1(parent, this, 0, inst);
			case 1: return new CollectionLiteralExpCS_CollectionLiteralPartsAssignment_1_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// collectionLiteralParts+=CollectionLiteralPartCS
protected class CollectionLiteralExpCS_CollectionLiteralPartsAssignment_1_1_0 extends AssignmentToken  {
	
	public CollectionLiteralExpCS_CollectionLiteralPartsAssignment_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getCollectionLiteralPartsAssignment_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralPartCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("collectionLiteralParts",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("collectionLiteralParts");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCollectionLiteralPartCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCollectionLiteralExpCSAccess().getCollectionLiteralPartsCollectionLiteralPartCSParserRuleCall_1_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CollectionLiteralExpCS_LeftCurlyBracketKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," collectionLiteralParts+=CollectionLiteralPartCS)*
protected class CollectionLiteralExpCS_Group_1_1_1 extends GroupToken {
	
	public CollectionLiteralExpCS_Group_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getGroup_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralExpCS_CollectionLiteralPartsAssignment_1_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class CollectionLiteralExpCS_CommaKeyword_1_1_1_0 extends KeywordToken  {
	
	public CollectionLiteralExpCS_CommaKeyword_1_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getCommaKeyword_1_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralExpCS_Group_1_1_1(parent, this, 0, inst);
			case 1: return new CollectionLiteralExpCS_CollectionLiteralPartsAssignment_1_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// collectionLiteralParts+=CollectionLiteralPartCS
protected class CollectionLiteralExpCS_CollectionLiteralPartsAssignment_1_1_1_1 extends AssignmentToken  {
	
	public CollectionLiteralExpCS_CollectionLiteralPartsAssignment_1_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getCollectionLiteralPartsAssignment_1_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralPartCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("collectionLiteralParts",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("collectionLiteralParts");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCollectionLiteralPartCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCollectionLiteralExpCSAccess().getCollectionLiteralPartsCollectionLiteralPartCSParserRuleCall_1_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CollectionLiteralExpCS_CommaKeyword_1_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "}"
protected class CollectionLiteralExpCS_RightCurlyBracketKeyword_1_2 extends KeywordToken  {
	
	public CollectionLiteralExpCS_RightCurlyBracketKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCollectionLiteralExpCSAccess().getRightCurlyBracketKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralExpCS_Group_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule CollectionLiteralExpCS ****************/


/************ begin Rule CollectionLiteralPartCS ****************
 *
 * CollectionLiteralPartCS:
 *   expressionCS=OclExpressionCS (".." lastExpressionCS=OclExpressionCS)?;
 *
 **/

// expressionCS=OclExpressionCS (".." lastExpressionCS=OclExpressionCS)?
protected class CollectionLiteralPartCS_Group extends GroupToken {
	
	public CollectionLiteralPartCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCollectionLiteralPartCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralPartCS_Group_1(parent, this, 0, inst);
			case 1: return new CollectionLiteralPartCS_ExpressionCSAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCollectionLiteralPartCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// expressionCS=OclExpressionCS
protected class CollectionLiteralPartCS_ExpressionCSAssignment_0 extends AssignmentToken  {
	
	public CollectionLiteralPartCS_ExpressionCSAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionLiteralPartCSAccess().getExpressionCSAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressionCS",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressionCS");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCollectionLiteralPartCSAccess().getExpressionCSOclExpressionCSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (".." lastExpressionCS=OclExpressionCS)?
protected class CollectionLiteralPartCS_Group_1 extends GroupToken {
	
	public CollectionLiteralPartCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCollectionLiteralPartCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralPartCS_LastExpressionCSAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ".."
protected class CollectionLiteralPartCS_FullStopFullStopKeyword_1_0 extends KeywordToken  {
	
	public CollectionLiteralPartCS_FullStopFullStopKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCollectionLiteralPartCSAccess().getFullStopFullStopKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CollectionLiteralPartCS_ExpressionCSAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// lastExpressionCS=OclExpressionCS
protected class CollectionLiteralPartCS_LastExpressionCSAssignment_1_1 extends AssignmentToken  {
	
	public CollectionLiteralPartCS_LastExpressionCSAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCollectionLiteralPartCSAccess().getLastExpressionCSAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("lastExpressionCS",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("lastExpressionCS");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCollectionLiteralPartCSAccess().getLastExpressionCSOclExpressionCSParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CollectionLiteralPartCS_FullStopFullStopKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule CollectionLiteralPartCS ****************/


/************ begin Rule PrimitiveLiteralExpCS ****************
 *
 * PrimitiveLiteralExpCS:
 *   IntegerLiteralExpCS|RealLiteralExpCS|StringLiteralExpCS|BooleanLiteralExpCS|
 *   UnlimitedNaturalLiteralExpCS|InvalidLiteralExpCS|NullLiteralExpCS;
 *
 **/

// IntegerLiteralExpCS|RealLiteralExpCS|StringLiteralExpCS|BooleanLiteralExpCS|
// UnlimitedNaturalLiteralExpCS|InvalidLiteralExpCS|NullLiteralExpCS
protected class PrimitiveLiteralExpCS_Alternatives extends AlternativesToken {

	public PrimitiveLiteralExpCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimitiveLiteralExpCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimitiveLiteralExpCS_IntegerLiteralExpCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new PrimitiveLiteralExpCS_RealLiteralExpCSParserRuleCall_1(parent, this, 1, inst);
			case 2: return new PrimitiveLiteralExpCS_StringLiteralExpCSParserRuleCall_2(parent, this, 2, inst);
			case 3: return new PrimitiveLiteralExpCS_BooleanLiteralExpCSParserRuleCall_3(parent, this, 3, inst);
			case 4: return new PrimitiveLiteralExpCS_UnlimitedNaturalLiteralExpCSParserRuleCall_4(parent, this, 4, inst);
			case 5: return new PrimitiveLiteralExpCS_InvalidLiteralExpCSParserRuleCall_5(parent, this, 5, inst);
			case 6: return new PrimitiveLiteralExpCS_NullLiteralExpCSParserRuleCall_6(parent, this, 6, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimitiveLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// IntegerLiteralExpCS
protected class PrimitiveLiteralExpCS_IntegerLiteralExpCSParserRuleCall_0 extends RuleCallToken {
	
	public PrimitiveLiteralExpCS_IntegerLiteralExpCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimitiveLiteralExpCSAccess().getIntegerLiteralExpCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntegerLiteralExpCS_IntegerSymbolAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntegerLiteralExpCS_IntegerSymbolAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntegerLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// RealLiteralExpCS
protected class PrimitiveLiteralExpCS_RealLiteralExpCSParserRuleCall_1 extends RuleCallToken {
	
	public PrimitiveLiteralExpCS_RealLiteralExpCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimitiveLiteralExpCSAccess().getRealLiteralExpCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RealLiteralExpCS_RealSymbolAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RealLiteralExpCS_RealSymbolAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRealLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StringLiteralExpCS
protected class PrimitiveLiteralExpCS_StringLiteralExpCSParserRuleCall_2 extends RuleCallToken {
	
	public PrimitiveLiteralExpCS_StringLiteralExpCSParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimitiveLiteralExpCSAccess().getStringLiteralExpCSParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StringLiteralExpCS_StringSymbolAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StringLiteralExpCS_StringSymbolAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStringLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BooleanLiteralExpCS
protected class PrimitiveLiteralExpCS_BooleanLiteralExpCSParserRuleCall_3 extends RuleCallToken {
	
	public PrimitiveLiteralExpCS_BooleanLiteralExpCSParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimitiveLiteralExpCSAccess().getBooleanLiteralExpCSParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteralExpCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanLiteralExpCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// UnlimitedNaturalLiteralExpCS
protected class PrimitiveLiteralExpCS_UnlimitedNaturalLiteralExpCSParserRuleCall_4 extends RuleCallToken {
	
	public PrimitiveLiteralExpCS_UnlimitedNaturalLiteralExpCSParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimitiveLiteralExpCSAccess().getUnlimitedNaturalLiteralExpCSParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnlimitedNaturalLiteralExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UnlimitedNaturalLiteralExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUnlimitedNaturalLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// InvalidLiteralExpCS
protected class PrimitiveLiteralExpCS_InvalidLiteralExpCSParserRuleCall_5 extends RuleCallToken {
	
	public PrimitiveLiteralExpCS_InvalidLiteralExpCSParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimitiveLiteralExpCSAccess().getInvalidLiteralExpCSParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InvalidLiteralExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(InvalidLiteralExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getInvalidLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// NullLiteralExpCS
protected class PrimitiveLiteralExpCS_NullLiteralExpCSParserRuleCall_6 extends RuleCallToken {
	
	public PrimitiveLiteralExpCS_NullLiteralExpCSParserRuleCall_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimitiveLiteralExpCSAccess().getNullLiteralExpCSParserRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteralExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NullLiteralExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNullLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule PrimitiveLiteralExpCS ****************/


/************ begin Rule TupleLiteralExpCS ****************
 *
 * TupleLiteralExpCS:
 *   {TupleLiteralExpCS} "Tuple" ("{" part+=TupleLiteralPartCS ("," part+=
 *   TupleLiteralPartCS)* "}")?; 
 * 
 *       // or TupleTypeLiteral
 *
 **/

// {TupleLiteralExpCS} "Tuple" ("{" part+=TupleLiteralPartCS ("," part+=
// TupleLiteralPartCS)* "}")?   // or TupleTypeLiteral
protected class TupleLiteralExpCS_Group extends GroupToken {
	
	public TupleLiteralExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralExpCS_Group_2(parent, this, 0, inst);
			case 1: return new TupleLiteralExpCS_TupleKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTupleLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {TupleLiteralExpCS}   // or TupleTypeLiteral
protected class TupleLiteralExpCS_TupleLiteralExpCSAction_0 extends ActionToken  {

	public TupleLiteralExpCS_TupleLiteralExpCSAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getTupleLiteralExpCSAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getTupleLiteralExpCSAccess().getTupleLiteralExpCSAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "Tuple"
protected class TupleLiteralExpCS_TupleKeyword_1 extends KeywordToken  {
	
	public TupleLiteralExpCS_TupleKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getTupleKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralExpCS_TupleLiteralExpCSAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("{" part+=TupleLiteralPartCS ("," part+=TupleLiteralPartCS)* "}")?
protected class TupleLiteralExpCS_Group_2 extends GroupToken {
	
	public TupleLiteralExpCS_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralExpCS_RightCurlyBracketKeyword_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "{"
protected class TupleLiteralExpCS_LeftCurlyBracketKeyword_2_0 extends KeywordToken  {
	
	public TupleLiteralExpCS_LeftCurlyBracketKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getLeftCurlyBracketKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralExpCS_TupleKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// part+=TupleLiteralPartCS
protected class TupleLiteralExpCS_PartAssignment_2_1 extends AssignmentToken  {
	
	public TupleLiteralExpCS_PartAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getPartAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralPartCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("part",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("part");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTupleLiteralPartCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTupleLiteralExpCSAccess().getPartTupleLiteralPartCSParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TupleLiteralExpCS_LeftCurlyBracketKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," part+=TupleLiteralPartCS)*
protected class TupleLiteralExpCS_Group_2_2 extends GroupToken {
	
	public TupleLiteralExpCS_Group_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getGroup_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralExpCS_PartAssignment_2_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class TupleLiteralExpCS_CommaKeyword_2_2_0 extends KeywordToken  {
	
	public TupleLiteralExpCS_CommaKeyword_2_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getCommaKeyword_2_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralExpCS_Group_2_2(parent, this, 0, inst);
			case 1: return new TupleLiteralExpCS_PartAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// part+=TupleLiteralPartCS
protected class TupleLiteralExpCS_PartAssignment_2_2_1 extends AssignmentToken  {
	
	public TupleLiteralExpCS_PartAssignment_2_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getPartAssignment_2_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralPartCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("part",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("part");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTupleLiteralPartCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTupleLiteralExpCSAccess().getPartTupleLiteralPartCSParserRuleCall_2_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TupleLiteralExpCS_CommaKeyword_2_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class TupleLiteralExpCS_RightCurlyBracketKeyword_2_3 extends KeywordToken  {
	
	public TupleLiteralExpCS_RightCurlyBracketKeyword_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTupleLiteralExpCSAccess().getRightCurlyBracketKeyword_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralExpCS_Group_2_2(parent, this, 0, inst);
			case 1: return new TupleLiteralExpCS_PartAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule TupleLiteralExpCS ****************/


/************ begin Rule TupleLiteralPartCS ****************
 *
 * TupleLiteralPartCS returns VariableCS:
 *   name=simpleNameCS (":" type=typeCS)? "=" initExpression=OclExpressionCS;
 *
 **/

// name=simpleNameCS (":" type=typeCS)? "=" initExpression=OclExpressionCS
protected class TupleLiteralPartCS_Group extends GroupToken {
	
	public TupleLiteralPartCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTupleLiteralPartCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralPartCS_InitExpressionAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTupleLiteralPartCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=simpleNameCS
protected class TupleLiteralPartCS_NameAssignment_0 extends AssignmentToken  {
	
	public TupleLiteralPartCS_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTupleLiteralPartCSAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleNameCS_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleNameCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTupleLiteralPartCSAccess().getNameSimpleNameCSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (":" type=typeCS)?
protected class TupleLiteralPartCS_Group_1 extends GroupToken {
	
	public TupleLiteralPartCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTupleLiteralPartCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralPartCS_TypeAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class TupleLiteralPartCS_ColonKeyword_1_0 extends KeywordToken  {
	
	public TupleLiteralPartCS_ColonKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTupleLiteralPartCSAccess().getColonKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralPartCS_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=typeCS
protected class TupleLiteralPartCS_TypeAssignment_1_1 extends AssignmentToken  {
	
	public TupleLiteralPartCS_TypeAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTupleLiteralPartCSAccess().getTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTupleLiteralPartCSAccess().getTypeTypeCSParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TupleLiteralPartCS_ColonKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "="
protected class TupleLiteralPartCS_EqualsSignKeyword_2 extends KeywordToken  {
	
	public TupleLiteralPartCS_EqualsSignKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTupleLiteralPartCSAccess().getEqualsSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleLiteralPartCS_Group_1(parent, this, 0, inst);
			case 1: return new TupleLiteralPartCS_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// initExpression=OclExpressionCS
protected class TupleLiteralPartCS_InitExpressionAssignment_3 extends AssignmentToken  {
	
	public TupleLiteralPartCS_InitExpressionAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTupleLiteralPartCSAccess().getInitExpressionAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initExpression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTupleLiteralPartCSAccess().getInitExpressionOclExpressionCSParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TupleLiteralPartCS_EqualsSignKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule TupleLiteralPartCS ****************/


/************ begin Rule IntegerLiteralExpCS ****************
 *
 * IntegerLiteralExpCS:
 *   integerSymbol=INTEGER_LITERAL;
 *
 **/

// integerSymbol=INTEGER_LITERAL
protected class IntegerLiteralExpCS_IntegerSymbolAssignment extends AssignmentToken  {
	
	public IntegerLiteralExpCS_IntegerSymbolAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntegerLiteralExpCSAccess().getIntegerSymbolAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIntegerLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("integerSymbol",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("integerSymbol");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getIntegerLiteralExpCSAccess().getIntegerSymbolINTEGER_LITERALParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule IntegerLiteralExpCS ****************/


/************ begin Rule RealLiteralExpCS ****************
 *
 * RealLiteralExpCS:
 *   realSymbol=REAL_LITERAL;
 *
 **/

// realSymbol=REAL_LITERAL
protected class RealLiteralExpCS_RealSymbolAssignment extends AssignmentToken  {
	
	public RealLiteralExpCS_RealSymbolAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRealLiteralExpCSAccess().getRealSymbolAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRealLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("realSymbol",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("realSymbol");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getRealLiteralExpCSAccess().getRealSymbolREAL_LITERALParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule RealLiteralExpCS ****************/


/************ begin Rule StringLiteralExpCS ****************
 *
 * StringLiteralExpCS:
 *   stringSymbol+=STRING_LITERAL+;
 *
 **/

// stringSymbol+=STRING_LITERAL+
protected class StringLiteralExpCS_StringSymbolAssignment extends AssignmentToken  {
	
	public StringLiteralExpCS_StringSymbolAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStringLiteralExpCSAccess().getStringSymbolAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StringLiteralExpCS_StringSymbolAssignment(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStringLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("stringSymbol",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("stringSymbol");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getStringLiteralExpCSAccess().getStringSymbolSTRING_LITERALTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule StringLiteralExpCS ****************/


/************ begin Rule BooleanLiteralExpCS ****************
 *
 * BooleanLiteralExpCS:
 *   value="true"|value="false";
 *
 **/

// value="true"|value="false"
protected class BooleanLiteralExpCS_Alternatives extends AlternativesToken {

	public BooleanLiteralExpCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBooleanLiteralExpCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteralExpCS_ValueAssignment_0(parent, this, 0, inst);
			case 1: return new BooleanLiteralExpCS_ValueAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// value="true"
protected class BooleanLiteralExpCS_ValueAssignment_0 extends AssignmentToken  {
	
	public BooleanLiteralExpCS_ValueAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanLiteralExpCSAccess().getValueAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("true".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBooleanLiteralExpCSAccess().getValueTrueKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// value="false"
protected class BooleanLiteralExpCS_ValueAssignment_1 extends AssignmentToken  {
	
	public BooleanLiteralExpCS_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanLiteralExpCSAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if("false".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBooleanLiteralExpCSAccess().getValueFalseKeyword_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule BooleanLiteralExpCS ****************/


/************ begin Rule UnlimitedNaturalLiteralExpCS ****************
 *
 * UnlimitedNaturalLiteralExpCS:
 *   {UnlimitedNaturalLiteralExpCS} "*";
 *
 **/

// {UnlimitedNaturalLiteralExpCS} "*"
protected class UnlimitedNaturalLiteralExpCS_Group extends GroupToken {
	
	public UnlimitedNaturalLiteralExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnlimitedNaturalLiteralExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnlimitedNaturalLiteralExpCS_AsteriskKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnlimitedNaturalLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {UnlimitedNaturalLiteralExpCS}
protected class UnlimitedNaturalLiteralExpCS_UnlimitedNaturalLiteralExpCSAction_0 extends ActionToken  {

	public UnlimitedNaturalLiteralExpCS_UnlimitedNaturalLiteralExpCSAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUnlimitedNaturalLiteralExpCSAccess().getUnlimitedNaturalLiteralExpCSAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUnlimitedNaturalLiteralExpCSAccess().getUnlimitedNaturalLiteralExpCSAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "*"
protected class UnlimitedNaturalLiteralExpCS_AsteriskKeyword_1 extends KeywordToken  {
	
	public UnlimitedNaturalLiteralExpCS_AsteriskKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnlimitedNaturalLiteralExpCSAccess().getAsteriskKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnlimitedNaturalLiteralExpCS_UnlimitedNaturalLiteralExpCSAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule UnlimitedNaturalLiteralExpCS ****************/


/************ begin Rule InvalidLiteralExpCS ****************
 *
 * InvalidLiteralExpCS:
 *   {InvalidLiteralExpCS} "invalid";
 *
 **/

// {InvalidLiteralExpCS} "invalid"
protected class InvalidLiteralExpCS_Group extends GroupToken {
	
	public InvalidLiteralExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInvalidLiteralExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InvalidLiteralExpCS_InvalidKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInvalidLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {InvalidLiteralExpCS}
protected class InvalidLiteralExpCS_InvalidLiteralExpCSAction_0 extends ActionToken  {

	public InvalidLiteralExpCS_InvalidLiteralExpCSAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getInvalidLiteralExpCSAccess().getInvalidLiteralExpCSAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getInvalidLiteralExpCSAccess().getInvalidLiteralExpCSAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "invalid"
protected class InvalidLiteralExpCS_InvalidKeyword_1 extends KeywordToken  {
	
	public InvalidLiteralExpCS_InvalidKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInvalidLiteralExpCSAccess().getInvalidKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InvalidLiteralExpCS_InvalidLiteralExpCSAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule InvalidLiteralExpCS ****************/


/************ begin Rule NullLiteralExpCS ****************
 *
 * NullLiteralExpCS:
 *   {NullLiteralExpCS} "null";
 *
 **/

// {NullLiteralExpCS} "null"
protected class NullLiteralExpCS_Group extends GroupToken {
	
	public NullLiteralExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNullLiteralExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteralExpCS_NullKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNullLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {NullLiteralExpCS}
protected class NullLiteralExpCS_NullLiteralExpCSAction_0 extends ActionToken  {

	public NullLiteralExpCS_NullLiteralExpCSAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNullLiteralExpCSAccess().getNullLiteralExpCSAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getNullLiteralExpCSAccess().getNullLiteralExpCSAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "null"
protected class NullLiteralExpCS_NullKeyword_1 extends KeywordToken  {
	
	public NullLiteralExpCS_NullKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNullLiteralExpCSAccess().getNullKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteralExpCS_NullLiteralExpCSAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule NullLiteralExpCS ****************/


/************ begin Rule TypeLiteralExpCS ****************
 *
 * TypeLiteralExpCS:
 *   pathNameCS|primitiveTypeCS|tupleTypeCS; 
 *     
 *     
 * 	
 * 	 
 * //|	collectionTypeCS
 * 	 
 * 
 * //---------------------------------------------------------------------
 * //  Expressions
 * //---------------------------------------------------------------------
 * // An OclExpressionCS comprising one or more LetExpCS is kept separate to ensure
 * //  that let is right associative, whereas infix operators are left associative.
 * //   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
 * // is
 * //   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
 *
 **/

// pathNameCS|primitiveTypeCS|tupleTypeCS 
//     
//     
// 	
// 	 
// //|	collectionTypeCS
// 	 
// 
// //---------------------------------------------------------------------
// //  Expressions
// //---------------------------------------------------------------------
// // An OclExpressionCS comprising one or more LetExpCS is kept separate to ensure
// //  that let is right associative, whereas infix operators are left associative.
// //   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
// // is
// //   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
protected class TypeLiteralExpCS_Alternatives extends AlternativesToken {

	public TypeLiteralExpCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeLiteralExpCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeLiteralExpCS_PathNameCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TypeLiteralExpCS_PrimitiveTypeCSParserRuleCall_1(parent, this, 1, inst);
			case 2: return new TypeLiteralExpCS_TupleTypeCSParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeLiteralExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// pathNameCS
protected class TypeLiteralExpCS_PathNameCSParserRuleCall_0 extends RuleCallToken {
	
	public TypeLiteralExpCS_PathNameCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeLiteralExpCSAccess().getPathNameCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PathNameCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PathNameCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPathNameCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// primitiveTypeCS 	 
// //|	collectionTypeCS
protected class TypeLiteralExpCS_PrimitiveTypeCSParserRuleCall_1 extends RuleCallToken {
	
	public TypeLiteralExpCS_PrimitiveTypeCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeLiteralExpCSAccess().getPrimitiveTypeCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimitiveTypeCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrimitiveTypeCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrimitiveTypeCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// tupleTypeCS
protected class TypeLiteralExpCS_TupleTypeCSParserRuleCall_2 extends RuleCallToken {
	
	public TypeLiteralExpCS_TupleTypeCSParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeLiteralExpCSAccess().getTupleTypeCSParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TupleTypeCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TupleTypeCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTupleTypeCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TypeLiteralExpCS ****************/


/************ begin Rule OclExpressionCS ****************
 *
 * OclExpressionCS:
 *   impliesCS|LetExpCS; 
 * 
 * //---------------------------------------------------------------------
 * //  Expressions
 * //---------------------------------------------------------------------
 * // An OclExpressionCS comprising one or more LetExpCS is kept separate to ensure
 * //  that let is right associative, whereas infix operators are left associative.
 * //   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
 * // is
 * //   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
 *
 **/

// impliesCS|LetExpCS 
// 
// //---------------------------------------------------------------------
// //  Expressions
// //---------------------------------------------------------------------
// // An OclExpressionCS comprising one or more LetExpCS is kept separate to ensure
// //  that let is right associative, whereas infix operators are left associative.
// //   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
// // is
// //   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
protected class OclExpressionCS_Alternatives extends AlternativesToken {

	public OclExpressionCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getOclExpressionCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_ImpliesCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new OclExpressionCS_LetExpCSParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// impliesCS
protected class OclExpressionCS_ImpliesCSParserRuleCall_0 extends RuleCallToken {
	
	public OclExpressionCS_ImpliesCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOclExpressionCSAccess().getImpliesCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ImpliesCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ImpliesCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getImpliesCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// LetExpCS
protected class OclExpressionCS_LetExpCSParserRuleCall_1 extends RuleCallToken {
	
	public OclExpressionCS_LetExpCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOclExpressionCSAccess().getLetExpCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LetExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule OclExpressionCS ****************/


/************ begin Rule impliesCS ****************
 *
 * impliesCS returns OclExpressionCS:
 *   xorCS ({BinaryExpressionCS.source=current} op="implies" argument=( impliesCS |
 *   LetExpCS ))?;
 *
 **/

// xorCS ({BinaryExpressionCS.source=current} op="implies" argument=( impliesCS |
// LetExpCS ))?
protected class ImpliesCS_Group extends GroupToken {
	
	public ImpliesCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getImpliesCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ImpliesCS_Group_1(parent, this, 0, inst);
			case 1: return new ImpliesCS_XorCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getImpliesCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// xorCS
protected class ImpliesCS_XorCSParserRuleCall_0 extends RuleCallToken {
	
	public ImpliesCS_XorCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getImpliesCSAccess().getXorCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(XorCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getXorCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryExpressionCS.source=current} op="implies" argument=( impliesCS | LetExpCS ))?
protected class ImpliesCS_Group_1 extends GroupToken {
	
	public ImpliesCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getImpliesCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ImpliesCS_ArgumentAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryExpressionCS.source=current}
protected class ImpliesCS_BinaryExpressionCSSourceAction_1_0 extends ActionToken  {

	public ImpliesCS_BinaryExpressionCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getImpliesCSAccess().getBinaryExpressionCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ImpliesCS_XorCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getImpliesCSAccess().getBinaryExpressionCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// op="implies"
protected class ImpliesCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public ImpliesCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getImpliesCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ImpliesCS_BinaryExpressionCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if("implies".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getImpliesCSAccess().getOpImpliesKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// argument=( impliesCS | LetExpCS )
protected class ImpliesCS_ArgumentAssignment_1_2 extends AssignmentToken  {
	
	public ImpliesCS_ArgumentAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getImpliesCSAccess().getArgumentAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ImpliesCS_Group(this, this, 0, inst);
			case 1: return new LetExpCS_Group(this, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("argument",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("argument");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getImpliesCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getImpliesCSAccess().getArgumentImpliesCSParserRuleCall_1_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getImpliesCSAccess().getArgumentLetExpCSParserRuleCall_1_2_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ImpliesCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule impliesCS ****************/


/************ begin Rule xorCS ****************
 *
 * xorCS returns OclExpressionCS:
 *   orCS ({BinaryExpressionCS.source=current} op="xor" argument=( xorCS | LetExpCS ))?;
 *
 **/

// orCS ({BinaryExpressionCS.source=current} op="xor" argument=( xorCS | LetExpCS ))?
protected class XorCS_Group extends GroupToken {
	
	public XorCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getXorCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorCS_Group_1(parent, this, 0, inst);
			case 1: return new XorCS_OrCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getXorCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// orCS
protected class XorCS_OrCSParserRuleCall_0 extends RuleCallToken {
	
	public XorCS_OrCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getXorCSAccess().getOrCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryExpressionCS.source=current} op="xor" argument=( xorCS | LetExpCS ))?
protected class XorCS_Group_1 extends GroupToken {
	
	public XorCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getXorCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorCS_ArgumentAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryExpressionCS.source=current}
protected class XorCS_BinaryExpressionCSSourceAction_1_0 extends ActionToken  {

	public XorCS_BinaryExpressionCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getXorCSAccess().getBinaryExpressionCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorCS_OrCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getXorCSAccess().getBinaryExpressionCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// op="xor"
protected class XorCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public XorCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getXorCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorCS_BinaryExpressionCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if("xor".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getXorCSAccess().getOpXorKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// argument=( xorCS | LetExpCS )
protected class XorCS_ArgumentAssignment_1_2 extends AssignmentToken  {
	
	public XorCS_ArgumentAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getXorCSAccess().getArgumentAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new XorCS_Group(this, this, 0, inst);
			case 1: return new LetExpCS_Group(this, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("argument",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("argument");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getXorCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getXorCSAccess().getArgumentXorCSParserRuleCall_1_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getXorCSAccess().getArgumentLetExpCSParserRuleCall_1_2_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new XorCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule xorCS ****************/


/************ begin Rule orCS ****************
 *
 * orCS returns OclExpressionCS:
 *   andCS ({BinaryExpressionCS.source=current} op="or" argument=( orCS | LetExpCS ))?;
 *
 **/

// andCS ({BinaryExpressionCS.source=current} op="or" argument=( orCS | LetExpCS ))?
protected class OrCS_Group extends GroupToken {
	
	public OrCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrCS_Group_1(parent, this, 0, inst);
			case 1: return new OrCS_AndCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// andCS
protected class OrCS_AndCSParserRuleCall_0 extends RuleCallToken {
	
	public OrCS_AndCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrCSAccess().getAndCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryExpressionCS.source=current} op="or" argument=( orCS | LetExpCS ))?
protected class OrCS_Group_1 extends GroupToken {
	
	public OrCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrCS_ArgumentAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryExpressionCS.source=current}
protected class OrCS_BinaryExpressionCSSourceAction_1_0 extends ActionToken  {

	public OrCS_BinaryExpressionCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOrCSAccess().getBinaryExpressionCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrCS_AndCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOrCSAccess().getBinaryExpressionCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// op="or"
protected class OrCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public OrCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrCS_BinaryExpressionCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if("or".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getOrCSAccess().getOpOrKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// argument=( orCS | LetExpCS )
protected class OrCS_ArgumentAssignment_1_2 extends AssignmentToken  {
	
	public OrCS_ArgumentAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrCSAccess().getArgumentAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrCS_Group(this, this, 0, inst);
			case 1: return new LetExpCS_Group(this, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("argument",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("argument");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrCSAccess().getArgumentOrCSParserRuleCall_1_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrCSAccess().getArgumentLetExpCSParserRuleCall_1_2_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule orCS ****************/


/************ begin Rule andCS ****************
 *
 * andCS returns OclExpressionCS:
 *   equalityCS ({BinaryExpressionCS.source=current} op="and" argument=( andCS | LetExpCS ))
 *   ?;
 *
 **/

// equalityCS ({BinaryExpressionCS.source=current} op="and" argument=( andCS | LetExpCS ))
// ?
protected class AndCS_Group extends GroupToken {
	
	public AndCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndCS_Group_1(parent, this, 0, inst);
			case 1: return new AndCS_EqualityCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// equalityCS
protected class AndCS_EqualityCSParserRuleCall_0 extends RuleCallToken {
	
	public AndCS_EqualityCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndCSAccess().getEqualityCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EqualityCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEqualityCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryExpressionCS.source=current} op="and" argument=( andCS | LetExpCS ))?
protected class AndCS_Group_1 extends GroupToken {
	
	public AndCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndCS_ArgumentAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryExpressionCS.source=current}
protected class AndCS_BinaryExpressionCSSourceAction_1_0 extends ActionToken  {

	public AndCS_BinaryExpressionCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAndCSAccess().getBinaryExpressionCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndCS_EqualityCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAndCSAccess().getBinaryExpressionCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// op="and"
protected class AndCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public AndCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndCS_BinaryExpressionCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if("and".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAndCSAccess().getOpAndKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// argument=( andCS | LetExpCS )
protected class AndCS_ArgumentAssignment_1_2 extends AssignmentToken  {
	
	public AndCS_ArgumentAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndCSAccess().getArgumentAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndCS_Group(this, this, 0, inst);
			case 1: return new LetExpCS_Group(this, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("argument",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("argument");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndCSAccess().getArgumentAndCSParserRuleCall_1_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndCSAccess().getArgumentLetExpCSParserRuleCall_1_2_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule andCS ****************/


/************ begin Rule equalityCS ****************
 *
 * equalityCS returns OclExpressionCS:
 *   relationalCS ({BinaryExpressionCS.source=current} op=( "=" | "<>" ) argument=(
 *   equalityCS | LetExpCS ))?;
 *
 **/

// relationalCS ({BinaryExpressionCS.source=current} op=( "=" | "<>" ) argument=(
// equalityCS | LetExpCS ))?
protected class EqualityCS_Group extends GroupToken {
	
	public EqualityCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEqualityCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityCS_Group_1(parent, this, 0, inst);
			case 1: return new EqualityCS_RelationalCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEqualityCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// relationalCS
protected class EqualityCS_RelationalCSParserRuleCall_0 extends RuleCallToken {
	
	public EqualityCS_RelationalCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEqualityCSAccess().getRelationalCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RelationalCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRelationalCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryExpressionCS.source=current} op=( "=" | "<>" ) argument=( equalityCS | LetExpCS ))
// ?
protected class EqualityCS_Group_1 extends GroupToken {
	
	public EqualityCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEqualityCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityCS_ArgumentAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryExpressionCS.source=current}
protected class EqualityCS_BinaryExpressionCSSourceAction_1_0 extends ActionToken  {

	public EqualityCS_BinaryExpressionCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getEqualityCSAccess().getBinaryExpressionCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityCS_RelationalCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getEqualityCSAccess().getBinaryExpressionCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// op=( "=" | "<>" )
protected class EqualityCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public EqualityCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualityCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityCS_BinaryExpressionCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if("=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getEqualityCSAccess().getOpEqualsSignKeyword_1_1_0_0();
			return obj;
		}
		if("<>".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getEqualityCSAccess().getOpLessThanSignGreaterThanSignKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// argument=( equalityCS | LetExpCS )
protected class EqualityCS_ArgumentAssignment_1_2 extends AssignmentToken  {
	
	public EqualityCS_ArgumentAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualityCSAccess().getArgumentAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityCS_Group(this, this, 0, inst);
			case 1: return new LetExpCS_Group(this, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("argument",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("argument");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEqualityCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEqualityCSAccess().getArgumentEqualityCSParserRuleCall_1_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEqualityCSAccess().getArgumentLetExpCSParserRuleCall_1_2_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EqualityCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule equalityCS ****************/


/************ begin Rule relationalCS ****************
 *
 * relationalCS returns OclExpressionCS:
 *   additiveCS ({BinaryExpressionCS.source=current} op=( ">" | "<" | ">=" | "<=" ) argument=(
 *   relationalCS | LetExpCS ))?;
 *
 **/

// additiveCS ({BinaryExpressionCS.source=current} op=( ">" | "<" | ">=" | "<=" ) argument=(
// relationalCS | LetExpCS ))?
protected class RelationalCS_Group extends GroupToken {
	
	public RelationalCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalCS_Group_1(parent, this, 0, inst);
			case 1: return new RelationalCS_AdditiveCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRelationalCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// additiveCS
protected class RelationalCS_AdditiveCSParserRuleCall_0 extends RuleCallToken {
	
	public RelationalCS_AdditiveCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalCSAccess().getAdditiveCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AdditiveCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAdditiveCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryExpressionCS.source=current} op=( ">" | "<" | ">=" | "<=" ) argument=( relationalCS
// | LetExpCS ))?
protected class RelationalCS_Group_1 extends GroupToken {
	
	public RelationalCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalCS_ArgumentAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryExpressionCS.source=current}
protected class RelationalCS_BinaryExpressionCSSourceAction_1_0 extends ActionToken  {

	public RelationalCS_BinaryExpressionCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRelationalCSAccess().getBinaryExpressionCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalCS_AdditiveCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRelationalCSAccess().getBinaryExpressionCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// op=( ">" | "<" | ">=" | "<=" )
protected class RelationalCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public RelationalCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalCS_BinaryExpressionCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if(">".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalCSAccess().getOpGreaterThanSignKeyword_1_1_0_0();
			return obj;
		}
		if("<".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalCSAccess().getOpLessThanSignKeyword_1_1_0_1();
			return obj;
		}
		if(">=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalCSAccess().getOpGreaterThanSignEqualsSignKeyword_1_1_0_2();
			return obj;
		}
		if("<=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalCSAccess().getOpLessThanSignEqualsSignKeyword_1_1_0_3();
			return obj;
		}
		return null;
	}

}

// argument=( relationalCS | LetExpCS )
protected class RelationalCS_ArgumentAssignment_1_2 extends AssignmentToken  {
	
	public RelationalCS_ArgumentAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalCSAccess().getArgumentAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalCS_Group(this, this, 0, inst);
			case 1: return new LetExpCS_Group(this, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("argument",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("argument");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRelationalCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalCSAccess().getArgumentRelationalCSParserRuleCall_1_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalCSAccess().getArgumentLetExpCSParserRuleCall_1_2_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule relationalCS ****************/


/************ begin Rule additiveCS ****************
 *
 * additiveCS returns OclExpressionCS:
 *   multiplicativeCS ({BinaryExpressionCS.source=current} op=( "+" | "-" ) argument=(
 *   additiveCS | LetExpCS ))?;
 *
 **/

// multiplicativeCS ({BinaryExpressionCS.source=current} op=( "+" | "-" ) argument=(
// additiveCS | LetExpCS ))?
protected class AdditiveCS_Group extends GroupToken {
	
	public AdditiveCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveCS_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveCS_MultiplicativeCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// multiplicativeCS
protected class AdditiveCS_MultiplicativeCSParserRuleCall_0 extends RuleCallToken {
	
	public AdditiveCS_MultiplicativeCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAdditiveCSAccess().getMultiplicativeCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(MultiplicativeCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryExpressionCS.source=current} op=( "+" | "-" ) argument=( additiveCS | LetExpCS ))?
protected class AdditiveCS_Group_1 extends GroupToken {
	
	public AdditiveCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveCS_ArgumentAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryExpressionCS.source=current}
protected class AdditiveCS_BinaryExpressionCSSourceAction_1_0 extends ActionToken  {

	public AdditiveCS_BinaryExpressionCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAdditiveCSAccess().getBinaryExpressionCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveCS_MultiplicativeCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveCSAccess().getBinaryExpressionCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// op=( "+" | "-" )
protected class AdditiveCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public AdditiveCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveCS_BinaryExpressionCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditiveCSAccess().getOpPlusSignKeyword_1_1_0_0();
			return obj;
		}
		if("-".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditiveCSAccess().getOpHyphenMinusKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// argument=( additiveCS | LetExpCS )
protected class AdditiveCS_ArgumentAssignment_1_2 extends AssignmentToken  {
	
	public AdditiveCS_ArgumentAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveCSAccess().getArgumentAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveCS_Group(this, this, 0, inst);
			case 1: return new LetExpCS_Group(this, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("argument",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("argument");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveCSAccess().getArgumentAdditiveCSParserRuleCall_1_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveCSAccess().getArgumentLetExpCSParserRuleCall_1_2_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AdditiveCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule additiveCS ****************/


/************ begin Rule multiplicativeCS ****************
 *
 * multiplicativeCS returns OclExpressionCS:
 *   unaryCS ({BinaryExpressionCS.source=current} op=( "*" | "/" ) argument=(
 *   multiplicativeCS | LetExpCS ))?;
 *
 **/

// unaryCS ({BinaryExpressionCS.source=current} op=( "*" | "/" ) argument=(
// multiplicativeCS | LetExpCS ))?
protected class MultiplicativeCS_Group extends GroupToken {
	
	public MultiplicativeCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeCS_Group_1(parent, this, 0, inst);
			case 1: return new MultiplicativeCS_UnaryCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// unaryCS
protected class MultiplicativeCS_UnaryCSParserRuleCall_0 extends RuleCallToken {
	
	public MultiplicativeCS_UnaryCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMultiplicativeCSAccess().getUnaryCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UnaryCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUnaryCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryExpressionCS.source=current} op=( "*" | "/" ) argument=( multiplicativeCS |
// LetExpCS ))?
protected class MultiplicativeCS_Group_1 extends GroupToken {
	
	public MultiplicativeCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeCS_ArgumentAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryExpressionCS.source=current}
protected class MultiplicativeCS_BinaryExpressionCSSourceAction_1_0 extends ActionToken  {

	public MultiplicativeCS_BinaryExpressionCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getMultiplicativeCSAccess().getBinaryExpressionCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeCS_UnaryCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeCSAccess().getBinaryExpressionCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// op=( "*" | "/" )
protected class MultiplicativeCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public MultiplicativeCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeCS_BinaryExpressionCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeCSAccess().getOpAsteriskKeyword_1_1_0_0();
			return obj;
		}
		if("/".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeCSAccess().getOpSolidusKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// argument=( multiplicativeCS | LetExpCS )
protected class MultiplicativeCS_ArgumentAssignment_1_2 extends AssignmentToken  {
	
	public MultiplicativeCS_ArgumentAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeCSAccess().getArgumentAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeCS_Group(this, this, 0, inst);
			case 1: return new LetExpCS_Group(this, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("argument",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("argument");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplicativeCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplicativeCSAccess().getArgumentMultiplicativeCSParserRuleCall_1_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplicativeCSAccess().getArgumentLetExpCSParserRuleCall_1_2_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MultiplicativeCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule multiplicativeCS ****************/


/************ begin Rule unaryCS ****************
 *
 * unaryCS returns OclExpressionCS:
 *   callingExpCS|{UnaryExpressionCS} op=( "-" | "not" ) source=unaryCS;
 *
 **/

// callingExpCS|{UnaryExpressionCS} op=( "-" | "not" ) source=unaryCS
protected class UnaryCS_Alternatives extends AlternativesToken {

	public UnaryCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getUnaryCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryCS_CallingExpCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new UnaryCS_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnaryCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// callingExpCS
protected class UnaryCS_CallingExpCSParserRuleCall_0 extends RuleCallToken {
	
	public UnaryCS_CallingExpCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryCSAccess().getCallingExpCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallingExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CallingExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCallingExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// {UnaryExpressionCS} op=( "-" | "not" ) source=unaryCS
protected class UnaryCS_Group_1 extends GroupToken {
	
	public UnaryCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryCS_SourceAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {UnaryExpressionCS}
protected class UnaryCS_UnaryExpressionCSAction_1_0 extends ActionToken  {

	public UnaryCS_UnaryExpressionCSAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUnaryCSAccess().getUnaryExpressionCSAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUnaryCSAccess().getUnaryExpressionCSAction_1_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// op=( "-" | "not" )
protected class UnaryCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public UnaryCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryCS_UnaryExpressionCSAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if("-".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnaryCSAccess().getOpHyphenMinusKeyword_1_1_0_0();
			return obj;
		}
		if("not".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnaryCSAccess().getOpNotKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// source=unaryCS
protected class UnaryCS_SourceAssignment_1_2 extends AssignmentToken  {
	
	public UnaryCS_SourceAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryCSAccess().getSourceAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("source",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("source");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryCSAccess().getSourceUnaryCSParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule unaryCS ****************/


/************ begin Rule callingExpCS ****************
 *
 * callingExpCS returns OclExpressionCS:
 *   callExpCS ({BinaryExpressionCS.source=current} op=( "." | "->" ) argument=callingExpCS)
 *   ?;
 *
 **/

// callExpCS ({BinaryExpressionCS.source=current} op=( "." | "->" ) argument=callingExpCS)
// ?
protected class CallingExpCS_Group extends GroupToken {
	
	public CallingExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallingExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallingExpCS_Group_1(parent, this, 0, inst);
			case 1: return new CallingExpCS_CallExpCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCallingExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// callExpCS
protected class CallingExpCS_CallExpCSParserRuleCall_0 extends RuleCallToken {
	
	public CallingExpCS_CallExpCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCallingExpCSAccess().getCallExpCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CallExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCallExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryExpressionCS.source=current} op=( "." | "->" ) argument=callingExpCS)?
protected class CallingExpCS_Group_1 extends GroupToken {
	
	public CallingExpCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallingExpCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallingExpCS_ArgumentAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryExpressionCS.source=current}
protected class CallingExpCS_BinaryExpressionCSSourceAction_1_0 extends ActionToken  {

	public CallingExpCS_BinaryExpressionCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCallingExpCSAccess().getBinaryExpressionCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallingExpCS_CallExpCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCallingExpCSAccess().getBinaryExpressionCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// op=( "." | "->" )
protected class CallingExpCS_OpAssignment_1_1 extends AssignmentToken  {
	
	public CallingExpCS_OpAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallingExpCSAccess().getOpAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallingExpCS_BinaryExpressionCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if(".".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getCallingExpCSAccess().getOpFullStopKeyword_1_1_0_0();
			return obj;
		}
		if("->".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getCallingExpCSAccess().getOpHyphenMinusGreaterThanSignKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// argument=callingExpCS
protected class CallingExpCS_ArgumentAssignment_1_2 extends AssignmentToken  {
	
	public CallingExpCS_ArgumentAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallingExpCSAccess().getArgumentAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallingExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("argument",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("argument");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCallingExpCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCallingExpCSAccess().getArgumentCallingExpCSParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CallingExpCS_OpAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule callingExpCS ****************/


/************ begin Rule iteratorVariableCS ****************
 *
 * iteratorVariableCS returns VariableCS:
 *   name=simpleNameCS (":" type=typeCS)?;
 *
 **/

// name=simpleNameCS (":" type=typeCS)?
protected class IteratorVariableCS_Group extends GroupToken {
	
	public IteratorVariableCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIteratorVariableCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IteratorVariableCS_Group_1(parent, this, 0, inst);
			case 1: return new IteratorVariableCS_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIteratorVariableCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=simpleNameCS
protected class IteratorVariableCS_NameAssignment_0 extends AssignmentToken  {
	
	public IteratorVariableCS_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIteratorVariableCSAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleNameCS_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleNameCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIteratorVariableCSAccess().getNameSimpleNameCSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (":" type=typeCS)?
protected class IteratorVariableCS_Group_1 extends GroupToken {
	
	public IteratorVariableCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIteratorVariableCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IteratorVariableCS_TypeAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class IteratorVariableCS_ColonKeyword_1_0 extends KeywordToken  {
	
	public IteratorVariableCS_ColonKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIteratorVariableCSAccess().getColonKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IteratorVariableCS_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=typeCS
protected class IteratorVariableCS_TypeAssignment_1_1 extends AssignmentToken  {
	
	public IteratorVariableCS_TypeAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIteratorVariableCSAccess().getTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIteratorVariableCSAccess().getTypeTypeCSParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IteratorVariableCS_ColonKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule iteratorVariableCS ****************/


/************ begin Rule iteratorAccumulatorCS ****************
 *
 * iteratorAccumulatorCS returns VariableCS:
 *   name=simpleNameCS ":" type=typeCS "=" initExpression=OclExpressionCS;
 *
 **/

// name=simpleNameCS ":" type=typeCS "=" initExpression=OclExpressionCS
protected class IteratorAccumulatorCS_Group extends GroupToken {
	
	public IteratorAccumulatorCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIteratorAccumulatorCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IteratorAccumulatorCS_InitExpressionAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIteratorAccumulatorCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=simpleNameCS
protected class IteratorAccumulatorCS_NameAssignment_0 extends AssignmentToken  {
	
	public IteratorAccumulatorCS_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIteratorAccumulatorCSAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleNameCS_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleNameCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIteratorAccumulatorCSAccess().getNameSimpleNameCSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ":"
protected class IteratorAccumulatorCS_ColonKeyword_1 extends KeywordToken  {
	
	public IteratorAccumulatorCS_ColonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIteratorAccumulatorCSAccess().getColonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IteratorAccumulatorCS_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=typeCS
protected class IteratorAccumulatorCS_TypeAssignment_2 extends AssignmentToken  {
	
	public IteratorAccumulatorCS_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIteratorAccumulatorCSAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIteratorAccumulatorCSAccess().getTypeTypeCSParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IteratorAccumulatorCS_ColonKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "="
protected class IteratorAccumulatorCS_EqualsSignKeyword_3 extends KeywordToken  {
	
	public IteratorAccumulatorCS_EqualsSignKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIteratorAccumulatorCSAccess().getEqualsSignKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IteratorAccumulatorCS_TypeAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initExpression=OclExpressionCS
protected class IteratorAccumulatorCS_InitExpressionAssignment_4 extends AssignmentToken  {
	
	public IteratorAccumulatorCS_InitExpressionAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIteratorAccumulatorCSAccess().getInitExpressionAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initExpression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIteratorAccumulatorCSAccess().getInitExpressionOclExpressionCSParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IteratorAccumulatorCS_EqualsSignKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule iteratorAccumulatorCS ****************/


/************ begin Rule callExpCS ****************
 *
 * callExpCS returns OclExpressionCS:
 *   preExpCS ({CallExpCS.source=current} "(" (variable1=iteratorVariableCS ("," variable2
 *   =iteratorVariableCS|";" variable2=iteratorAccumulatorCS)? "|")? (arguments+=
 *   OclExpressionCS ("," arguments+=OclExpressionCS)*)? ")")?;
 *
 **/

// preExpCS ({CallExpCS.source=current} "(" (variable1=iteratorVariableCS ("," variable2
// =iteratorVariableCS|";" variable2=iteratorAccumulatorCS)? "|")? (arguments+=
// OclExpressionCS ("," arguments+=OclExpressionCS)*)? ")")?
protected class CallExpCS_Group extends GroupToken {
	
	public CallExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Group_1(parent, this, 0, inst);
			case 1: return new CallExpCS_PreExpCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCallExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// preExpCS
protected class CallExpCS_PreExpCSParserRuleCall_0 extends RuleCallToken {
	
	public CallExpCS_PreExpCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getPreExpCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PreExpCS_IndexExpCSParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PreExpCS_IndexExpCSParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPreExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({CallExpCS.source=current} "(" (variable1=iteratorVariableCS ("," variable2=
// iteratorVariableCS|";" variable2=iteratorAccumulatorCS)? "|")? (arguments+=
// OclExpressionCS ("," arguments+=OclExpressionCS)*)? ")")?
protected class CallExpCS_Group_1 extends GroupToken {
	
	public CallExpCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_RightParenthesisKeyword_1_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {CallExpCS.source=current}
protected class CallExpCS_CallExpCSSourceAction_1_0 extends ActionToken  {

	public CallExpCS_CallExpCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getCallExpCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_PreExpCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCallExpCSAccess().getCallExpCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// "("
protected class CallExpCS_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public CallExpCS_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getLeftParenthesisKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_CallExpCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (variable1=iteratorVariableCS ("," variable2=iteratorVariableCS|";" variable2=
// iteratorAccumulatorCS)? "|")?
protected class CallExpCS_Group_1_2 extends GroupToken {
	
	public CallExpCS_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_VerticalLineKeyword_1_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// variable1=iteratorVariableCS
protected class CallExpCS_Variable1Assignment_1_2_0 extends AssignmentToken  {
	
	public CallExpCS_Variable1Assignment_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getVariable1Assignment_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IteratorVariableCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIteratorVariableCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCallExpCSAccess().getVariable1IteratorVariableCSParserRuleCall_1_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CallExpCS_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," variable2=iteratorVariableCS|";" variable2=iteratorAccumulatorCS)?
protected class CallExpCS_Alternatives_1_2_1 extends AlternativesToken {

	public CallExpCS_Alternatives_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getAlternatives_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Group_1_2_1_0(parent, this, 0, inst);
			case 1: return new CallExpCS_Group_1_2_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "," variable2=iteratorVariableCS
protected class CallExpCS_Group_1_2_1_0 extends GroupToken {
	
	public CallExpCS_Group_1_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getGroup_1_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Variable2Assignment_1_2_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class CallExpCS_CommaKeyword_1_2_1_0_0 extends KeywordToken  {
	
	public CallExpCS_CommaKeyword_1_2_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getCommaKeyword_1_2_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Variable1Assignment_1_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// variable2=iteratorVariableCS
protected class CallExpCS_Variable2Assignment_1_2_1_0_1 extends AssignmentToken  {
	
	public CallExpCS_Variable2Assignment_1_2_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getVariable2Assignment_1_2_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IteratorVariableCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIteratorVariableCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCallExpCSAccess().getVariable2IteratorVariableCSParserRuleCall_1_2_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CallExpCS_CommaKeyword_1_2_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ";" variable2=iteratorAccumulatorCS
protected class CallExpCS_Group_1_2_1_1 extends GroupToken {
	
	public CallExpCS_Group_1_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getGroup_1_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Variable2Assignment_1_2_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ";"
protected class CallExpCS_SemicolonKeyword_1_2_1_1_0 extends KeywordToken  {
	
	public CallExpCS_SemicolonKeyword_1_2_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getSemicolonKeyword_1_2_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Variable1Assignment_1_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// variable2=iteratorAccumulatorCS
protected class CallExpCS_Variable2Assignment_1_2_1_1_1 extends AssignmentToken  {
	
	public CallExpCS_Variable2Assignment_1_2_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getVariable2Assignment_1_2_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IteratorAccumulatorCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIteratorAccumulatorCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCallExpCSAccess().getVariable2IteratorAccumulatorCSParserRuleCall_1_2_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CallExpCS_SemicolonKeyword_1_2_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "|"
protected class CallExpCS_VerticalLineKeyword_1_2_2 extends KeywordToken  {
	
	public CallExpCS_VerticalLineKeyword_1_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getVerticalLineKeyword_1_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Alternatives_1_2_1(parent, this, 0, inst);
			case 1: return new CallExpCS_Variable1Assignment_1_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// (arguments+=OclExpressionCS ("," arguments+=OclExpressionCS)*)?
protected class CallExpCS_Group_1_3 extends GroupToken {
	
	public CallExpCS_Group_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getGroup_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Group_1_3_1(parent, this, 0, inst);
			case 1: return new CallExpCS_ArgumentsAssignment_1_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// arguments+=OclExpressionCS
protected class CallExpCS_ArgumentsAssignment_1_3_0 extends AssignmentToken  {
	
	public CallExpCS_ArgumentsAssignment_1_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getArgumentsAssignment_1_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arguments",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCallExpCSAccess().getArgumentsOclExpressionCSParserRuleCall_1_3_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CallExpCS_Group_1_2(parent, next, actIndex, consumed);
			case 1: return new CallExpCS_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," arguments+=OclExpressionCS)*
protected class CallExpCS_Group_1_3_1 extends GroupToken {
	
	public CallExpCS_Group_1_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getGroup_1_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_ArgumentsAssignment_1_3_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class CallExpCS_CommaKeyword_1_3_1_0 extends KeywordToken  {
	
	public CallExpCS_CommaKeyword_1_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getCommaKeyword_1_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Group_1_3_1(parent, this, 0, inst);
			case 1: return new CallExpCS_ArgumentsAssignment_1_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// arguments+=OclExpressionCS
protected class CallExpCS_ArgumentsAssignment_1_3_1_1 extends AssignmentToken  {
	
	public CallExpCS_ArgumentsAssignment_1_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getArgumentsAssignment_1_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arguments",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCallExpCSAccess().getArgumentsOclExpressionCSParserRuleCall_1_3_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CallExpCS_CommaKeyword_1_3_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class CallExpCS_RightParenthesisKeyword_1_4 extends KeywordToken  {
	
	public CallExpCS_RightParenthesisKeyword_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCallExpCSAccess().getRightParenthesisKeyword_1_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CallExpCS_Group_1_3(parent, this, 0, inst);
			case 1: return new CallExpCS_Group_1_2(parent, this, 1, inst);
			case 2: return new CallExpCS_LeftParenthesisKeyword_1_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule callExpCS ****************/


/************ begin Rule preExpCS ****************
 *
 * preExpCS returns OclExpressionCS:
 *   indexExpCS; 
 * 
 *     
 * 	
 * //  ({UnaryExpressionCS.source=current} '@' op='pre')?
 *
 **/

// indexExpCS 
// 	
// //  ({UnaryExpressionCS.source=current} '@' op='pre')?
protected class PreExpCS_IndexExpCSParserRuleCall extends RuleCallToken {
	
	public PreExpCS_IndexExpCSParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPreExpCSAccess().getIndexExpCSParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IndexExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPreExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IndexExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIndexExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule preExpCS ****************/


/************ begin Rule indexExpCS ****************
 *
 * indexExpCS returns OclExpressionCS:
 *   messageExpCS ({IndexExpCS.source=current} "[" indexes+=OclExpressionCS ("," indexes+=
 *   OclExpressionCS)* "]")?;
 *
 **/

// messageExpCS ({IndexExpCS.source=current} "[" indexes+=OclExpressionCS ("," indexes+=
// OclExpressionCS)* "]")?
protected class IndexExpCS_Group extends GroupToken {
	
	public IndexExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IndexExpCS_Group_1(parent, this, 0, inst);
			case 1: return new IndexExpCS_MessageExpCSParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIndexExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// messageExpCS
protected class IndexExpCS_MessageExpCSParserRuleCall_0 extends RuleCallToken {
	
	public IndexExpCS_MessageExpCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getMessageExpCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MessageExpCS_PrimaryExpCSParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(MessageExpCS_PrimaryExpCSParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMessageExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({IndexExpCS.source=current} "[" indexes+=OclExpressionCS ("," indexes+=
// OclExpressionCS)* "]")?
protected class IndexExpCS_Group_1 extends GroupToken {
	
	public IndexExpCS_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IndexExpCS_RightSquareBracketKeyword_1_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {IndexExpCS.source=current}
protected class IndexExpCS_IndexExpCSSourceAction_1_0 extends ActionToken  {

	public IndexExpCS_IndexExpCSSourceAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getIndexExpCSSourceAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IndexExpCS_MessageExpCSParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getIndexExpCSAccess().getIndexExpCSSourceAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("source", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("source")) return null;
		return getDescr((EObject) val);
	}
}

// "["
protected class IndexExpCS_LeftSquareBracketKeyword_1_1 extends KeywordToken  {
	
	public IndexExpCS_LeftSquareBracketKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getLeftSquareBracketKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IndexExpCS_IndexExpCSSourceAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// indexes+=OclExpressionCS
protected class IndexExpCS_IndexesAssignment_1_2 extends AssignmentToken  {
	
	public IndexExpCS_IndexesAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getIndexesAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("indexes",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("indexes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIndexExpCSAccess().getIndexesOclExpressionCSParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IndexExpCS_LeftSquareBracketKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," indexes+=OclExpressionCS)*
protected class IndexExpCS_Group_1_3 extends GroupToken {
	
	public IndexExpCS_Group_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getGroup_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IndexExpCS_IndexesAssignment_1_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class IndexExpCS_CommaKeyword_1_3_0 extends KeywordToken  {
	
	public IndexExpCS_CommaKeyword_1_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getCommaKeyword_1_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IndexExpCS_Group_1_3(parent, this, 0, inst);
			case 1: return new IndexExpCS_IndexesAssignment_1_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// indexes+=OclExpressionCS
protected class IndexExpCS_IndexesAssignment_1_3_1 extends AssignmentToken  {
	
	public IndexExpCS_IndexesAssignment_1_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getIndexesAssignment_1_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("indexes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("indexes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIndexExpCSAccess().getIndexesOclExpressionCSParserRuleCall_1_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IndexExpCS_CommaKeyword_1_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "]"
protected class IndexExpCS_RightSquareBracketKeyword_1_4 extends KeywordToken  {
	
	public IndexExpCS_RightSquareBracketKeyword_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIndexExpCSAccess().getRightSquareBracketKeyword_1_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IndexExpCS_Group_1_3(parent, this, 0, inst);
			case 1: return new IndexExpCS_IndexesAssignment_1_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule indexExpCS ****************/


/************ begin Rule messageExpCS ****************
 *
 * messageExpCS returns OclExpressionCS:
 *   primaryExpCS; 
 *     
 *     
 * 	
 * //|	OclMessageExpCS // OclExpressionCS[E] is added by CompleteOCL
 *
 **/

// primaryExpCS 
// 	
// //|	OclMessageExpCS // OclExpressionCS[E] is added by CompleteOCL
protected class MessageExpCS_PrimaryExpCSParserRuleCall extends RuleCallToken {
	
	public MessageExpCS_PrimaryExpCSParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMessageExpCSAccess().getPrimaryExpCSParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMessageExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrimaryExpCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule messageExpCS ****************/


/************ begin Rule primaryExpCS ****************
 *
 * primaryExpCS returns OclExpressionCS:
 *   selfKeywordCS|LiteralExpCS|IfExpCS|"(" OclExpressionCS ")"; 
 * 
 *     
 * 	
 * //|	restrictedKeywordCS
 * 	      // OclExpressionCS[C]
 * 	           // OclExpressionCS[F]
 *
 **/

// selfKeywordCS|LiteralExpCS|IfExpCS|"(" OclExpressionCS ")" 
// 
//     
// 	
// //|	restrictedKeywordCS
// 	      // OclExpressionCS[C]
// 	           // OclExpressionCS[F]
protected class PrimaryExpCS_Alternatives extends AlternativesToken {

	public PrimaryExpCS_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimaryExpCSAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpCS_SelfKeywordCSParserRuleCall_0(parent, this, 0, inst);
			case 1: return new PrimaryExpCS_LiteralExpCSParserRuleCall_1(parent, this, 1, inst);
			case 2: return new PrimaryExpCS_IfExpCSParserRuleCall_2(parent, this, 2, inst);
			case 3: return new PrimaryExpCS_Group_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// selfKeywordCS 
// 	
// //|	restrictedKeywordCS
protected class PrimaryExpCS_SelfKeywordCSParserRuleCall_0 extends RuleCallToken {
	
	public PrimaryExpCS_SelfKeywordCSParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpCSAccess().getSelfKeywordCSParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelfKeywordCS_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SelfKeywordCS_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSelfKeywordCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// LiteralExpCS 	      // OclExpressionCS[C]
protected class PrimaryExpCS_LiteralExpCSParserRuleCall_1 extends RuleCallToken {
	
	public PrimaryExpCS_LiteralExpCSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpCSAccess().getLiteralExpCSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralExpCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LiteralExpCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLiteralExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// IfExpCS 	           // OclExpressionCS[F]
protected class PrimaryExpCS_IfExpCSParserRuleCall_2 extends RuleCallToken {
	
	public PrimaryExpCS_IfExpCSParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpCSAccess().getIfExpCSParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IfExpCS_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIfExpCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "(" OclExpressionCS ")"
protected class PrimaryExpCS_Group_3 extends GroupToken {
	
	public PrimaryExpCS_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrimaryExpCSAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpCS_RightParenthesisKeyword_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class PrimaryExpCS_LeftParenthesisKeyword_3_0 extends KeywordToken  {
	
	public PrimaryExpCS_LeftParenthesisKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpCSAccess().getLeftParenthesisKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// OclExpressionCS
protected class PrimaryExpCS_OclExpressionCSParserRuleCall_3_1 extends RuleCallToken {
	
	public PrimaryExpCS_OclExpressionCSParserRuleCall_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpCSAccess().getOclExpressionCSParserRuleCall_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OclExpressionCS_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpCS_LeftParenthesisKeyword_3_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class PrimaryExpCS_RightParenthesisKeyword_3_2 extends KeywordToken  {
	
	public PrimaryExpCS_RightParenthesisKeyword_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpCSAccess().getRightParenthesisKeyword_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpCS_OclExpressionCSParserRuleCall_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule primaryExpCS ****************/


/************ begin Rule IfExpCS ****************
 *
 * IfExpCS:
 *   "if" condition=OclExpressionCS "then" thenExpression=OclExpressionCS "else"
 *   elseExpression=OclExpressionCS "endif";
 *
 **/

// "if" condition=OclExpressionCS "then" thenExpression=OclExpressionCS "else"
// elseExpression=OclExpressionCS "endif"
protected class IfExpCS_Group extends GroupToken {
	
	public IfExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpCS_EndifKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIfExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "if"
protected class IfExpCS_IfKeyword_0 extends KeywordToken  {
	
	public IfExpCS_IfKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpCSAccess().getIfKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// condition=OclExpressionCS
protected class IfExpCS_ConditionAssignment_1 extends AssignmentToken  {
	
	public IfExpCS_ConditionAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpCSAccess().getConditionAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("condition",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("condition");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpCSAccess().getConditionOclExpressionCSParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpCS_IfKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "then"
protected class IfExpCS_ThenKeyword_2 extends KeywordToken  {
	
	public IfExpCS_ThenKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpCSAccess().getThenKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpCS_ConditionAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// thenExpression=OclExpressionCS
protected class IfExpCS_ThenExpressionAssignment_3 extends AssignmentToken  {
	
	public IfExpCS_ThenExpressionAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpCSAccess().getThenExpressionAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("thenExpression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("thenExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpCSAccess().getThenExpressionOclExpressionCSParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpCS_ThenKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "else"
protected class IfExpCS_ElseKeyword_4 extends KeywordToken  {
	
	public IfExpCS_ElseKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpCSAccess().getElseKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpCS_ThenExpressionAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// elseExpression=OclExpressionCS
protected class IfExpCS_ElseExpressionAssignment_5 extends AssignmentToken  {
	
	public IfExpCS_ElseExpressionAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpCSAccess().getElseExpressionAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("elseExpression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("elseExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpCSAccess().getElseExpressionOclExpressionCSParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpCS_ElseKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "endif"
protected class IfExpCS_EndifKeyword_6 extends KeywordToken  {
	
	public IfExpCS_EndifKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpCSAccess().getEndifKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpCS_ElseExpressionAssignment_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule IfExpCS ****************/


/************ begin Rule LetExpCS ****************
 *
 * LetExpCS:
 *   "let" variable+=LetVariableCS ("," variable+=LetVariableCS)* "in" in=OclExpressionCS;
 *
 **/

// "let" variable+=LetVariableCS ("," variable+=LetVariableCS)* "in" in=OclExpressionCS
protected class LetExpCS_Group extends GroupToken {
	
	public LetExpCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLetExpCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetExpCS_InAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLetExpCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "let"
protected class LetExpCS_LetKeyword_0 extends KeywordToken  {
	
	public LetExpCS_LetKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLetExpCSAccess().getLetKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// variable+=LetVariableCS
protected class LetExpCS_VariableAssignment_1 extends AssignmentToken  {
	
	public LetExpCS_VariableAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLetExpCSAccess().getVariableAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetVariableCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetVariableCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLetExpCSAccess().getVariableLetVariableCSParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LetExpCS_LetKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," variable+=LetVariableCS)*
protected class LetExpCS_Group_2 extends GroupToken {
	
	public LetExpCS_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLetExpCSAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetExpCS_VariableAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class LetExpCS_CommaKeyword_2_0 extends KeywordToken  {
	
	public LetExpCS_CommaKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLetExpCSAccess().getCommaKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetExpCS_Group_2(parent, this, 0, inst);
			case 1: return new LetExpCS_VariableAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// variable+=LetVariableCS
protected class LetExpCS_VariableAssignment_2_1 extends AssignmentToken  {
	
	public LetExpCS_VariableAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLetExpCSAccess().getVariableAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetVariableCS_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLetVariableCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLetExpCSAccess().getVariableLetVariableCSParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LetExpCS_CommaKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "in"
protected class LetExpCS_InKeyword_3 extends KeywordToken  {
	
	public LetExpCS_InKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLetExpCSAccess().getInKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetExpCS_Group_2(parent, this, 0, inst);
			case 1: return new LetExpCS_VariableAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// in=OclExpressionCS
protected class LetExpCS_InAssignment_4 extends AssignmentToken  {
	
	public LetExpCS_InAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLetExpCSAccess().getInAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("in",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("in");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLetExpCSAccess().getInOclExpressionCSParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LetExpCS_InKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule LetExpCS ****************/


/************ begin Rule LetVariableCS ****************
 *
 * LetVariableCS returns VariableCS:
 *   name=simpleNameCS ":" type=typeCS "=" initExpression=OclExpressionCS;
 *
 **/

// name=simpleNameCS ":" type=typeCS "=" initExpression=OclExpressionCS
protected class LetVariableCS_Group extends GroupToken {
	
	public LetVariableCS_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLetVariableCSAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetVariableCS_InitExpressionAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLetVariableCSRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=simpleNameCS
protected class LetVariableCS_NameAssignment_0 extends AssignmentToken  {
	
	public LetVariableCS_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLetVariableCSAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleNameCS_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleNameCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLetVariableCSAccess().getNameSimpleNameCSParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ":"
protected class LetVariableCS_ColonKeyword_1 extends KeywordToken  {
	
	public LetVariableCS_ColonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLetVariableCSAccess().getColonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetVariableCS_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=typeCS
protected class LetVariableCS_TypeAssignment_2 extends AssignmentToken  {
	
	public LetVariableCS_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLetVariableCSAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLetVariableCSAccess().getTypeTypeCSParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LetVariableCS_ColonKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "="
protected class LetVariableCS_EqualsSignKeyword_3 extends KeywordToken  {
	
	public LetVariableCS_EqualsSignKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLetVariableCSAccess().getEqualsSignKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LetVariableCS_TypeAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initExpression=OclExpressionCS
protected class LetVariableCS_InitExpressionAssignment_4 extends AssignmentToken  {
	
	public LetVariableCS_InitExpressionAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLetVariableCSAccess().getInitExpressionAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OclExpressionCS_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initExpression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOclExpressionCSRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLetVariableCSAccess().getInitExpressionOclExpressionCSParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LetVariableCS_EqualsSignKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule LetVariableCS ****************/

}
