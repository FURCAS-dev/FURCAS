
header {
/******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/

package org.eclipse.emf.ocl.internal.parser;

import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.ECollections;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;

import antlr.NoViableAltException;
import antlr.ParserSharedInputState;
import antlr.RecognitionException;
import antlr.SemanticException;
import antlr.Token;
import antlr.TokenBuffer;
import antlr.TokenStream;
import antlr.TokenStreamException;
import antlr.collections.impl.BitSet;

import org.eclipse.emf.ocl.expressions.AssociationEndCallExp;
import org.eclipse.emf.ocl.expressions.AssociationClassCallExp;
import org.eclipse.emf.ocl.expressions.AttributeCallExp;
import org.eclipse.emf.ocl.expressions.BooleanLiteralExp;
import org.eclipse.emf.ocl.expressions.CollectionItem;
import org.eclipse.emf.ocl.expressions.CollectionKind;
import org.eclipse.emf.ocl.expressions.CollectionLiteralExp;
import org.eclipse.emf.ocl.expressions.CollectionLiteralPart;
import org.eclipse.emf.ocl.expressions.CollectionRange;
import org.eclipse.emf.ocl.expressions.EnumLiteralExp;
import org.eclipse.emf.ocl.expressions.ExpressionsFactory;
import org.eclipse.emf.ocl.expressions.ExpressionsPackage;
import org.eclipse.emf.ocl.expressions.IfExp;
import org.eclipse.emf.ocl.expressions.IntegerLiteralExp;
import org.eclipse.emf.ocl.expressions.IterateExp;
import org.eclipse.emf.ocl.expressions.IteratorExp;
import org.eclipse.emf.ocl.expressions.LetExp;
import org.eclipse.emf.ocl.expressions.LiteralExp;
import org.eclipse.emf.ocl.expressions.LoopExp;
import org.eclipse.emf.ocl.expressions.ModelPropertyCallExp;
import org.eclipse.emf.ocl.expressions.NavigationCallExp;
import org.eclipse.emf.ocl.expressions.OclExpression;
import org.eclipse.emf.ocl.expressions.OperationCallExp;
import org.eclipse.emf.ocl.expressions.RealLiteralExp;
import org.eclipse.emf.ocl.expressions.StringLiteralExp;
import org.eclipse.emf.ocl.expressions.TupleLiteralExp;
import org.eclipse.emf.ocl.expressions.UnspecifiedValueExp;
import org.eclipse.emf.ocl.expressions.VariableDeclaration;
import org.eclipse.emf.ocl.expressions.VariableExp;
import org.eclipse.emf.ocl.internal.OclEnginePlugin;
import org.eclipse.emf.ocl.internal.l10n.Messages;
import org.eclipse.emf.ocl.uml.AssociationClass;
import org.eclipse.emf.ocl.uml.AssociationClassEnd;
import org.eclipse.emf.ocl.uml.Constraint;
import org.eclipse.emf.ocl.uml.UmlFactory;
import org.eclipse.emf.ocl.uml.UmlPackage;
import org.eclipse.emf.ocl.parser.Environment;
import org.eclipse.emf.ocl.parser.EcoreEnvironment;
import org.eclipse.emf.ocl.types.BagType;
import org.eclipse.emf.ocl.types.CollectionType;
import org.eclipse.emf.ocl.types.OrderedSetType;
import org.eclipse.emf.ocl.types.PrimitiveType;
import org.eclipse.emf.ocl.types.SequenceType;
import org.eclipse.emf.ocl.types.SetType;
import org.eclipse.emf.ocl.types.TupleType;
import org.eclipse.emf.ocl.types.TypesFactory;
import org.eclipse.emf.ocl.types.TypesPackage;
import org.eclipse.emf.ocl.types.internal.impl.AnyTypeImpl;
import org.eclipse.emf.ocl.types.internal.impl.CollectionTypeImpl;
import org.eclipse.emf.ocl.types.internal.impl.PrimitiveTypeImpl;
import org.eclipse.emf.ocl.types.util.Types;

import org.eclipse.osgi.util.NLS;

/**
 * ANTLR-generated parser class.
 *
 * IMPORTANT:  Instructions for eliminating compiler warnings.
 *
 * After regenerating the parser from this file, do the following:
 *
 * On the OclParser.java file:
 * 
 * 1.  Do an "Aurora Tools -> Fix NON-NLS for current file"
 * 2.  Remove the unused antlr.* imports (do not Ctrl+Shift+O otherwise
 *     you will lose this comment).
 * 3.  Find the uncommented empty block warning and fill the block with:
 *
 *    // empty block generated by ANTLR
 *
 * 4.  Remove the comment at the top of the file indicating that it was
 *     generated by ANTLR, so that the copyright is topmost.
 *
 * On the OclParserTokenTypes.java file:
 *
 * 5.  Remove the comment at the top of the file indicating that it was
 *     generated by ANTLR, so that the copyright is topmost.
 * 6.  Ctrl+Shift+O to remove the unused imports (all of them are unused).
 *
 * On the OclLexer.java file:
 *
 * 7.  Do an "Aurora Tools -> Fix NON-NLS for current file"
 * 8.  In method nextToken(), remove unread local vars
 *     theRetToken (several occurrences) and _token.
 * 9.  Search and replace "int _saveIndex;" with nothing (all occurrences).
 * 10. Search and replace "(char)LA(" with "LA(" (all occurrences).
 * 11. Find the uncommented empty block warnings and fill the blocks with:
 *
 *    // empty block generated by ANTLR
 *
 * 12. Remove the comment at the top of the file indicating that it was
 *     generated by ANTLR, so that the copyright is topmost.
 * 13.  Ctrl+Shift+O to remove the unused imports.
 *
 * 14. That's it!  You're clean
 */
}

class OclParser extends Parser;
		options {
			  k = 2;
			  defaultErrorHandler=false;
						}		
  
{

    private static final String StringParse_ERROR_ =
            Messages.StringParse_ERROR_;

    private static final String ErrorMessage_ERROR_ =
            Messages.ErrorMessage_ERROR_;

    private static final String VariableUsed_ERROR_ =
            Messages.VariableUsed_ERROR_;

    private static final String VariableDeclaration_ERROR_ =
            Messages.VariableDeclaration_ERROR_;

    private static final String OperationNotFound_ERROR_ =
            Messages.OperationNotFound_ERROR_;

    private static final String BadArg_ERROR_ =
            Messages.BadArg_ERROR_;

    private static final String PackageNotFound_ERROR_ =
            Messages.PackageNotFound_ERROR_;

    private static final String UnrecognizedContext_ERROR_ =
            Messages.UnrecognizedContext_ERROR_;

    private static final String BooleanForIf_ERROR_ =
            Messages.BooleanForIf_ERROR_;

    private static final String MissingTypeForVar_ERROR_ =
            Messages.MissingTypeForVar_ERROR_;

    private static final String MissingInitForVar_ERROR_ =
            Messages.MissingInitForVar_ERROR_;

    private static final String VarInNavExp_ERROR_ =
            Messages.VarInNavExp_ERROR_;

    private static final String UnrecognizedVar_ERROR_ =
            Messages.UnrecognizedVar_ERROR_;

    private static final String DeclarationType_ERROR_ =
            Messages.DeclarationType_ERROR_;

    private static final String DeclarationNoInitExp_ERROR_ =
            Messages.DeclarationNoInitExp_ERROR_;

    private static final String DeclarationInitExp_ERROR_ =
            Messages.DeclarationInitExp_ERROR_;

    private static final String UnrecognizedVarType_ERROR_ =
            Messages.UnrecognizedVarType_ERROR_;

    private static final String NoType_ERROR_ =
            Messages.NoType_ERROR_;

    private static final String NoInitExp_ERROR_ =
            Messages.NoInitExp_ERROR_;

    private static final String InitExpNotAllowed_ERROR_ =
            Messages.InitExpNotAllowed_ERROR_;

    private static final String MissingTypeDecl_ERROR_ =
            Messages.MissingTypeDecl_ERROR_;

    private static final String DuplicateNameInTuple_ERROR_ =
            Messages.DuplicateNameInTuple_ERROR_;

    private static final String MissingInit_ERROR_ =
            Messages.MissingInit_ERROR_;

    private static final String UnrecognizedEnum_ERROR_ =
            Messages.UnrecognizedEnum_ERROR_;

    private static final String FirstLastTypeMismatch_ERROR_ =
            Messages.FirstLastTypeMismatch_ERROR_;

    private static final String UnrecognizedType_ERROR_ =
            Messages.UnrecognizedType_ERROR_;

    private static final String ILLEGAL_AT_PRE_ERROR_ =
            Messages.IllegalAtPre_ERROR_;

    private static final String ILLEGAL_QUALIFIERS_ERROR_ =
            Messages.IllegalQualifiers_ERROR_;

    private static final String MISMATCHED_QUALIFIERS_ERROR_ =
            Messages.MismatchedQualifiers_ERROR_;

    private static final String ASSOCIATION_CLASS_QUALIFIER_COUNT_ERROR_ =
            Messages.AssociationClassQualifierCount_ERROR_;

    private static final String ASSOCIATION_CLASS_QUALIFIER_TYPE_ERROR_ =
            Messages.AssociationClassQualifierType_ERROR_;

    private static final String ASSOCIATION_CLASS_AMBIGUOUS_ERROR_ =
            Messages.AssociationClassAmbiguous_ERROR_;

	/*
	 * Factories for creating OCL AST nodes
	 */	 	
	TypesPackage typesPackage = TypesPackage.eINSTANCE;
    TypesFactory typesFactory = typesPackage.getTypesFactory();
    	
    ExpressionsPackage expressionsPackage = ExpressionsPackage.eINSTANCE;
    ExpressionsFactory expressionsFactory = expressionsPackage.getExpressionsFactory();
    	   		 
    UmlPackage umlPackage = UmlPackage.eINSTANCE;
    UmlFactory umlFactory = umlPackage.getUmlFactory();
    
    private OclToken lastOclToken = null;
    private List oclTokenStack = new java.util.ArrayList();
    private int oclTokenStackPointer = -1;
 
    private boolean traceflag = true;	
    	
    private String errorString = "";		

    public void setTraceFlag(boolean flag) {
    	traceflag = flag;
    }
    
    public boolean getTraceFlag() {
    	return traceflag;
    }
    
    private void TRACE( String rule, String message) {
	    if (traceflag) {
	    	System.out.println(rule + ": " + message);
	    }
	}
		    
	private void TRACE(String rule, String message, Vector namelist) {		  			
		TRACE(rule, message + makeString(namelist)); 
	}
	
	/** Pushes the next token onto the token stack. */
	private OclToken push() throws TokenStreamException {
		OclToken result = null;
		
		if (inputState.guessing == 0) {
			result = (OclToken) LT(1);
			
			push(result);
		}
		
		return result;
	}
	
	/** Pushes a specified token onto the token stack. */
	private void push(OclToken token) {
		oclTokenStack.add(token);
		oclTokenStackPointer++;
	}
	
	/**
	 * Pops the top token off of the stack.  This is the first token in the
	 * expression that we have just matched.
	 */
	private OclToken pop() {
		OclToken result = (OclToken) oclTokenStack.get(oclTokenStackPointer);
		oclTokenStack.remove(oclTokenStackPointer);
		oclTokenStackPointer--;
		return result;
	}
	
	/**
	 * Initializes the start and end positions of the specified OCL expression.
	 * This has the side-effect of popping the token stack.
	 *
	 * @param expr an OCL expression
	 */
	private void initStartEndPositions(OclExpression expr) {
		OclToken last = lastOclToken;
		OclToken first = pop();
		
		expr.setStartPosition(first.getStartPosition());
		expr.setEndPosition(last.getEndPosition());
	}
	
	/**
	 * Initializes the start and end positions of the specified variable
	 * declaration.
	 * This has the side-effect of popping the token stack.
	 *
	 * @param vdecl a variable declaration
	 */
	private void initStartEndPositions(VariableDeclaration vdecl) {
		OclToken last = lastOclToken;
		OclToken first = pop();
		
		vdecl.setStartPosition(first.getStartPosition());
		vdecl.setEndPosition(last.getEndPosition());
	}

	/**
	 * Initializes the start and end positions of the property name in the
	 * specified model property call expression.
	 * This has no side-effects.
	 *
	 * @param expr a model property call expression
	 */
	private void initPropertyPositions(ModelPropertyCallExp expr, OclToken token) {
		expr.setPropertyStartPosition(token.getStartPosition());
		expr.setPropertyEndPosition(token.getEndPosition());
	}
	
	/**
	 * Creates a fake OCL token starting at the specified location and having
	 * the specified length.
	 */
	private OclToken createFakeToken(int start, int length) {
		StringBuffer buf = new StringBuffer(length);
		buf.setLength(length);  // fill with null characters
		
		OclToken result = new OclToken(0, buf.toString()); // invalid token type
		result.setStartPosition(start);
		return result;
	}
	
	/**
	 * Sets the last token recognized in the (sub)expression currently being
	 * parsed.  If it is the first token, also, then that is recorded.
	 */
	public void match(int t) throws MismatchedTokenException, TokenStreamException {
		lastOclToken = (OclToken) LT(1);
		
		super.match(t);
	}
	
	/**
	 * Sets the last token recognized in the (sub)expression currently being
	 * parsed.  If it is the first token, also, then that is recorded.
	 */
	public void match(BitSet b) throws MismatchedTokenException, TokenStreamException {
		lastOclToken = (OclToken) LT(1);
		
		super.match(b);
	}
	
	private String makeString(Vector namelist) {
		String msg = "";
		for (int i = 0; i < namelist.size(); i++) {
			msg += " " + (String) namelist.elementAt(i);
		}
		return msg;
	}
	
	/**
	 * Removes the "s surrounding a quoted string, if any.
	 * 
	 * @param quoted a possibly quoted string
	 * @return <code>quoted</code> without the surrounding quotes, or just
	 *     <code>quoted</code> verbatim if there were none
	 */
	private String unquote(String quoted) {
	    String result = quoted;
	
    	if ((result != null) && (result.length() > 1)) {
    		int max = result.length() - 1;
	
    		if ((result.charAt(0) == '"') && (quoted.charAt(max) == '"')) {
    			result = result.substring(1, max);
    			}
    			// this is a regexp, so the backslash needs to be
    								//   re-escaped, thus "\\" is rendered in a Java
    													//   string literal as "\\\\"
    			result = result.replaceAll("\\\\\"", "\"");  //$NON-NLS-1$//$NON-NLS-2$
    	}
    
		return result;
	}
	
	/**
	 * Sets the specified navigation call's qualifiers, if they are compatible
	 * with the navigated association end or association class.
	 * 
	 * @param env the OCL environment
	 * @param rule the rule name that parsed the qualifiers
	 * @param nc the navigation call expression
	 * @param qualifiers the qualifiers to set
	 * 
	 * @throws SemanticException if the qualifiers do not conform
	 */
	private void setQualifiers(Environment env, String rule,
			NavigationCallExp nc, EList qualifiers) throws SemanticException {
		
		if (nc instanceof AssociationEndCallExp) {
			EReference source = ((AssociationEndCallExp) nc).getReferredAssociationEnd();
			
			List expectedTypes = EcoreEnvironment.getQualifierTypes(source);
			
			if (expectedTypes.size()!= qualifiers.size()) {
				ERROR(rule, MISMATCHED_QUALIFIERS_ERROR_);
			} else {
				Iterator eiter = expectedTypes.iterator();
				Iterator qiter = qualifiers.iterator();
				
				while (eiter.hasNext()) {
					EClassifier expectedType = (EClassifier) eiter.next();
					OclExpression qualifier = (OclExpression) qiter.next();
					
					EClassifier qualifierType = qualifier.getType();
					if (AnyTypeImpl.typeCompare(expectedType, qualifierType) < 0) {
						ERROR(rule, MISMATCHED_QUALIFIERS_ERROR_);
					}
				}
			}
		} else if (nc instanceof AssociationClassCallExp) {
			if (qualifiers.size() != 1) {
				ERROR(rule, ASSOCIATION_CLASS_QUALIFIER_COUNT_ERROR_);
			}
			
			Object qualifier = qualifiers.get(0);
			if (!(qualifier instanceof AssociationEndCallExp)) {
				ERROR(rule, ASSOCIATION_CLASS_QUALIFIER_TYPE_ERROR_);
			}
			
			AssociationClassCallExp acc = (AssociationClassCallExp) nc;
			EClass assocClass = acc.getReferredAssociationClass();
			
			// can assume an EClass, otherwise we wouldn't have found an
			//   association class call expression
			EClass sourceType = (EClass) nc.getSource().getType();
			EReference ref = ((AssociationEndCallExp) qualifier).getReferredAssociationEnd();
			if ((ref instanceof AssociationClassEnd)
					&& sourceType.getEAllReferences().contains(ref)
					&& (((AssociationClassEnd) ref).getAssociationClass() == assocClass)) {
				acc.setNavigationSource(ref);
			} else {
				ERROR(rule, ASSOCIATION_CLASS_QUALIFIER_TYPE_ERROR_);
			}
		}
			
		// all's well
		nc.getQualifiers().addAll(qualifiers);
	}
	
	/**
	 * Asserts that the specified association class is not a reflexive
	 * association.
	 * 
	 * @param env the current environment
	 * @param rule the rule that we are matching
	 * @param acc the association class call expression
	 * 
	 * @throws SemanticException if the association class is reflexive
	 */
	private void checkNotReflexive(Environment env, String rule,
			AssociationClassCallExp acc) throws SemanticException {
		
		EClass assocClass = acc.getReferredAssociationClass();
		
		List ends;
		if (assocClass instanceof AssociationClass) {
			ends = ((AssociationClass) assocClass).getMemberEnds();
		} else {
			ends = ECollections.EMPTY_ELIST;
		}
		
		if (ends.size() == 2) {
			EReference end1 = (EReference) ends.get(0);
			EReference end2 = (EReference) ends.get(1);
			
			if (end1.getEReferenceType() == end2.getEReferenceType()) {
				ERROR(rule, ASSOCIATION_CLASS_AMBIGUOUS_ERROR_);
			}
		}
	}
	
	/**
	 * Convenience method for parsing OCL expressions
	 * String to be parsed is the argument for OclLexer.
	 * @return the parsed OCL expression
	 */
	public OclExpression parse() {
		boolean traceFlagSave = getTraceFlag();
		setTraceFlag(false);
		EList constraints = new BasicEList();
		try {
			classifierContextDeclCS(null, constraints);
		}
		catch (Exception e) {
            String message = NLS.bind(StringParse_ERROR_,
                    new Object[] { e.getMessage() });
            IllegalArgumentException error = new IllegalArgumentException(
                    message);
            OclEnginePlugin.throwing(getClass(), "parse", error);//$NON-NLS-1$
            throw error;
		}
		Constraint constraint = (Constraint) constraints.get(0);	
		setTraceFlag(traceFlagSave);
		
		return constraint.getBody();	
	}
	
	/**
	 * Hub for all semantic parsing messages -- 
	 * Should be changed if want to continue parsing, and not terminate
	 * on first exception.
	 */
	public static void ERR(String message) throws SemanticException {
		throw new SemanticException(message);
	}
	    
	private void ERROR(String rule, String errorMessage) throws SemanticException {
        String error = NLS.bind(ErrorMessage_ERROR_, new Object[] {
                rule, errorMessage });
        errorString += error;
        ERR(error);
	    
	    /*if (traceflag) {
	    	System.out.println(error);
	    }*/
	    
	}
		
	private void ERROR(String rule, String errorMessage, Vector namelist)
	throws SemanticException {		  	
		String msg = errorMessage;
		for (int i = 0; i < namelist.size(); i++) {
			msg += " " + (String) namelist.elementAt(i);
		}
		ERROR(rule, msg); 
	}
	
	
	/**
	 * Generate a VariableDeclaration AST node, and add it to the environment.
	 * Variable declarations are generated for "self", let expression variables, and
	 * iterator and iterate variables, both implicit and explicit.
	 * For implicit variables, the name is generated by the Environment.
	 */
	private VariableDeclaration genVariableDeclaration(String rule, Environment env, String name, 
				EClassifier type, OclExpression initExp, boolean explicitFlag,
				boolean addToEnvironment, boolean isSelf) throws RecognitionException {
			
		VariableDeclaration vdcl = expressionsFactory.createVariableDeclaration();		
 		vdcl.setVarName(name);
 		vdcl.setType(type);
 		vdcl.setInitExpression(initExp);
 		
 		if (addToEnvironment) {
 			boolean result = env.addElement(name, vdcl, explicitFlag);
 			if (!result) {
                if (name != null) {
                    String message = NLS.bind(VariableUsed_ERROR_,
                            new Object[] { name });
                    ERROR(rule, message);
                } else {
                    ERROR(rule, VariableDeclaration_ERROR_);
                }
 			}
 			
 			if (isSelf) {
 				env.setSelfVariable(vdcl);
 			}
 		}
 		
 		if (addToEnvironment) {
 			TRACE(rule, "adding variable declaration for " + vdcl.getVarName());
 		}	
 		return vdcl;
	}
    	    
	/**
	 * Generate an OperationCallExp node. 
	 * operName is the input name of the operation, which
	 * must be matched against the datatype of the operation source.
	 */ 
	private OperationCallExp genOperationCallExp(Environment env, String rule, String operName, OclExpression source, EList args)
	throws RecognitionException {
	    	
	    OperationCallExp result;
	    
	    result = expressionsFactory.createOperationCallExp();
	    result.setSource(source);	   
	    EClassifier sourceType = source.getType();
	    
	    // Performs method signature checking		
	    EOperation oper = EcoreEnvironment.lookupOperation(sourceType, operName, args);
	    if (oper == null) { 
            String message = NLS.bind(OperationNotFound_ERROR_,
                    new Object[] { operName });
            ERROR(rule, message);
            result.setType(Types.OCL_VOID);
		} else {
		  	TRACE(rule, oper.getName());
	    	result.setReferredOperation(oper);
	    }
						    
		// Set up arguments
		EList callargs = result.getArguments();
		if (args != null) {
		   	for (int i = 0; i < args.size(); i++) {
		   		OclExpression arg = (OclExpression) args.get(i);
		   		if (arg == null) {
                    ERROR(rule, BadArg_ERROR_);
		   			continue;
		   		}
		   		
		   		callargs.add(args.get(i));
		   	}
		}
				
		// Compute the result type, and perform conformance checking.
		if (oper != null) {
			EClassifier resultType = null;
			
		   	if (sourceType instanceof CollectionType) { 
		   		int opcode = ((CollectionTypeImpl) sourceType).getOperationCode(operName);
		   		result.setOperationCode(opcode);
		   		CollectionTypeImpl ct = (CollectionTypeImpl) sourceType;
				resultType = ct.getResultType(opcode, args);
		   	} else if (sourceType instanceof PrimitiveType) {
		   		int opcode = ((PrimitiveTypeImpl) sourceType).getOperationCode(operName);
		   		result.setOperationCode(opcode);
		   		PrimitiveTypeImpl pt = (PrimitiveTypeImpl) sourceType;
		   		resultType = pt.getResultType(opcode, args);
		   	} else {
		   		// source is a tuple, an EClass, or an enumeration
		   		int opcode = AnyTypeImpl.OCL_ANY_TYPE.getOperationCode(operName);
		   		result.setOperationCode(opcode);
		   		resultType = AnyTypeImpl.getResultType(sourceType, opcode, args);
		   	}
		   	if (resultType == null)
		   		resultType = EcoreEnvironment.getOclType(oper);	   		
		   	result.setType(resultType);
		}
			
		return result;
	}
}
           
    
/*
 * packageDeclarationCS
 */
packageDeclarationCS[EList constraints]
{ 	Vector pathname = null; 
	EPackage defaultPackage = null;
} :

	((	"package" pathname = pathNameCS 
		{ 
			defaultPackage = EcoreEnvironment.findPackage(pathname); 
		  	if (defaultPackage == null) {
                ERROR("packageDeclarationCS", PackageNotFound_ERROR_,//$NON-NLS-1$
                        pathname);
		 	 }
		  
		  	TRACE("packageDeclarationCS", "Package ", pathname);	  	
		}			
	  	( contextDeclarationCS[defaultPackage, constraints] )+	  	
	  	"endpackage"	  
	|
		( contextDeclarationCS[defaultPackage, constraints] )+	
	)
	EOF )
;
	

/*
 * pathNameCS     name :: name :: name
 */
pathNameCS returns  [Vector sequenceOfNames]  
{
	sequenceOfNames = null;
} :
	
	/*( t:NAME 
		( "::"  sequenceOfNames = pathNameCS )?
    ) */
    (	
    	p:PATHNAME
    	{
    		StringTokenizer tokenizer = new StringTokenizer(p.getText(), "::");
    		sequenceOfNames = new Vector();
    		while (tokenizer.hasMoreTokens()) {
    			sequenceOfNames.add(unquote(tokenizer.nextToken()));
    		}
    	}
    |
    	t:NAME
    	{
    		sequenceOfNames = new Vector();
    		sequenceOfNames.add(unquote(t.getText()));
    	}
    |
    	n:NUMERICPATHNAME
    	{
    		StringTokenizer tokenizer = new StringTokenizer(n.getText(), "::");
    		sequenceOfNames = new Vector();
    		while (tokenizer.hasMoreTokens()) {
    			sequenceOfNames.add(unquote(tokenizer.nextToken()));
    		}
    	}
    )

;


   
/*
 * contextDeclarationCS
 *   omitting:  attrOrAssocContextCS
 */
contextDeclarationCS[EPackage defpack, EList constraints]
{
	String selfName = null;
	Vector pathName = null;
} :
 	(	
 		"context"
 			(c:NAME COLON {selfName = unquote(c.getText());})?
 			pathName = pathNameCS
 		(
 			operationContextDeclCS0[defpack, selfName, pathName, constraints]
 			| classifierContextDeclCS0[defpack, selfName, pathName, constraints]
		)
 	)
;

/*
 * classifierContextDeclCS
 */
classifierContextDeclCS[EPackage defpack, EList constraints] 
{ 	String selfName = null;
	Vector pathName = null;
}  :	
 	(
		"context"
			(c:NAME COLON {selfName = unquote(c.getText());})?
			pathName = pathNameCS
 		classifierContextDeclCS0[defpack, selfName, pathName, constraints] 
 	)
;
 
/*
 * Internal rule for recognizing the part of the classifier context declaration
 * following the "context" keyword, optional self name, and path name.
 */
protected classifierContextDeclCS0[EPackage defpack, String selfName, Vector pathName, EList constraints] 
{ 	EClassifier type = null;
 	Constraint astNode = null;
}  :
 	(
 		{   Environment env = new EcoreEnvironment(defpack);
 			type = env.lookupPathName(pathName);
 			if (type == null) {
                String message = NLS.bind(
                        UnrecognizedContext_ERROR_,
                        new Object[] { makeString(pathName) });
                ERROR("classifierContextDeclCS", message);//$NON-NLS-1$
            }
            type = EcoreEnvironment.getOclType(type);
 			if (selfName == null || selfName.length() == 0) {
 				selfName = "self";
 			}
 			genVariableDeclaration("\nclassifierContextDeclCS", env,
 							selfName, type, null, true, true, true);
 								
  			TRACE("classifierContextDeclCS", "context", pathName);  
 		}
 			
 		( astNode = invOrDefCS0[env] 
 			{ astNode.setInstanceVarName(selfName);
 			  constraints.add(astNode); }
 		)+
 	
 	)
;
  
/*
 * operationContextDeclCS
 */
operationContextDeclCS[EPackage defpack, EList constraints] 
{ 	Vector operationName = null;
}  :	
 	(
		"context" operationName = pathNameCS
 		operationContextDeclCS0[defpack, null, operationName, constraints] 
 	)
;
 
/*
 * Internal rule for recognizing the part of the operation context declaration
 * following the "context" keyword and path name.
 */
protected operationContextDeclCS0[EPackage defpack, String selfName,
			Vector operationName, EList constraints] 
{ 	EOperation operation = null;
	EClassifier classifier = null;
 	EList parms = new BasicEList(); 
 	EList results = new BasicEList(); 
 	Constraint astNode = null;
 	String instanceVarName = null;
 	Environment env = new EcoreEnvironment(defpack);
 	Environment operationEnv = new EcoreEnvironment(env);
}  :	
 	(
 		operationSig[operationEnv, parms, results]
 		{   
 			if (operationName.size() > 1) {
 				int lastName = operationName.size() - 1;
 				Vector className = new Vector(
 					operationName.subList(0, lastName));
 				classifier = env.lookupPathName(className);
 				
 				if (classifier != null) {
 					operation = EcoreEnvironment.lookupOperation(
 						classifier, (String) operationName.get(lastName), parms);
 				}
 			}
 			
 			if (operation == null) {
                String message = NLS.bind(
                        UnrecognizedContext_ERROR_,
                        new Object[] { makeString(operationName) });
                ERROR("operationContextDeclCS", message);//$NON-NLS-1$
            }
            
 			genVariableDeclaration("\noperationContextDeclCS", env,
 							"self", classifier, null, true, true, true);
 								
  			TRACE("operationContextDeclCS", "context", operationName);
  			
  			  
 		}
 			
 		( astNode = prePostOrBodyDeclCS0[operationEnv, operation] 
 			{ astNode.setInstanceVarName(instanceVarName);
 			  constraints.add(astNode); }
 		)+
 		
 	)
;

/*
 * operationCS
 */
operationCS[Environment env, EList parms, EList results] returns [Vector operationName]
{	operationName = null;
} :
	(
		(operationName = pathNameCS)
		operationSig[env, parms, results]
	)
;

/*
 * Internal rule recognizing the operation signature
 */
protected operationSig[Environment env, EList parms, EList results]
{	EClassifier type = null;
} :
	(
		LPAREN (parametersCS[env, parms])? RPAREN COLON (type = typeCS[env])?
		{
			if (type != null) {
				results.add(type);
				OclTokenAdapter.getToken(type); // discard adapter if any
			}
		}
	)
;

/*
 * parametersCS
 */
parametersCS[Environment env, EList parms]
{	VariableDeclaration decl = null;
} :
	(
		(decl = variableDeclarationCS[env, true]) {parms.add(decl);}
		(
			COMMA decl = variableDeclarationCS[env, true] {parms.add(decl);}
		)*
	)
;

/*
 * prePostOrBodyDeclCS - top-level externally callable rule to parse a single
 *    operation pre-, post-, or body constraint
 */
prePostOrBodyDeclCS[Environment env, EOperation operation] returns [Constraint astNode]
:
	(astNode = prePostOrBodyDeclCS0[env, operation])
	EOF
;

/*
 * prePostOrBodyDeclCS0 - protected implementation of prePostOrBodyDeclCS
 */
protected prePostOrBodyDeclCS0[Environment env, EOperation operation] returns [Constraint astNode]
{ 	OclExpression oclexpr = null;
	EClassifier operationType = EcoreEnvironment.getOclType(operation);
	astNode = null;
	String stereotype = null;
} :
	(
		(
			("pre") { stereotype = Constraint.PRECONDITION; }
			| ("post") {
				 stereotype = Constraint.POSTCONDITION;
				 
				 // postconditions have an implicit variable "result" of the
				 //    same type as the operation
				 if ((operationType != null) && (env.lookupLocal("result") == null)) {//$NON-NLS-1$
					genVariableDeclaration(
						"prePostOrBodyDeclCS0", env,//$NON-NLS-1$
 						"result", operationType, null, true, true, false);//$NON-NLS-1$
				 }
			 }
			| ("body") { stereotype = Constraint.BODY; }
		)
		( n:NAME )? COLON oclexpr = oclExpressionCS[env] 		
		{  
			/* create a constraint astNode  -- must reference the type of self...
		       also, can have a name n.  type of constraint is pre/post/body...
		    */
			astNode = umlFactory.createConstraint();

			if (n != null) {
				astNode.setName(unquote(n.getText()));
			}
			
			EList constrainedElement = astNode.getConstrainedElement();
			constrainedElement.add(operation);
			astNode.setBody(oclexpr);
			astNode.setStereotype(stereotype);
		}
	)
;

/*
 * invOrDefCS - top-level, externally callable rule to parse a single invariant
 *    constraint or def expression (currently not supporting def)
 *
 *    omitting:  def
 */
invOrDefCS[Environment env] returns [Constraint astNode]
:
	(astNode = invOrDefCS0[env])
	EOF
;

/*
 * invOrDefCS0 - protected implementation of invOrDefCS
 */
protected invOrDefCS0[Environment env] returns [Constraint astNode]
{ 	OclExpression oclexpr = null;
	astNode = null;
} :
	(
		"inv" ( n:NAME )? COLON oclexpr = oclExpressionCS[env] 		
		{  
			/* create a constraint astNode  -- must reference the type of self...
		       also, can have a name n.  type of constraint is inv...
		       constraints can be of different types ??  inv or pre/post?
		    */
			astNode = umlFactory.createConstraint();

			if (n != null) {
				astNode.setName(unquote(n.getText()));
			}
			
			EClassifier type = env.getSelfVariable().getType();
			EList constrainedElement = astNode.getConstrainedElement();
			constrainedElement.add(type);
			astNode.setBody(oclexpr);
			astNode.setStereotype(Constraint.INVARIANT);
		}
	)
;
	

/*
 * oclExpressionCS -- implies
 */
oclExpressionCS[Environment env] returns [OclExpression astNode]
{ 	
	OclExpression expr = null;
	astNode = null;
	EList args = null;
	boolean matchedOne = false;
	OclToken oclToken = null;
} :
	( 
		{ oclToken = push(); }
		
	    astNode = oclExpr1CS[env]
	    
	    (options { warnWhenFollowAmbig = false; } :
		  	
		  	{
		  		if (matchedOne) {
		  			// re-push the first token of the composed implies expression
		  			push(oclToken);
		  		}
		  	}
		  	
			( "implies" expr = oclExpr1CS[env] ) 
		  	
			{ 
		 		args = new BasicEList();
		 		args.add(expr);
		 		astNode = genOperationCallExp(env, "oclExpressionCS", "implies", astNode, args);	      
		 		matchedOne = true;
		 		initStartEndPositions(astNode);
		 	}
		)*
		
		{
			if (!matchedOne) {
				// pop the redunant token that we didn't need
		 		pop();
			}
		}
	)
;

/*
 * oclExpressionCS -- and, or
 */
oclExpr1CS[Environment env] returns [OclExpression astNode]
{
	OclExpression expr = null;
	astNode = null;
	EList args = null;
	String operName = null;
	boolean matchedOne = false;
	OclToken oclToken = null;
} :
	(   
		{ oclToken = push(); }
		
		 astNode = oclExpr2CS[env]
		 ( options { warnWhenFollowAmbig = false; } : 
		  	{
		  		if (matchedOne) {
		  			// re-push the first token of the composed expression
		  			push(oclToken);
		  		}
		  	}
		  	
			( 
				("and") 	{ operName = "and"; } 
			| 
		   	  	("or") 		{ operName = "or"; } 
		   	|
		   	 	( "xor")    { operName = "xor"; }
		   	)
		   	expr = oclExpr2CS[env] 
		   	{
		   		args = new BasicEList();
		   		args.add(expr);
		       	astNode = genOperationCallExp(env, "oclExpr1CS", operName, astNode, args);
		 		matchedOne = true;
		 		initStartEndPositions(astNode);
		   	}
		   				   	  
		)*
		
		{
			if (!matchedOne) {
				// pop the redunant token that we didn't need
		 		pop();
			}
		}
	)
;


/*
 * oclExpressionCS -- equality  =, <>
 */
oclExpr2CS[Environment env] returns [OclExpression astNode]
{
	OclExpression expr = null;
	astNode = null;
	EList args = null;
	String operName = null; 							   	    
	boolean matchedOne = false;
	OclToken oclToken = null;
} :
	(
		{ oclToken = push(); }
		
		// TBD:  take care of case when an operand has an EDataType type...
		astNode = oclExpr3CS[env]
		( options { warnWhenFollowAmbig = false; } :
		  	{
		  		if (matchedOne) {
		  			// re-push the first token of the composed expression
		  			push(oclToken);
		  		}
		  	}
		  	
			( 	
				(EQUALS)  { operName = "oclEquals"; }
			|
				(NEQUALS) { operName = "oclNotEquals"; }
			|
		
				(GT) 	 { operName = "greaterThan"; }
			|
				(GE)  	 { operName = "greaterThanEqual"; }
			| 
				(LT)  	 { operName = "lessThan"; }
			|
				(LE)	 { operName = "lessThanEqual"; }
			)
			expr = oclExpr3CS[env]				
			{
				args = new BasicEList();
				args.add(expr);
				astNode = genOperationCallExp(env, "oclExpr2CS", operName, astNode, args);
		 		matchedOne = true;
		 		initStartEndPositions(astNode);
			}
			
		)*
		
		{
			if (!matchedOne) {
				// pop the redunant token that we didn't need
		 		pop();
			}
		}
	)
;


/*
 * oclExpression -- if-then-else-endif
 */
oclExpr3CS[Environment env] returns [OclExpression astNode]
{ 	astNode = null; }  :
	
	( 	astNode = ifExpCS[env] 
	|	astNode = oclExpr4CS[env]
	)
;


/*
 * ifExpCS
 */
ifExpCS[Environment env] returns [OclExpression astNode]
{ 	astNode = null; 
	OclExpression expr1 = null;
	OclExpression expr2 = null;
	OclExpression expr3 = null;
	IfExp ifNode = null;
} :
	
	{ push(); }
	
	( "if" expr1 = oclExpressionCS[env]
	  "then"  expr2 = oclExpressionCS[env]
	  "else"   expr3 = oclExpressionCS[env]
	  "endif"
	)
	{ 
		TRACE("ifExpCS", " "); 
		
		if (expr1.getType() != PrimitiveTypeImpl.OCL_BOOLEAN && 
							expr1 != Types.OCL_VOID) {
            ERROR("ifExpCS", BooleanForIf_ERROR_);//$NON-NLS-1$
		}
	
		ifNode = expressionsFactory.createIfExp();
		ifNode.setCondition(expr1);
		ifNode.setThenExpression(expr2);
		ifNode.setElseExpression(expr3);
		ifNode.setType(AnyTypeImpl.commonSuperType(expr2.getType(), expr3.getType()));
		astNode = ifNode;
		
 		initStartEndPositions(astNode);
	}
;

/*
 * oclExpressionCS -- +, -
 */
oclExpr4CS[Environment env] returns [OclExpression astNode]
{
	OclExpression expr = null;
	astNode = null;
	String operName = null;
	EList args = null;
	boolean matchedOne = false;
	OclToken oclToken = null;
} :
	(
		{ oclToken = push(); }
		
		astNode = oclExpr5CS[env] 
			
		( options { warnWhenFollowAmbig = false; } :
		  	{
		  		if (matchedOne) {
		  			// re-push the first token of the composed expression
		  			push(oclToken);
		  		}
		  	}
		  	
			(
				(PLUS)  { operName = "plus"; }  
			| 
		   	  	(MINUS) 
		   	  	{ 
		   	  		if (astNode.getType() instanceof CollectionType) {
		   	  			operName = "symmetricDifference";
		   	  		} else {
		   	  			operName = "minus";
		   	  		} 
		   	  	}
		   	  	 
		   	)
		   	expr = oclExpr5CS[env]
		   	{
		   		args = new BasicEList();
		   		args.add(expr);
		   		astNode = genOperationCallExp(env, "oclExpr4CS", operName, astNode, args);	    	
		 		matchedOne = true;
		 		initStartEndPositions(astNode);
	    	}
		)*
		
		{
			if (!matchedOne) {
				// pop the redunant token that we didn't need
		 		pop();
			}
		}
	)
;


/*
 * oclExpressionCS -- *, /
 */
oclExpr5CS[Environment env] returns [OclExpression astNode]
{
	OclExpression expr = null;
	astNode = null;
	EList args = null;
	String operName = null;
	boolean matchedOne = false;
	OclToken oclToken = null;
} :
	(
		{ oclToken = push(); }
		
		astNode = oclExpr6CS[env] 
		( options { warnWhenFollowAmbig = false; } :
		  	{
		  		if (matchedOne) {
		  			// re-push the first token of the composed expression
		  			push(oclToken);
		  		}
		  	}
		  	
			(
				(MULTIPLY) { operName = "times"; }    	   
			| 
				(DIVIDE)   { operName = "divide"; } 
			)
			expr = oclExpr6CS[env]
			{
				args = new BasicEList();
				args.add(expr);
				astNode = genOperationCallExp(env, "oclExpr5CS", operName, astNode, args);
		 		matchedOne = true;
		 		initStartEndPositions(astNode);
			}
		)*
		
		{
			if (!matchedOne) {
				// pop the redunant token that we didn't need
		 		pop();
			}
		}
	)
;
			
/*
 * oclExpressionCS -- unary minus, not 
 */
oclExpr6CS[Environment env] returns [OclExpression astNode]
{
	OclExpression expr = null;
	astNode = null;
	String operName = null;
} :
	(
		astNode = oclExpr7CS[env]
	|
		(	options { warnWhenFollowAmbig = false; } :
			{ push(); }
			
			(
				(MINUS) 
				{ 
					operName = "minus";
				}
			|
				("not")  { operName = "not"; }				
			)
			expr = oclExpr6CS[env]			
			{ 
				astNode = genOperationCallExp(env, "oclExpr6CS", operName, expr, new BasicEList());
				initStartEndPositions(astNode);
			}
		)

	)
;


/*
 * oclExpressionCS  dot and arrow 
 */
oclExpr7CS[Environment env] returns [OclExpression astNode]
{
	astNode = null;
	OclToken oclToken = null;
} :
	{ oclToken = (OclToken) LT(1); }
	
	(
		astNode = oclExprCS[env, null]
		astNode = dotOrArrowExtension[env, astNode, oclToken]
	)
;
	

/*
 * dotOrArrowExtension   (  .a  | ->b )*
 */
dotOrArrowExtension[Environment env, OclExpression source, OclToken oclToken] returns [OclExpression astNode]	 
{
	OclExpression expr = null;
	astNode = source;
}  :

	( options { warnWhenFollowAmbig = false; } :
		{ push(oclToken); } // always push the same first token
		(
			  ( DOT expr = modelPropertyCallExpCS[env, astNode] )
			  { 
			  	TRACE("dotOrArrowExtension", "dot"); 
			  }  
		| 
		   	  ( ARROW )	   	  	
		   	  {	
		   	  	/* The source must be a collection type.
		   	  	 */
		   	  	if (!(astNode.getType() instanceof CollectionType)) {
		   	  		CollectionLiteralExp astNode1 = expressionsFactory.createCollectionLiteralExp();
					astNode1.setKind(CollectionKind.SET_LITERAL);
					EList collectionParts = astNode1.getParts();
					CollectionItem collItem = expressionsFactory.createCollectionItem();
 					collItem.setType(astNode.getType());
 					collItem.setItem(astNode);				
					collectionParts.add(collItem);
		   	  		SetType type = typesFactory.createSetType(astNode.getType());
		   	  		type.setName("Set(" + type.getName() + ")" );
		   	  		astNode1.setType(type);
		   	  		astNode = astNode1;
		   	  	}	
		   	  		
		   	  } 
		   	  ( expr = setExpCS[env, astNode] ) 
		   	  { 
		   	  	TRACE("dotOrArrowExtension", "arrow"); 
		   	  }
		   	  	
		 )
		 { 
		      astNode = expr;
		      initStartEndPositions(expr);	              	 
		 } 
	)*
;

							
/*
 * OclExprCS
 */
oclExprCS[Environment env, OclExpression source] returns [OclExpression astNode]   

	{	astNode = null;
		EList qualifiers = null;
		boolean isMarkedPre = false;
	} :
	
	{ push(); }
	
	( 
		astNode = letExpCS[env] |		
		astNode = operationCallExpCS[env, source, false] |
		astNode = literalExpCS[env] |
		astNode = simpleVariableCS[env, source]
		    (qualifiers = qualifiersCS[env, astNode])?
		    (PRE {isMarkedPre=true;})? |
      	LPAREN astNode = oclExpressionCS[env] RPAREN
	)
	
	{
      	initStartEndPositions(astNode);
      	
		if (isMarkedPre) {
			if (astNode instanceof ModelPropertyCallExp) {
				((ModelPropertyCallExp) astNode).setMarkedPre(isMarkedPre);
			} else {
                ERROR("oclExprCS", ILLEGAL_AT_PRE_ERROR_);//$NON-NLS-1$
			}
		}
		
		if (qualifiers != null) {
			if (astNode instanceof NavigationCallExp) {
				setQualifiers(env, "oclExprCS", (NavigationCallExp) astNode, qualifiers);
			} else if ((astNode instanceof LoopExp)
					&& ((LoopExp) astNode).getBody() instanceof NavigationCallExp) {
				// might have parsed an implicit collect expression
				setQualifiers(env, "oclExprCS",//$NON-NLS-1$
					(NavigationCallExp) ((LoopExp) astNode).getBody(), qualifiers);
			} else {
				ERROR("oclExprCS", ILLEGAL_QUALIFIERS_ERROR_);//$NON-NLS-1$
			}
		} else if (astNode instanceof AssociationClassCallExp) {
			checkNotReflexive(env, "oclExprCS", (AssociationClassCallExp) astNode);
		}
	}
;

/*
 * Parses out the qualifiers in a navigation call expression.
 */
protected qualifiersCS[Environment env, OclExpression navigation] returns [EList qualifiers]
{
	OclExpression expr = null;
	OclExpression source = null;
	
	if (navigation instanceof LoopExp) {
		// extract the navigation expression from an iteration expression,
		//    if any
		navigation = ((LoopExp) navigation).getBody();
	}
}
:
	LBRACKET
	(
		{ navigation instanceof AssociationClassCallExp }?
		(
			{
				AssociationClassCallExp acc = (AssociationClassCallExp) navigation;
				source = acc.getSource();
				push((OclToken) LT(1));
			}
			expr = modelPropertyCallExpCS[env, source]
			{
				initStartEndPositions(expr);
				qualifiers = new BasicEList();
				acc.setSource(source); // expr "stole" the source
				qualifiers.add(expr);
			}
		)
		|
			qualifiers = argumentsCS[env]
			
	)
	RBRACKET
;

/*
 * modelPropertyCallExpCS  -- after "." can have an operation call or a property reference
 */
modelPropertyCallExpCS[Environment env, OclExpression source] returns [OclExpression astNode]
	{	astNode = null;
		EList qualifiers = null;
		boolean isMarkedPre = false;} :
	( 
		( astNode = operationCallExpCS[env, source, true]  )
	|
		( astNode = simpleVariableCS[env, source]
		    (qualifiers = qualifiersCS[env, astNode])?
		    (PRE {isMarkedPre=true;})? )
	) {
		if (isMarkedPre) {
			if (astNode instanceof ModelPropertyCallExp) {
				((ModelPropertyCallExp) astNode).setMarkedPre(isMarkedPre);
			} else {
                ERROR("modelPropertyCallExpCS", ILLEGAL_AT_PRE_ERROR_);//$NON-NLS-1$
			}
		}
		
		if (qualifiers != null) {
			if (astNode instanceof NavigationCallExp) {
				setQualifiers(env, "modelPropertyCallExpCS",
					(NavigationCallExp) astNode, qualifiers);
			} else if ((astNode instanceof LoopExp)
					&& ((LoopExp) astNode).getBody() instanceof NavigationCallExp) {
				// might have parsed an implicit collect expression
				setQualifiers(env, "modelPropertyCallExpCS",//$NON-NLS-1$
					(NavigationCallExp) ((LoopExp) astNode).getBody(), qualifiers);
			} else {
				ERROR("modelPropertyCallExpCS", ILLEGAL_QUALIFIERS_ERROR_);//$NON-NLS-1$
			}
		} else if (astNode instanceof AssociationClassCallExp) {
			checkNotReflexive(env, "modelPropertyCallExpCS",
				(AssociationClassCallExp) astNode);
		}
	}
;

/*
 * oclSetExpCS --  expressions after ->
 * type is the type of the source
 */
setExpCS[Environment env, OclExpression source] returns [OclExpression astNode]
	{ 	astNode = null; } :
	
	(  
		( astNode = iteratorExpCS[env, source] )
	|
		( astNode = iterateExpCS[env, source] )
	|
		( astNode = operationCallExpCS[env, source, false] )
	
	)
;



/*
 * LetExpCS
 */
letExpCS[ Environment env] returns [LetExp astNode]  
	{ 
	  VariableDeclaration varDeclaration;
	  OclExpression letSubExp;
	  String varName = null;	  
	  astNode = null;
    }  :

    ( "let" varDeclaration = variableDeclarationCS[env, true]
    	{
	   		varName = varDeclaration.getVarName();
    		if (varDeclaration.getType() == null) {
                String message = NLS.bind(MissingTypeForVar_ERROR_,
                        new Object[] { varName });
                ERROR("letExpCS", message);//$NON-NLS-1$
	   		}
	   		if (varDeclaration.getInitExpression() == null) {
                String message = NLS.bind(MissingInitForVar_ERROR_,
                        new Object[] { varName });
                ERROR("letExpCS", message);//$NON-NLS-1$
	   		} 
    	}
	   	letSubExp = letExpSubCS[env] 
	)

	{
	   
	   astNode = expressionsFactory.createLetExp(); 
	   astNode.setVariable(varDeclaration);
	   astNode.setIn(letSubExp);
	   astNode.setType(letSubExp.getType());
	   env.deleteElement(varName);
	}
;


/*
 * VariableDeclarationCS
 */
variableDeclarationCS[Environment env, boolean addToEnvironment] returns [VariableDeclaration astNode] 
   	{
	  	String varName;
	  	EClassifier type = null;
	  	OclExpression expr = null;
	  	
	  	astNode = null;
   	}  :
   	
   	{ push(); }
   	
   	(   t:NAME 
   		( COLON type = typeCS[env]
   			{ if (type == null) {
                    String message = NLS.bind(
                            UnrecognizedVarType_ERROR_, new Object[] {
                            	unquote(t.getText()) });
                    ERROR("variableDeclarationCS", message);//$NON-NLS-1$;
                    break;
   			}
   			}
   		) ?	

	  	( options { warnWhenFollowAmbig = false; } :
	  	EQUALS  expr = oclExpressionCS[env]) ?  
   	) 
	{
		varName = unquote(t.getText());
		astNode = genVariableDeclaration("variableDeclarationCS", env, varName, type, expr, 
						true, addToEnvironment, false);
		
		initStartEndPositions(astNode);
		
		OclToken typeToken = OclTokenAdapter.getToken(type);
		astNode.setTypeStartPosition(typeToken.getStartPosition());
		astNode.setTypeEndPosition(typeToken.getEndPosition());
	}
;

/*
 * TypeCS
 */
typeCS[Environment env] returns [EClassifier astNode] 
{
     astNode = null;
	Vector pathName = null;
} : 
	( 
		( 	
			astNode = primitiveTypeCS
		|	pathName = pathNameCS 
			{
				astNode = env.lookupPathName(pathName);
			}
		) { OclTokenAdapter.attach(astNode, lastOclToken); }
	|
		{ push(); }
		(
			astNode = collectionTypeCS[env]
		|	astNode = tupleTypeCS[env]
		)
		{
			// create a fake token for the collection or tuple type
			int fakeTokenStart = pop().getStartPosition();
			int fakeTokenLength = lastOclToken.getEndPosition() - fakeTokenStart;
			OclToken fakeToken = createFakeToken(fakeTokenStart, fakeTokenLength);
			OclTokenAdapter.attach(astNode, fakeToken);
		}
	|	LPAREN astNode = typeCS[env] RPAREN
	)
;

/**
 * primitiveTypeCS
 */
primitiveTypeCS returns [EClassifier astNode]
{ astNode = null;
} :
	(	"Integer"	{
						astNode = PrimitiveTypeImpl.OCL_INTEGER; }
	|	"String"	{ 
					 astNode = PrimitiveTypeImpl.OCL_STRING;}
	|	"Real"		{
					 astNode = PrimitiveTypeImpl.OCL_REAL; }
	|	"Boolean"	 {
						astNode = PrimitiveTypeImpl.OCL_BOOLEAN; }
	|   "OclAny"
					 {  astNode = AnyTypeImpl.OCL_ANY_TYPE; }
	|	"OclVoid"
					{  astNode = Types.OCL_VOID; }
	)
;

/*
 * collectionTypeCS
 */
collectionTypeCS[Environment env] returns [CollectionType astNode]
{	astNode = null;
	EClassifier type = null;
} :
	( astNode = collectionTypeIdentifierCS LPAREN
		type = typeCS[env] RPAREN
	)
	{
		astNode.setElementType(type);
		astNode.setName(astNode.getName() + "(" + type.getName() + ")" );
		
		OclToken typeToken = OclTokenAdapter.getToken(type);
		astNode.setTypeStartPosition(typeToken.getStartPosition());
		astNode.setTypeEndPosition(typeToken.getEndPosition());
	}
;

/*
 * collectionTypeIdentifierCS 
 */
collectionTypeIdentifierCS returns [CollectionType astNode]
{	astNode = null;
} :
	(
		"Set"
		{
			astNode = typesFactory.createSetType();
			astNode.setName("Set");
			TRACE("collectionTypeIdentifierCS", "SET");
		}
		|	"Bag"
		{
			astNode = typesFactory.createBagType();
			astNode.setName("Bag");  
			TRACE("collectionTypeIdentifierCS", "BAG"); 
		}
		|	"Sequence"
		{  	
			astNode = typesFactory.createSequenceType();
			astNode.setName("Sequence");
			TRACE("collectionTypeIdentifierCS", "SEQUENCE"); 
		}
		|	"Collection"
		{
			astNode = typesFactory.createCollectionType();
			astNode.setName("Collection"); 
			TRACE("collectionTypeIdentifierCS", "COLLECTION"); 
		}
		| 	"OrderedSet"
		{
			astNode = typesFactory.createOrderedSetType();
			astNode.setName("OrderedSet");
			TRACE("collectionTypeIdentifierCS", "ORDERED_SET"); 
		}
	)
	{ astNode.setElementType(Types.OCL_VOID); }
;



/*
 * tupleTypeCS
 */
tupleTypeCS[Environment env] returns [EClassifier astNode]
{
	astNode = null;
	VariableDeclaration vdcl = null;
	HashSet names = null;
	EList vdcls = null;
	String nodeName = null;
} :
	( "Tuple" LPAREN 
		{ 
			TRACE("typeTypeCS", "Tuple Type");
			names = new HashSet();
			vdcls = new BasicEList();		
		}						
		( 	
			vdcl = variableDeclarationCS[env, false]
			{
				String name = vdcl.getVarName();
				TRACE("tupleTypeCS", " name = " + name);
				names.add(name);
				if (vdcl.getInitExpression() != null) {
                    String message = NLS.bind(
                            InitExpNotAllowed_ERROR_,
                            new Object[] { name });
                    ERROR("tupleTypeCS", message);//$NON-NLS-1$;                      
				}
				if (vdcl.getType() == null) {
                    String message = NLS.bind(
                            MissingTypeDecl_ERROR_, new Object[] { name });
                    ERROR("tupleTypeCS", message);//$NON-NLS-1$;
				}  else {
					vdcls.add(vdcl);
					nodeName = "Tuple(" + vdcl.getVarName() + ":" + vdcl.getType().getName();
					
				}										
			}
			( 	options { warnWhenFollowAmbig = false; } :
				COMMA  vdcl = variableDeclarationCS[env, false]
				{
					name = vdcl.getVarName();
					TRACE("tupleTypeCS", " name = " + name);
					if (names.contains(name)) {
                        String message = NLS.bind(
                                DuplicateNameInTuple_ERROR_,
                                new Object[] { name });
                        ERROR("tupleTypeCS", message);//$NON-NLS-1$;
						vdcl.setVarName(null);
					} else {
						names.add(name);
					}
					
					if (vdcl.getInitExpression() != null) {
                        String message = NLS.bind(
                                InitExpNotAllowed_ERROR_,
                                new Object[] { name });
                        ERROR("tupleTypeCS", message);//$NON-NLS-1$;  
					}
					if (vdcl.getType() == null) {
                        String message = NLS.bind(
                                MissingTypeDecl_ERROR_,
                                new Object[] { name });
                        ERROR("tupleTypeCS", message);//$NON-NLS-1$;
					}
					vdcls.add(vdcl);
					nodeName += ", " + vdcl.getVarName() + ":" + vdcl.getType().getName();					
				}
			)*
		) ?
		RPAREN
		{
			astNode = typesFactory.createTupleType(vdcls);
			astNode.setName(nodeName + ")");
		}
	)
;
 
		

/*
 * LetExpSubCS
 */
letExpSubCS[ Environment env] returns [OclExpression astNode] 
{
	VariableDeclaration varDeclaration;
	OclExpression letSubExp;
	String varName = null;
	LetExp letExp;		
	astNode = null;
}  :

	( 	COMMA varDeclaration = variableDeclarationCS[env, true]
		{
			if (varDeclaration.getType() == null) {
                String message = NLS.bind(NoType_ERROR_,
                        new Object[] { varName });
                ERROR("letExpSubCS", message);//$NON-NLS-1$;
			}
			if (varDeclaration.getInitExpression() == null) {
                String message = NLS.bind(NoInitExp_ERROR_,
                        new Object[] { varName });
                ERROR("letExpSubCS", message);//$NON-NLS-1$;
			}
		} 
		letSubExp = letExpSubCS[env]  
	) 
	 
	{  
		varName = varDeclaration.getVarName();
		env.deleteElement(varName);

		letExp = expressionsFactory.createLetExp(); 
		letExp.setVariable(varDeclaration);
		letExp.setIn(letSubExp);
		letExp.setType(letSubExp.getType());		
		astNode = letExp;
	}
	|
	( "in" astNode = oclExpressionCS[env] )
;



/*
 * simpleVariableExpCS
 */
simpleVariableCS[Environment env, OclExpression source] returns  [OclExpression astNode]   
	{ 
		String simpleName;
		
		astNode = null;
		EAttribute eattr = null;
		EReference eref = null;
		EClassifier classifier = null;
		AttributeCallExp attr = null;
		AssociationEndCallExp ref = null;
		EClass assocClass = null;
		AssociationClassCallExp acref = null;
		VariableDeclaration vdcl = null;
	} :
	
	( t:NAME | classifier = primitiveTypeCS )
	{
		
		/* A name can be a variable defined by a Variable declaration, the special
		  variable "self", an attribute or a reference to another object.
		  If the source is not null, then the last token was a "." or "->"
		  The source is used to establish the navigation.
		  If no type is provided, then either the name is a the use of a variable,
		  or there is an implicit variable declaration (self or an iterator)
		  that is the source.		  		   
		 */
		if (t != null) {
			simpleName = unquote(t.getText());
		} else {
				simpleName = classifier.getName();
		}
		
		/*
		 * The source may be a collection type (for example, in self.children.name, children
		 * may be a set.)_  In this case, we have to get the element type of children, so
		 * that the attribute name can be found.
		 * The source type can also be a tuple type. In this case, we need to get the 
		 * EClass of the tuple.
		 * 
		 */ 
		EClassifier sourceElementType = null;
		if (source != null) {
			sourceElementType = source.getType();
			if (sourceElementType instanceof CollectionType) {
				sourceElementType = ((CollectionType) sourceElementType).getElementType();
			} 
		}
		
		Vector names = new Vector();
		names.addElement(simpleName);
		if (classifier == null) {
				classifier = env.lookupPathName(names);
		}
		if (classifier != null) {
			/* Variable is a classifier. Classifiers are used in
			 * allInstances, isKindOf, isTypeOf, asTypeOf operators
			 * It is not clear how to represent types as OclExpressions,
			 * so we generate an UnspecifiedValueExpression with correct type.
			 */
			
			UnspecifiedValueExp vexp = expressionsFactory.createUnspecifiedValueExp();	
			vexp.setType( classifier);
			astNode = vexp;			 		
		} else if (source == null && (vdcl = env.lookup(simpleName)) != null)  { 
			// Either a use of a declared variable or self

			TRACE("variableExpCS", "Variable Expression: " + simpleName);
			
			/*if (source != null) {
				ERROR("simpleVariableExp", "Can't have a variable in the middle of a navigation path:"
								+ simpleName);
			}*/
			VariableExp vexp = expressionsFactory.createVariableExp();	
			vexp.setReferredVariable(vdcl);
			vexp.setName(vdcl.getVarName());
			vexp.setType( vdcl.getType());
			astNode = vexp;
		} else if ((eattr = env.lookupAttribute( sourceElementType, simpleName)) != null) {
			
			TRACE("variableExpCS", "Attribute: " + simpleName);
			attr = expressionsFactory.createAttributeCallExp();
			attr.setReferredAttribute(eattr);
			attr.setType(EcoreEnvironment.getOclType(eattr));
			if (source != null) {
				attr.setSource(source);
			} else {
				VariableExp src = expressionsFactory.createVariableExp();
				VariableDeclaration implicitSource = env.lookupImplicitSourceForAttribute(simpleName);
				src.setType(implicitSource.getType());
				src.setReferredVariable(implicitSource);
				src.setName(implicitSource.getVarName());
				attr.setSource(src);
			}
			initPropertyPositions(attr, (OclToken) t);
			astNode = attr;
						
		} else if ((eref = env.lookupReference( sourceElementType, simpleName)) != null) {
			TRACE("variableExpCS", "Reference: " + simpleName);//$NON-NLS-2$//$NON-NLS-1$
			ref = expressionsFactory.createAssociationEndCallExp();
			ref.setReferredAssociationEnd(eref);
			ref.setType(EcoreEnvironment.getOclType(eref));
			
			if (source != null) {
				ref.setSource(source);
			} else {
				VariableExp src = expressionsFactory.createVariableExp();
				VariableDeclaration implicitSource = env.lookupImplicitSourceForAssociationEnd(simpleName);
				src.setType(implicitSource.getType());
				src.setReferredVariable(implicitSource);
				src.setName(implicitSource.getVarName());
				ref.setSource(src);
			}
			initPropertyPositions(ref, (OclToken) t);
			astNode = ref;
			
		} else if ((assocClass = env.lookupAssociationClassReference(sourceElementType, simpleName)) != null) {
			TRACE("variableExpCS", "Association class: " + simpleName);//$NON-NLS-2$//$NON-NLS-1$
			acref = expressionsFactory.createAssociationClassCallExp();
			acref.setReferredAssociationClass(assocClass);
			acref.setType(assocClass);
			
			if (source != null) {
				acref.setSource(source);
			} else {
				VariableExp src = expressionsFactory.createVariableExp();
				VariableDeclaration implicitSource = env.lookupImplicitSourceForAssociationClass(simpleName);
				src.setType(implicitSource.getType());
				src.setReferredVariable(implicitSource);
				src.setName(implicitSource.getVarName());
				acref.setSource(src);
			}
			initPropertyPositions(acref, (OclToken) t);
			astNode = acref;
			
		} else {
			if (source != null && (vdcl = env.lookup(simpleName)) != null) {
                String message = NLS.bind(VarInNavExp_ERROR_,
                        new Object[] { simpleName });
                ERROR("variableExpCS", message);//$NON-NLS-1$
			} else {
                String message = NLS.bind(UnrecognizedVar_ERROR_,
                        new Object[] { simpleName });
                ERROR("variableExpCS", message);//$NON-NLS-1$
			}
		}
		
		/*
		 * If the source type is a collection, then need there is an implicit COLLECT operator.
		 * Not that this rule is not called after "->".
		 */
		if (source != null && source.getType() instanceof CollectionType) {
			IteratorExp iterexp = expressionsFactory.createIteratorExp();
			
			VariableDeclaration itervar = genVariableDeclaration("VariableExpCS", env,
							null, sourceElementType, null, false, true, false);

			EList iters = iterexp.getIterators();
			iters.add(itervar);
			iterexp.setBody(astNode);
			iterexp.setName("collect");
			VariableExp vexp = expressionsFactory.createVariableExp();
			vexp.setType(itervar.getType());
			vexp.setReferredVariable(itervar);
			vexp.setName(itervar.getVarName());
			/* adjust the source variable for the body expression  to be the
			   newly generated implicit iterator variable */
			if (astNode instanceof AttributeCallExp) {
				attr.setSource(vexp);
				// the overall start and end positions are the property positions
				attr.setStartPosition(attr.getPropertyStartPosition());
				attr.setEndPosition(attr.getPropertyEndPosition());
			} else if (astNode instanceof AssociationEndCallExp) {
				ref.setSource(vexp);
				// the overall start and end positions are the property positions
				ref.setStartPosition(ref.getPropertyStartPosition());
				ref.setEndPosition(ref.getPropertyEndPosition());
			} else if (astNode instanceof AssociationClassCallExp) {
				acref.setSource(vexp);
				// the overall start and end positions are the property positions
				acref.setStartPosition(acref.getPropertyStartPosition());
				acref.setEndPosition(acref.getPropertyEndPosition());
			}
			iterexp.setSource(source);
			if (source.getType() instanceof SequenceType ||
					source.getType() instanceof OrderedSetType) {
				iterexp.setType(typesFactory.createSequenceType(astNode.getType()));
			} else {
				iterexp.setType(typesFactory.createBagType(astNode.getType()));
			}
			astNode = iterexp;			
			env.deleteElement(itervar.getVarName());			
	   	}
	}		
;


/*
 * LiteralExpCS 
 */
literalExpCS[Environment env] returns [OclExpression astNode] 
{	astNode = null;
} : 
	( 
		astNode = primitiveLiteralExpCS[env] 
	|	astNode = collectionLiteralExpCS[env]
	| 	astNode = tupleLiteralExpCS[env]
	| 	astNode = enumerationOrClassLiteralExpCS[env]
	)
;


/*
 * enumerationOrClassLiteralExpCS
 */
enumerationOrClassLiteralExpCS[Environment env] returns [OclExpression astNode]
{ 	astNode = null;
	Vector sequenceOfNames = null;
	String lastToken = null;
 
} :
	( t:PATHNAME )
	{
    	StringTokenizer tokenizer = new StringTokenizer(t.getText(), "::");
    	sequenceOfNames = new Vector();
    	while (tokenizer.hasMoreTokens()) {
    		lastToken = unquote(tokenizer.nextToken());
    		if (tokenizer.hasMoreTokens()) {
    			sequenceOfNames.add(lastToken);
    		}
    	}	
 		EEnumLiteral literal = null;		
		EClassifier enumType = env.lookupPathName(sequenceOfNames);
		if (enumType == null || ! (enumType instanceof EEnum)) {
			astNode = expressionsFactory.createUnspecifiedValueExp();
			
			// Check to see whether the pathname corresponds to a type
			sequenceOfNames.add(lastToken);
			EClassifier type = env.lookupPathName(sequenceOfNames);
			if (type == null) {		
                String message = NLS.bind(UnrecognizedEnum_ERROR_,
                        new Object[] { sequenceOfNames });
                ERROR("enumerationOrClassLiteralExpCS", message);//$NON-NLS-1$;                
			} else {
				astNode.setType(type);
			}		
		} else { // is an enum
			astNode = expressionsFactory.createEnumLiteralExp();
			literal = ((EEnum) enumType).getEEnumLiteral(lastToken);
			if (literal == null) {
                String message = NLS.bind(UnrecognizedEnum_ERROR_,
                        new Object[] { lastToken });
                ERROR("enumerationOrClassLiteralExpCS", message);//$NON-NLS-1$;
			}
			EnumLiteralExp litExp = (EnumLiteralExp) astNode;
			litExp.setReferredEnumLiteral(literal);
			astNode = litExp;
			if (enumType == null || literal == null) {
				astNode.setType(Types.OCL_VOID);
			} else {
				astNode.setType(enumType);
			}			
		}
		TRACE("enumerationOrClassLiteralExpCS", t.getText());	
	}	
;
	

/*
 * PrimitiveLiteralExpCS
 */
primitiveLiteralExpCS[Environment env] returns [LiteralExp astNode]
{ astNode = null;
} :
	
	( 	
		astNode = integerLiteralExpCS[env]
	|
		astNode = realLiteralExpCS[env]
	|
		astNode = stringLiteralExpCS[env]
	|
		astNode = booleanLiteralExpCS[env]
	)
;


/*
 * IntegerLiteralExpCS
 */
integerLiteralExpCS[Environment env] returns [IntegerLiteralExp astNode]
	{ astNode = null; } :
	
	( 	t:NUMBER_LITERAL )
	{ 	
		astNode = expressionsFactory.createIntegerLiteralExp();
		astNode.setIntegerSymbol(new Integer(t.getText()));
		astNode.setType(PrimitiveTypeImpl.OCL_INTEGER);
		astNode.setName("Integer");
		TRACE("integerLiteralExpCS", "Integer: " + t.getText());
	}
;

/*
 * RealLiteralExpCS
 */
realLiteralExpCS[Environment env] returns [RealLiteralExp astNode]
{ astNode = null; 
} :
	( t:REAL_LITERAL )
	{
		astNode = expressionsFactory.createRealLiteralExp();
		astNode.setRealSymbol(new Double(t.getText()));
		astNode.setType(PrimitiveTypeImpl.OCL_REAL);
		astNode.setName("Real");
		TRACE("realLiteralExpCS", "Real: " + t.getText());
	}
;


/*
 * BooleanLiteralExpCS
 */
booleanLiteralExpCS[Environment env] returns [BooleanLiteralExp astNode]
{ 	astNode = null; 
} :
	(
		"true"    
		{ 
			astNode = expressionsFactory.createBooleanLiteralExp();
			astNode.setBooleanSymbol(Boolean.TRUE);
		}
	|
		"false"   
		{ 
			astNode = expressionsFactory.createBooleanLiteralExp(); 
			astNode.setBooleanSymbol(Boolean.FALSE);
		}
	)
	{
		astNode.setType(PrimitiveTypeImpl.OCL_BOOLEAN);
		astNode.setName("Boolean");
		TRACE("boleanLiteralExpCS", "Boolean");
	}
;


/*
 * StringLiteralExpCS
 */
stringLiteralExpCS[Environment env] returns [StringLiteralExp astNode]
{ astNode = null; 
} :
	( t:STRING_LITERAL )
	{
		astNode = expressionsFactory.createStringLiteralExp();
		String stringLiteral = t.getText();
		if (stringLiteral.length() <= 2) {
			astNode.setStringSymbol("");
		} else {
			astNode.setStringSymbol(stringLiteral.substring(1, stringLiteral.length()-1));
		}
		astNode.setType(PrimitiveTypeImpl.OCL_STRING);
		astNode.setName("String");
		TRACE("stringLiteralExpCS", "String: " + t.getText());
	}
;


/*
 * CollectionLiteralExpCS
 */
collectionLiteralExpCS[Environment env] returns [CollectionLiteralExp astNode]
{
	astNode = null;
	CollectionKind kind = null;
	CollectionLiteralPart collectionLiteralPartExp = null;
	EList collectionParts = null;
	EClassifier type = null;
	CollectionType resultType = null;
} :
	(
		resultType = collectionTypeIdentifierCS		 
		{	if (resultType instanceof SetType)
				kind = CollectionKind.SET_LITERAL; 
			else if (resultType instanceof BagType)
				kind = CollectionKind.BAG_LITERAL;
			else if (resultType instanceof  SequenceType)
				kind = CollectionKind.SEQUENCE_LITERAL;
			else if (resultType instanceof OrderedSetType)
				kind = CollectionKind.ORDERED_SET_LITERAL;
									
			astNode = expressionsFactory.createCollectionLiteralExp();
			astNode.setKind(kind);
			collectionParts = astNode.getParts();
		}					   
		LBRACE 
		(
			collectionLiteralPartExp = collectionLiteralPartCS[env]
			{ 
				collectionParts.add(collectionLiteralPartExp);				
				type = collectionLiteralPartExp.getType();				
			}			
			( COMMA collectionLiteralPartExp = collectionLiteralPartCS[env]
				{ 
					EClassifier type1 = collectionLiteralPartExp.getType();					
					type = AnyTypeImpl.commonSuperType(type, type1);
					collectionParts.add(collectionLiteralPartExp);
				}
			)*
		)? 
		RBRACE
		{  
			
			if (collectionParts.isEmpty()) {
				resultType.setElementType(Types.OCL_VOID);
				resultType.setName(resultType.getName() + "()");
			} else {
				resultType.setElementType(type);
				resultType.setName(resultType.getName() + "(" + type.getName() + ")" );
			}
			astNode.setType(resultType);
			 
		}
					
	)
;


/*
 * collectionLiteralPartCS
 */
collectionLiteralPartCS[Environment env] returns [CollectionLiteralPart astNode]
{
 	astNode = null;
 	OclExpression expr1 = null;
 	OclExpression expr2 = null;
 	CollectionRange collRange = null;
 	CollectionItem collItem = null;
} :
 	(
 		(
 			expr1 = oclExpressionCS[env]
 			( DOTDOT expr2 = oclExpressionCS[env] 
 				{
 					collRange = expressionsFactory.createCollectionRange();
 					collRange.setFirst(expr1);
 					collRange.setLast(expr2);
 					collRange.setType(expr1.getType());
 					// TODO:  What types are allowed in ranges.  Only Integers?
 					if (expr1.getType() != expr2.getType()) {
                        ERROR(
                                "collectionLiteralPartCS", FirstLastTypeMismatch_ERROR_);//$NON-NLS-1$;
 					}
 					astNode = collRange;
 					TRACE("collectionLiteralPartCS", "collection range");
 				}
 			) ?
 		) 
 	)
 		
 	{ 
 		if (expr2 == null) {
 			collItem = expressionsFactory.createCollectionItem();
 			collItem.setType(expr1.getType());
 			collItem.setItem(expr1);
 			astNode = collItem;
 			TRACE("collectionLiteralPartCS", "collection item");
 		}
 	}
;


/*
 * tupleLiteralExpCS
 */
tupleLiteralExpCS[Environment env] returns [TupleLiteralExp astNode]
{
	astNode = null;
	VariableDeclaration vdcl = null;
	EList tupleParts = null;
	EList vdcls = null;
	HashSet names = null;
	String typeName = null;
} :
	(
		"Tuple" LBRACE
		{ 
			astNode = expressionsFactory.createTupleLiteralExp();
			tupleParts = astNode.getTuplePart();
			vdcls = new BasicEList();
			TRACE("tupleLiteralExpCS", "Tuple");
			typeName = "Tuple (";
		}
		vdcl = variableDeclarationCS[env, false]
		{ 
			tupleParts.add(vdcl); 
			vdcls.add(vdcl);
			
			String name = vdcl.getVarName();
			names = new HashSet();		
			names.add(name);
			TRACE("tupleLiteralExpCS", " name = " + name);
			if (vdcl.getType() == null) {
                String message = NLS.bind(MissingTypeDecl_ERROR_,
                        new Object[] { name });
                ERROR("tupleLiteralExpCS", message);//$NON-NLS-1$;
			}
			if (vdcl.getInitExpression() == null) {
                String message = NLS.bind(MissingInit_ERROR_,
                        new Object[] { name });
                ERROR("tupleLiteralExpCS", message);//$NON-NLS-1$;
			}
			typeName += vdcl.getVarName() + ":" + vdcl.getType().getName();
		}
		( COMMA vdcl = variableDeclarationCS[env, false] 
			{ 
				tupleParts.add(vdcl);
				vdcls.add(vdcl);
				name = vdcl.getVarName();
				TRACE("tupleLiteralExpCS", " name = " + name);
				if (vdcl.getType() == null) {
                    String message = NLS.bind(
                            MissingTypeDecl_ERROR_,
                            new Object[] { name });
                    ERROR("tupleLiteralExpCS", message);//$NON-NLS-1$;
				}
				if (vdcl.getInitExpression() == null) {
	                String message = NLS.bind(
	                        MissingInit_ERROR_, new Object[] { name });
	                ERROR("tupleLiteralExpCS", message);//$NON-NLS-1$;
				}
				if (names.contains(name)) {
                    String message = NLS.bind(
                            DuplicateNameInTuple_ERROR_,
                            new Object[] { name });
                    ERROR("tupleLiteralExpCS", message);//$NON-NLS-1$;
					vdcl.setVarName(null);
				} else {
					names.add(name);
				}
				typeName += ", " + vdcl.getVarName() + ":" + vdcl.getType().getName();
			}
		) *
		RBRACE
		{ 
			TupleType tt = typesFactory.createTupleType(vdcls);
			tt.setName(typeName + "}");
			astNode.setType(tt);
		}
	)
;
 		
 
/*
 * iteratorExpCS
 */
iteratorExpCS[Environment env, OclExpression source] returns [IteratorExp astNode]
{ 
	astNode = null; 
	String name = null;
} :
	(    
		(   /* Collection iterators */
		   	"forAll"   	
		   	{ name = "forAll"; } 
		|  	"exists"   	
			{ name = "exists";}
		|  	"isUnique" 
			{ name = "isUnique"; } 
		|  	"any"      	
			{ name = "any";  }
		|  	"one"      	
			{ name = "one"; }
		|  	"collect"  	
			{ name = "collect"; } 
		|  	"select"   	
			{ name = "select"; }
		|	"reject"	
			{ name = "reject";   }
		|	"collectNested"	
			{name = "collectNested"; }
		|	"sortedBy"	
			{ name = "sortedBy"; }	
			 
		) 
		LPAREN astNode = iterContents[env, name, source] RPAREN
	)
;

/*
 *iterContents
 */
iterContents[Environment env, String name, OclExpression source] returns [IteratorExp astNode]
{ 
	astNode = null; 
	VariableDeclaration vdcl = null;
	VariableDeclaration vdcl1 = null;
	OclExpression expr = null;
	EList iterators = null;
} :
	(
		{ LT(2).getText().equals(":") || LT(2).getText().equals(",")
   	 	 || LT(2).getText().equals(";") || LT(2).getText().equals("|") }?
   	 	  				 
		( options { warnWhenFollowAmbig = false; } :
			(vdcl = variableDeclarationCS[env, true] 
			{	
				astNode = expressionsFactory.createIteratorExp();
				astNode.setName(name);
				iterators = astNode.getIterators();	
				if (vdcl.getType() == null) {
					EClassifier sourceType = source.getType();
					if (sourceType instanceof CollectionType) {
						vdcl.setType(((CollectionType) sourceType).getElementType());
					}
				}
				iterators.add(vdcl);
			}
	  		( 
	  			COMMA vdcl1 = variableDeclarationCS[env, true] 
	  			{
	  				if (vdcl1.getType() == null) {
						EClassifier sourceType = source.getType();
						if (sourceType instanceof CollectionType) {
							vdcl1.setType(((CollectionType) sourceType).getElementType());
						}
	  				}
	  				iterators.add(vdcl1);
	  			} 
	  	 	) ?
	  		BAR
	  		) 	  	
	  		expr = oclExpressionCS[env] 
		) 
	|		
		{ 
			astNode = expressionsFactory.createIteratorExp();
			astNode.setName(name);
			iterators = astNode.getIterators();	
			// Synthesize the iterator expression.
			vdcl = genVariableDeclaration("iteratorExpCS", env, null, 
				((CollectionType) source.getType()).getElementType(), null, false, true, false);
			iterators.add(vdcl);
		}
		( expr = oclExpressionCS[env] )
	)	  	
		
	
	{ 
		TRACE("oclIteratorExpCS: ", name);
		
		if (name.equals("forAll") || name.equals("exists") || name.equals("one") || name.equals("isUnique")) {
			astNode.setType(PrimitiveTypeImpl.OCL_BOOLEAN);
		} else if (name.equals("select") || name.equals("reject") ) {
			astNode.setType(source.getType());
		} else if (name.equals("collect")) {
			// The result type for collect must be flattened
			EClassifier elementType = expr.getType();
			while (elementType instanceof CollectionType) {
				elementType = ((CollectionType) elementType).getElementType();
			}
			if (source.getType() instanceof SequenceType || 
							source.getType() instanceof OrderedSetType) {
				astNode.setType(typesFactory.createSequenceType(elementType));
			} else {
				astNode.setType(typesFactory.createBagType(elementType));
			}
		} else if (name.equals("collectNested")) {
			if (source.getType() instanceof SequenceType || 
							source.getType() instanceof OrderedSetType) {
				astNode.setType(typesFactory.createSequenceType(expr.getType()));
			} else {
				astNode.setType(typesFactory.createBagType(expr.getType()));
			}
		} else if (name.equals("any")) {
			astNode.setType(((CollectionType) source.getType()).getElementType());
		} else if (name.equals("sortedBy")) {
			if ((source.getType() instanceof SequenceType) ||
					source.getType() instanceof BagType) {
				SequenceType osType = typesFactory.createSequenceType();
				osType.setElementType(((CollectionType) source.getType()).getElementType());
				astNode.setType(osType);
			} else { // set, ordered set
				OrderedSetType osType = typesFactory.createOrderedSetType();
				osType.setElementType(((CollectionType) source.getType()).getElementType());
				astNode.setType(osType);
			}
		} 
				
		astNode.setBody(expr);
		astNode.setSource(source);
		
		env.deleteElement(vdcl.getVarName());
		if (vdcl1 != null) {
			env.deleteElement(vdcl1.getVarName());
		}		
	}
;



/*
  iterateExpCS
 */
iterateExpCS[Environment env, OclExpression source] returns [IterateExp astNode]
{ 
	astNode = null; 
	VariableDeclaration vdcl = null;
	VariableDeclaration vdcl1 = null;
	OclExpression expr = null;
} :	
	(
		( 
			"iterate" LPAREN 
			vdcl = variableDeclarationCS[env, true] 
			( SEMICOLON vdcl1 = variableDeclarationCS[env, true] )? BAR
		)
		{
			/* If there is only one variable declaration, then it is the result, vdcl1. 
		   		The missing variable declaration is treated as the implicit iterator vdcl.
		 	*/
			if (vdcl1 == null) {
				vdcl1 = vdcl;
				vdcl = null;
			}	
		
			if (vdcl == null) { // synthesize a new variable declaration.		
				vdcl = genVariableDeclaration("iterateExpCS", env, null, 
						((CollectionType) source.getType()).getElementType(), null, false, true, false);	
			} 
			if ( vdcl.getType() == null) {
				vdcl.setType(((CollectionType) source.getType()).getElementType());
			}
		} 
		( expr = oclExpressionCS[env]   RPAREN )
	)
	{
		TRACE("iterateExpCS", "iterate");
		astNode = expressionsFactory.createIterateExp();
		astNode.setName("iterate");			
		EList iterator = astNode.getIterators();
		iterator.add(vdcl);
		astNode.setSource(source);
		astNode.setResult(vdcl1);
		astNode.setBody(expr);
		
		
		if (vdcl1.getType() == null) {
            String message = NLS.bind(DeclarationType_ERROR_,
                    new Object[] { vdcl1.getVarName() });
            ERROR("iterateExpCS", message);//$NON-NLS-1$
		}
		
		astNode.setType(vdcl1.getType());
		
		if (vdcl1.getInitExpression() == null) {
            String message = NLS.bind(DeclarationNoInitExp_ERROR_,
                    new Object[] { vdcl1.getVarName() });
            ERROR("iterateExpCS", message);//$NON-NLS-1$
		}
		if (vdcl.getInitExpression() != null) {
            String message = NLS.bind(DeclarationInitExp_ERROR_,
                    new Object[] { vdcl1.getVarName() });
            ERROR("iterateExpCS", message);//$NON-NLS-1$
		} 
		
		env.deleteElement(vdcl.getVarName());
		env.deleteElement(vdcl1.getVarName());
		
	}
;



/*
 * operationCallExpCS
 */
operationCallExpCS[Environment env,  OclExpression source, boolean dotOperator] returns [OclExpression astNode]
{
	astNode = null;
	EList args = null;
	String operationName = null;
	IntegerLiteralExp intSource = null;
	OclExpression referenceArg = null;
	boolean isMarkedPre = false;
	OclToken oclToken = null;
	OclToken nameToken = null;
} :
	(
		(
			( t:"oclAsType"
				{ operationName = "oclAsType";
				  nameToken = (OclToken) t; }
			)
		|
			( t1:"oclIsKindOf"
				{ operationName = "oclIsKindOf";
				  nameToken = (OclToken) t1; }
			)
		|
			( t2:"oclIsTypeOf" 
				{ operationName = "oclIsTypeOf";
				  nameToken = (OclToken) t2; }
			)
		)
		( args = operationArgs[env, operationName] )

	|
		(   (  t3:"closure"
				{ operationName = "closure";
				  nameToken = (OclToken) t3; } 
		    |
			   t4:"closureAll"
				{ operationName = "closureAll";
				  nameToken = (OclToken) t4; }
			)
			
			 LPAREN
			    { oclToken = (OclToken) LT(1); } // don't include the paren
			 referenceArg = modelPropertyCallExpCS[env, source]
		     referenceArg = dotOrArrowExtension[env, referenceArg, oclToken]
		     { 
		     	args = new BasicEList();
		     	args.add(referenceArg); 
		     }
			 RPAREN
		)
		
	|
		(
			// TBD:  What to do with a real pathname (length > 1)
			t5:NAME
			LPAREN (args = argumentsCS[env] ) ? RPAREN
		)
		{  operationName = unquote(t5.getText());
		   nameToken = (OclToken) t5;  }			
	|
		(	//   45.someoperation(...)
			p:OPERATION_EXPR
		)
		{
			String text = p.getText();
			StringTokenizer tokenizer = new StringTokenizer(text, ".");
			intSource = expressionsFactory.createIntegerLiteralExp();
			intSource.setType(PrimitiveTypeImpl.OCL_INTEGER);
			intSource.setIntegerSymbol(new Integer(tokenizer.nextToken()));
			operationName = unquote(tokenizer.nextToken());
			nameToken = createFakeToken(
				((OclToken) p).getStartPosition() + text.indexOf('.' + 1),
				operationName.length());
		}
		(
			args = operationArgs[env, operationName]
		)
	) 

	{ 	
		/*
		 * The type of the operation is specified by a path expression
		 * or self, or by an explicit source expression.  The source expression
		 * may be a collection type (-> operation) or a regular navigation expression
		 * (. operation)
		 */
		OclExpression src = source;
		if (intSource != null) {
			src = intSource;  // source is an integer:  number.name(...)
		} else if (src == null) {  // create an implicit source
			VariableExp vexp = expressionsFactory.createVariableExp();
			VariableDeclaration implicitSource = 
					env.lookupImplicitSourceForOperation(operationName, args);
			vexp.setType(implicitSource.getType());
			vexp.setReferredVariable(implicitSource);
			vexp.setName(implicitSource.getVarName());
			src = vexp;
		}

		astNode = genOperationCallExp(env, "operationCallExpCS", operationName, src, args);
		
		((OperationCallExp) astNode).setMarkedPre(isMarkedPre);
		initPropertyPositions((OperationCallExp) astNode, nameToken);

		/*
		 * If the source type is a collection and operator is ".",
		 * then there is an implicit COLLECT operator.
		 */
		if (dotOperator && source.getType() instanceof CollectionType) {
			IteratorExp iterexp = expressionsFactory.createIteratorExp();
			
			VariableDeclaration itervar = genVariableDeclaration("operationCallExpCS", env,
				null, ((CollectionType) source.getType()).getElementType(), null, false, true, false);

			EList iters = iterexp.getIterators();
			iters.add(itervar);
			iterexp.setBody(astNode);
			iterexp.setName("collect");
			VariableExp vexp = expressionsFactory.createVariableExp();
			vexp.setType(itervar.getType());
			vexp.setReferredVariable(itervar);
			vexp.setName(itervar.getVarName());
			/* adjust the source variable for the body expression  to be the
			   newly generated implicit iterator variable */
			
			OperationCallExp opcallexp = (OperationCallExp) astNode;
			opcallexp.setSource(vexp);

			iterexp.setSource(source);
			if (source.getType() instanceof SequenceType ||
									source.getType() instanceof OrderedSetType) {
				iterexp.setType(typesFactory.createSequenceType(astNode.getType()));
			} else {
				iterexp.setType(typesFactory.createBagType(astNode.getType()));
			}
			astNode = iterexp;
			env.deleteElement(itervar.getVarName());			
	   	}
	}
;

/*
 * operationArgs can be either an OclExpression list or an EClassifier.
 */
operationArgs[Environment env, String operName] returns [BasicEList arguments]
{ 	arguments = null;
	EClassifier typeArg;
}  :
	(
			
	{ operName.equals("oclAsType") || operName.equals("oclIsTypeOf") ||
				operName.equals("oclIsKindOf") }?	
			( LPAREN typeArg = typeCS[env] RPAREN )
			{
				if (typeArg == null) {
                    ERROR("operationArgs", UnrecognizedType_ERROR_);//$NON-NLS-1$
				}
				arguments = new BasicEList();
				UnspecifiedValueExp arg = expressionsFactory.createUnspecifiedValueExp();
				arg.setType(typeArg);
				arguments.add(arg);
				
				OclToken typeToken = OclTokenAdapter.getToken(typeArg);
				arg.setStartPosition(typeToken.getStartPosition());
				arg.setEndPosition(typeToken.getEndPosition());
			}
		|
			( LPAREN (arguments = argumentsCS[env] ) ? RPAREN )
	)
;
			


/*
 * argumentsCS
 */
argumentsCS[Environment env] returns  [BasicEList arguments]  
{	arguments = null;
  	OclExpression expr; 
} :

	(  expr = oclExpressionCS[env]
		( COMMA   arguments= argumentsCS[env] )?
    ) 

	{      
        if (arguments == null) arguments = new BasicEList();
	    arguments.add(0, expr);	    
	}
;   


class OclLexer extends Lexer;

options {
	  k=3;
	  
  //	 force vocabulary to be all usual unicode characters except for special 
  // ones that ANTLR uses internally (0 to 2) and ffff (which is EOF (-1)).
			  charVocabulary = '\u0003'..'\ufffe';
	}

{
	/** Number of characters absolutely consumed so far. */
	int charCount = 0;
	int tokenStartChar = 0;
	
	/* Override panic to not do a system.exit(). */
	public void panic(String s) {
		throw new Error("CharScanner; panic: " + s);
	}

	/* Override panic to not do a system.exit(). */
	public void panic() {
		throw new Error("CharScanner: panic");
	}
	
	public void setTokenObjectClass(String className) {
		// ignore the requested class name and use the OclToken class
		tokenObjectClass = OclToken.class;
	}
	
	public void consume() throws CharStreamException {
		super.consume();
		
		if (inputState.guessing == 0) {
			// not guessing means that it's consumed for good
			charCount++;
		}
	}
	
	public void resetText() {
		super.resetText();
		tokenStartChar = charCount;
	}
	
	protected Token makeToken(int t) {
		OclToken result = (OclToken) super.makeToken(t);
		result.setStartPosition(tokenStartChar);
		return result;
	}
	
	/**
	 * Sets the (initial) character count.  Useful for offsetting the token
	 * position information to account for a string prefix invisible to the
	 * client.
	 */
	public void setCharacterCount(int count) {
		charCount = count;
	}
}

// NEED TO HANDLE  COMMENTS

// whitespace
//WS: 
//    ( ' '
//    | '\t'
//    | ( '\r' | '\n' ) 
//    )
//    { $setType(Token.SKIP); }
//;

// Whitespace -- ignored 
WS : ( ' ' | '\t' | '\f' 
// handle newlines | ( options {generateAmbigWarnings=false;} : "\r\n" 
// Evil DOS 
| '\r' 
// Macintosh 
| '\n' 
// Unix (the right way) ) 
{ newline(); } )+ { _ttype = Token.SKIP; } 
; 

// Single-line comments 
SL_COMMENT : "--" (~('\n'|'\r'))* ('\n'|'\r'('\n')?)? 
 	{$setType(Token.SKIP); newline();} 
; 
     

ARROW: "->" ;
BAR: '|';
COLON: ':' ;
COMMA: ',' ;
DIVIDE: '/' ;
DOT: '.' ;
DOTDOT: "..";
DOUBLECOLON: "::" ;
EQUALS:'=' ;
GE: ">=" ;
GT: '>';
LE: "<=" ;
LT: '<';
MINUS: '-' ;
MULTIPLY: '*' ;
NEQUALS: "<>" ;
LPAREN: '(' ;
RPAREN: ')' ;
LBRACKET: '[';
RBRACKET: ']';
LBRACE: '{';
RBRACE: '}';
PRE: "@pre" ;
PLUS: '+' ;
SEMICOLON: ';' ;


// a numeric literal
protected NUMBER_LITERAL:
    (DIGIT)+
;

protected REAL_LITERAL:
	(NUMBER_LITERAL DOT NUMBER_LITERAL)
	(EXPONENT) ?
;

protected EXPONENT : 
	('e'|'E') ('+'|'-')? ('0'..'9')+
; 


protected OPERATION_EXPR:
	(NUMBER_LITERAL DOT NAME)
;

// 1.34.56   - - numeric url name
protected NUMERIC_URL :
	NUMBER_LITERAL ( DOT (NUMBER_LITERAL | NAME))+
;

// a URL as part of a pathname   1.34.56::a::b::c
protected NUMERICPATHNAME : 
	NUMERIC_URL ( DOUBLECOLON (NAME|NUMBER_LITERAL) )+
;


NUMBER_OR_REAL_OR_RANGE_OR_OPERATION:
    ( NUMERIC_URL DOUBLECOLON ) => NUMERICPATHNAME {$setType(NUMERICPATHNAME); }
  |
  	( NUMBER_LITERAL DOT NAME) => OPERATION_EXPR { $setType(OPERATION_EXPR); }
  |
	( NUMBER_LITERAL DOT NUMBER_LITERAL)  => REAL_LITERAL {$setType(REAL_LITERAL);}
  | 
  	( NUMBER_LITERAL )  => NUMBER_LITERAL {$setType(NUMBER_LITERAL);}
;  
  	

// decimal digit
protected DIGIT: '0'..'9' ;


STRING_LITERAL: 
	'\'' 
	(ESC|~('\''|'\\'))* 
	'\'' 
;
// escape sequence -- note that this is protected; it can only be called 
// from another lexer rule -- it will not ever directly return a token to 
// the parser 
// There are various ambiguities hushed in this rule. The optional 
// '0'...'9' digit matches should be matched here rather than letting
// them go back to STRING_LITERAL to be matched. ANTLR does the 
// right thing by matching immediately; hence, it's ok to shut off 
// the FOLLOW ambig warnings. 
protected ESC : '\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '"' | '\'' | '\\' | ('u')+ 
HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT 
| '0'..'3' 
( options { warnWhenFollowAmbig = false; } : '0'..'7' 
( options { warnWhenFollowAmbig = false; } : '0'..'7' )? )? | '4'..'7' 
( options { warnWhenFollowAmbig = false; } : '0'..'7' )? ) ; 
// hexadecimal digit (again, note it's protected!) 
protected HEX_DIGIT : ('0'..'9'|'A'..'F'|'a'..'f') ; 

// variable name
protected NAME:
	NONQUOTED_NAME | QUOTED_NAME
	;	
protected NONQUOTED_NAME:
	('a'..'z'|'A'..'Z'|'_'|'\u00c0'..'\ufffe')
	  ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\u00a0'..'\ufffe')*
;
protected QUOTED_NAME:
	'"'
	('a'..'z'|'A'..'Z'|'_'|'\u00c0'..'\ufffe')
	  ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'\u00a0'..'\ufffe'|' '|'\t'|('\\' '"'))*
	'"'
;

protected NAMEORDOTTEDNAME:
	NAME ( DOT NAME )*
;

// A path name is:   a::b::c
//					www.what.ever::a::b::c
protected PATHNAME:
NAMEORDOTTEDNAME ( DOUBLECOLON ( NAME | NUMBER_LITERAL ) )+ 
;

NAME_OR_PATHNAME:
//		(NAME DOUBLECOLON) => PATHNAME {$setType(PATHNAME);}
		(NAMEORDOTTEDNAME DOUBLECOLON) => PATHNAME {$setType(PATHNAME);}
	|
		( NAME ) => NAME {$setType(NAME); }
;
	

