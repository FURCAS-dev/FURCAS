#/**
# * <copyright>
# *
# * Copyright (c) 2003-2005 IBM Corporation and others.
# * All rights reserved.   This program and the accompanying materials
# * are made available under the terms of the Eclipse Public License v1.0
# * which accompanies this distribution, and is available at
# * http://www.eclipse.org/legal/epl-v10.html
# * 
# * Contributors: 
# *   IBM - Initial API and implementation
# *
# * </copyright>
# *
# * $Id: OCLMessages.properties,v 1.4 2006/04/04 18:07:25 cdamus Exp $
# */

# ==============================================================================
# Translation Instruction: section to be translated
# 
# Error messages from the OCL parser/interpreter.
# ==============================================================================

# Message that is substituted for an exception that otherwise does not have one.
# Tells the user that we don't know what happened.
no_message = (no message)

# ==============================================================================
# Translation Instruction: section to be translated
# 
# Error messages from the OCL parser/interpreter.
# ==============================================================================

BindingExist_ERROR_ = The name: ({0})  already has a binding: ({1})
UnknownOperation_ERROR_ = Unknown operation for type:  ({0})
IteratorNotImpl_ERROR_ = iterator ({0}) not yet implemented.
IndexOutOfRange_ERROR_ = Index ({0}) not in range ({1})..({2})
TupleFieldDoesntExist_ERROR_ = Cannot find tuple field ({0})
InvalidClass_ERROR_ =  The class ({0}) is not a valid classifier
InvalidDatatype_ERROR_ =  The datatype ({0}) is not a valid classifier

NullProperty_ERROR_ = Null referred property in PropertyCallExp ({0})
NullNavigationSource_ERROR_ = Null source in NavigationCallExp  ({0})
NullNavigationType_ERROR_ = Null type in NavigationCallExp  ({0})

NullOperation_ERROR_ = Null operation in OperationCallExp ({0})
NullSourceOperation_ERROR_ = Null source in OperationCallExp  ({0})
IllegalOperation_ERROR_ = Illegal operation ({0})
IllegalOpcode_ERROR_ = Illegal opcode for ({0})
TypeConformanceOperation_ERROR_ = Type of OperationCallExp is non-conformant ({0})
IllegalEnumLiteral_ERROR_ = Illegal EnumLiteralExp: ({0})
VariableTypeMismatch_ERROR_= The type of a VariableExpression must match the type of the variable.
MissingNameInVariableDeclaration_ERROR_= Missing Name in Variable Declaration.
TypeConformanceInit_ERROR_= Init expression type does not conform to variable type.

NonBooleanIfExp_ERROR_= If Expression condition must be boolean-valued: ({0})
TypeConformanceIfExp_ERROR_= If Expression type is not equal to common super type of then and else part types: ({0})
TypeConformanceIntegerLiteral_ERROR_= Integer Literal Expression must be of type Integer.
TypeConformanceRealLiteral_ERROR_= Real Literal Expression must be of type Real.
TypeConformanceStringLiteral_ERROR_= String Literal Expression must be of type String.
TypeConformanceBooleanLiteral_ERROR_= Boolean Literal Expression must be of type Boolean.
TypeConformanceNullLiteral_ERROR_= Null Literal Expression must be of type OclVoid.
TypeConformanceInvalidLiteral_ERROR_= OclInvalid Literal Expression must be of type Invalid.
TypeConformanceLetExp_ERROR_= Let Expression type conformance error: ({0}) != ({1})
TypeConformanceIterateExp_ERROR_= Iterate Expression type must be the same as result variable type ({0})
TypeConformanceIterateExpBody_ERROR_= Iterate Expression body type must conform to the result type ({0})
TypeConformanceIterateExpLoopVar_ERROR_= Iterate Expression iteration variable must have same type as source element type ({0})
TypeConformanceIteratorResult_ERROR_= Iterator result type must be boolean ({0})
TypeConformanceCollectSequence_ERROR_= Collect type must be sequence ({0})
TypeConformanceCollectBag_ERROR_= Collect type must be bag ({0})
TypeConformanceClosure_ERROR_= Closure type must be Set ({0})
ElementTypeConformanceClosure_ERROR_= Closure type {{0}) does conform to source type ({1})
TypeConformanceSelectReject_ERROR_= Select/reject type must be the same as the source type ({0})
TypeConformanceIterateExpBodyBoolean_ERROR_= Iterate Expression body type must be boolean ({0})
TypeConformanceCollectionLiteralExp_ERROR_= Missing or Illegal Type in Collection Literal Expression: ({0})
TypeConformanceSetLiteral_ERROR_= Set literal must have SetType: ({0})
TypeConformanceOrderedSetLiteral_ERROR_= Ordered set literal must have OrderedSetType: ({0})
TypeConformanceBagLiteral_ERROR_= Bag literal must have BagType: ({0})
TypeConformanceSequenceLiteral_ERROR_= Sequence literal must have SequenceType: ({0})
TypeConformanceEmptyCollection_ERROR_= Empty collection must have element type Classifier: ({0})
TypeConformanceCollectionElementType_ERROR_= Collection Element Type does not match the supertype of the element types: ({0})
TypeConformanceTupleLiteralExp_ERROR_= Tuple Literal Expression must be of Type Tuple.
TypeConformanceTupleLiteralExpParts_ERROR_= The tuple literal expression parts do not match the expression type

TupleLiteralExpressionAttribName_ERROR_= Tuple Literal Expression: Attribute name not a field: ({0}) ({1})
TupleLiteralExpressionRefName_ERROR_= Tuple Literal Expression: Reference name not a field: ({0}) ({1})
TupleDuplicateName_ERROR_= Duplicate field name in tuple: ({0})
MissingPropertyInTupleLiteralPart_ERROR_= Tuple literal part missing attribute reference
MissingTypeInTupleLiteralPart_ERROR_= Tuple literal part missing type reference
MissingValueInTupleLiteralPart_ERROR_= Tuple literal part missing value
TuplePartType_ERROR_= Tuple literal part type does not match attribute type
TypeConformanceTuplePartValue_ERROR_= Tuple literal part value does not conform to tuple attribute type

TypeConformanceTypeExp_ERROR_= Type of Type Expression must be TypeType: ({0})
TypeExpMissingType_ERROR_= Missing referred type in Type Expression

RecursiveContainment_ERROR_= Recursive containment not allowed for ({0})
EMFOCLConversion_ERROR_= Cannot convert EMF type ({0}) to an OCL equivalent.
UnknownOperationOwnerType_ERROR_= Unknown owner type: ({0}) for operation: ({1})
IllegalSignature_ERROR_= illegal operation signature: ({0})

IteratorSource_ERROR_= The source of an iterator must be a collection ({0})
MissingInitIterateExpLoopVar_ERROR_= Iterate Expression loop iteration variable may not be initialized ({0})

IncompleteVariableDeclaration_ERROR_ = Incomplete Variable Declaration: ({0})
IncompleteLetExp_ERROR_ = Incomplete Let Expression: ({0})
IncompleteIterateExp_ERROR_ = Incomplete Iterate Expression: ({0})
IncompleteIfExp_ERROR_= Incomplete If Expression: ({0})
IncompleteIteratorExp_ERROR_= Incomplete Iterator Expression: ({0})

MissingInitIterateExp_ERROR_ = Iterate Expression result must have an init expression ({0})

StringParse_ERROR_ = The string cannot be parsed: ({0})
ErrorMessage_ERROR_ = ERROR in ({0}): ({1})
VariableUsed_ERROR_ = Variable already used: ({0})
VariableDeclaration_ERROR_ = Variable declaration failed
OperationNotFound_ERROR_ = Cannot find operation ({0}) for the type ({1})
BadArg_ERROR_ = Bad argument expression
PackageNotFound_ERROR_ = Unable to find package
UnrecognizedContext_ERROR_ = Unrecognized context: ({0})
PropertyConstraints_ERROR_ = Property context may define at most one init and one derive expression: ({0})
BooleanForIf_ERROR_ = expect boolean condition for if statement
MissingTypeForVar_ERROR_ = Missing type for variable ({0})
MissingInitForVar_ERROR_ = Missing init expression for variable ({0})
VarInNavExp_ERROR_ = Variable cannot appear in the middle of a navigation expression: ({0})
UnrecognizedVar_ERROR_ = unrecognized variable: ({0})
DeclarationType_ERROR_ = Declaration for ({0}) must have a type
DeclarationNoInitExp_ERROR_ = Declaration for ({0}) must have an initial expression
DeclarationInitExp_ERROR_ = Declaration for ({0}) must not have an initial expression
UnrecognizedType_ERROR_ = Unknown type ({0})
UnrecognizedVarType_ERROR_ = Unrecognizable type for variable: ({0})
NoType_ERROR_ = Type not provided for variable: ({0})
NoInitExp_ERROR_ = Init expr not provided for variable: ({0})
MissingTypeDecl_ERROR_ = Missing type declaration for variable: ({0})
DuplicateNameInTuple_ERROR_ = Duplicate name in tuple ({0})
InitExpNotAllowed_ERROR_ = Initialize expressions not allowed in types: ({0})
MissingInit_ERROR_ = Missing initializer for variable: ({0})
UnrecognizedPackageOrEnum_ERROR_ = Unrecognizable package or enum ({0})
UnrecognizedEnum_ERROR_ = Unknown enumeration literal ({0})
FirstLastTypeMismatch_ERROR_ = First and last type mismatch
NullArgExpectEObj_ERROR_ = Argument is null, expect EObject
NullArgExpectlist_ERROR_ = Argument is null, expect List.
BooleanQuery_ERROR_ = Query must be a boolean-valued constraint.
InputListExpectEObjs_ERROR_ = Input list items must be EObjects
CheckBool_ERROR_ = Check can only be called on boolean valued constraints
Noncomforming_ERROR_ = AnyType: Nonconforming arguments for type ({0}) and operation ({1})
SourceEClass_ERROR_ = AnyType: the source of operation: ({0}) must be an EClass or implement Comparable
SourceOperationCompareTo_ERROR_ = AnyType: source for operation ({0}) must have compatible method: compareTo
ResultCompareToInt_ERROR_ = AnyType: the result of the compareTo method must be Integer
TypeMismatch_ERROR_ = Conformance Type Mismatch. No common supertype: ({0}), ({1})
CompareTypeMismatch_ERROR_ = TypeCompare: Conformance Type Mismatch: ({0}), ({1})
UnrecognizedCollectionOperation_ERROR_= Unrecognizable collection operation: ({0})
CollectionType_ERROR_ = Collection type conformance failure: ({0}).({1}) 
CollectionSuperType_ERROR_ = Collection.commonSuperType: conformance error: ({0}), ({1})
# duplicate
#SumOperator_ERROR_= Conformance failure: The sum() operator can only be applied to Numeric types collections, not: ({0})
SumOperator_ERROR_= OclCollection::sum only works for collections of Numeric types
TupleTypeMismatch_ERROR_= Conformance Tuple Type Mismatch: ({0}), ({1})
TupleFieldNotFound_ERROR_= Conformance Type Mismatch, field ({0}).({1}) not found in ({2})
TupleFieldNumMismatch_ERROR_= Tuple type conformance, number of fields mismatch: ({0}) ({1})
RemoveUnsupported_ERROR_= remove not supported
OCLCollectionKindNotImpl_ERROR_ = OCL collection kind ({0}) is not implemented in the java collection factory.
IsInStateSignature_ERROR_= oclIsInState() must have a single State argument
NoSuchState_ERROR_= No such state ({0}) in type ({1})
MissingStateInStateExp_ERROR_= Missing referredState in StateExp
MissingStateNameInStateExp_ERROR_= Unnamed state referenced in StateExp
UnrecognizedMessageType_ERROR_= Unrecognized operation or signal ({0}) in message expression
AmbiguousMessageType_ERROR_= Ambiguous message expression: ({0}) could be an operation or a signal
IllegalUnspecifiedValueExp_ERROR_= Unspecified values may only be used in message expressions
MissingMessageTarget_ERROR_= Missing target in message expression
MissingOperationInCallAction_ERROR_ Missing operation in CallOperationAction
MissingSignalInCallAction_ERROR_ Missing signal in SendSignalAction
MessageArgumentCount_ERROR_= Wrong number of arguments for message type ({0})
MessageArgConformance_ERROR_= Argument ({1}) does not conform to parameter ({0}) of message
DefinitionConstraintFeature_ERROR_= Unknown defined feature in definition constraint of {0}
DefinitionConstraintConformance_ERROR_= Def expression type ({0}) does not conform to defined feature type ({1})
DuplicateProperty_ERROR_= Property ({0}) already defined in type ({1})
DuplicateOperation_ERROR_= Operation ({0}) already defined in type ({1})
InitOrDerConstraintConformance_ERROR_= Initial or derived value expression type ({0}) does not conform to property "{1}" type ({2})

IllegalAtPre_ERROR_ = @pre may only be applied to model property calls
AtPreInPostcondition_ERROR_ = @pre may only be used in an operation postcondition constraint
BodyConditionNotAllowed_ERROR_ = Cannot specify body condition for void operation "{0}"
BodyConditionConformance_ERROR_ = Body condition does not conform to result type of operation "{0}": ({1}), ({2})
BodyConditionConformance2_ERROR_ = Body condition does not conform to result type of operation "{0}": {1}
OCLIsNewInPostcondition_ERROR_ = oclIsNew() may only be called in an operation postcondition constraint
IllegalQualifiers_ERROR_ = Qualifiers may only be applied to navigation calls
MismatchedQualifiers_ERROR_ = Qualifiers do not conform to expected types
MissingAssociationClass_ERROR_ = Missing AssociationClass in AssociationClassEnd: {0}
AssociationClassQualifierCount_ERROR_ = Cannot have more than one qualifier role on association class navigation
AssociationClassQualifierType_ERROR_ = Qualifier on association class navigation must be a role of the navigation source
AssociationClassAmbiguous_ERROR_ = Qualifier needed to select navigation direction in reflexive association class
BodyConditionForm_ERROR_ = Body condition must have the form "result = <expr>" on operation "{0}"
OperationConstraintBoolean_ERROR_ = Constraint must be boolean-valued on operation "{0}"

# Error indicating an attempt to parse an OCL Expression as an invariant
# constraint, but the expression does not compute a boolean value
# args:
#   0 -  the name of the context classified on which the invariant is defined
InvariantConstraintBoolean_ERROR_ = Constraint must be boolean-valued on type "{0}"

InvalidOCL_ERROR_ = Invalid OCL

ParseCSTNodeType_ERROR_ = expected parser to return {0} but got {1}

OCLParseErrorCodes_LEX_ERROR = {0} {1} unexpected character ignored
OCLParseErrorCodes_ERROR = {0} {1} parsing terminated at this token
OCLParseErrorCodes_BEFORE = {0} {1} inserted before {2}
OCLParseErrorCodes_INSERTION = {0} {1} expected after {2}
OCLParseErrorCodes_INVALID = {0} {1} unexpected input discarded
OCLParseErrorCodes_SUBSTITUTION_SECONDARY = {0} {1} expected instead of {2}
OCLParseErrorCodes_DELETION = {0} {1} unexpected token(s)
OCLParseErrorCodes_MERGE = {0} merge tokens {2} to form {1}
OCLParseErrorCodes_MISPLACED = {0} {1} misplaced construct(s)
OCLParseErrorCodes_SCOPE = {0} missing {1} to complete scope
OCLParseErrorCodes_EOF = {0} End-of-File reached after this token {1}
OCLParseErrorCodes_INVALID_TOKEN = {0} token {1} is invalid

# row(start):column(start):row(end):column(end)
ErrorReport_RowColumn = {0}:{1}:{2}:{3}