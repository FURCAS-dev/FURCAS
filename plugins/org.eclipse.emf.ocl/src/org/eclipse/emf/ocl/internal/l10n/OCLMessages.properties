#/**
# * <copyright>
# *
# * Copyright (c) 2003-2006 IBM Corporation and others.
# * All rights reserved.   This program and the accompanying materials
# * are made available under the terms of the Eclipse Public License v1.0
# * which accompanies this distribution, and is available at
# * http://www.eclipse.org/legal/epl-v10.html
# * 
# * Contributors: 
# *   IBM - Initial API and implementation
# *
# * </copyright>
# *
# * $Id: OCLMessages.properties,v 1.6 2006/04/13 22:04:10 cdamus Exp $
# */

# ==============================================================================
# Translation Instruction: section to be translated
# 
# Error messages from the OCL parser/interpreter.
# ==============================================================================

# Message that is substituted for an exception that otherwise does not have one.
# Tells the user that we don't know what happened.
no_message = (no message)

# ==============================================================================
# Translation Instruction: section to be translated
# 
# Error messages from the OCL parser/interpreter.
# ==============================================================================

#
# Indicates that a value is already bound to a name in the evaluation environment.
# args:
#   0 - the name of the variable
#   1 - the value already bound to it
#
BindingExist_ERROR_ = The name: ({0})  already has a binding: ({1})

#
# Indicates that an operation lookup on a classifier failed during evaluation of
# an OCL expression.
# args:
#   0 - the operation name that could not be found
#
UnknownOperation_ERROR_ = Unknown operation for type:  ({0})

#
# Indicates that the named iterator expression is recognized by the parser
# but is not supported by the interpreter.
# args:
#   0 - the iterator name
#
IteratorNotImpl_ERROR_ = Iterator ({0}) not yet implemented.

#
# Indicates attempt to access an index in an integer range, that falls outside of the range.
# args:
#   0 - the index that was attempted
#   1 - the lower bound of the range
#   2 - the upper bound of the range
#
IndexOutOfRange_ERROR_ = Index ({0}) not in range ({1})..({2})

#
# Indicates attempt to navigate a property of a tuple that is not defined by the tuple type.
# args:
#   0 - the name of the missing tuple property
#
TupleFieldDoesntExist_ERROR_ = Cannot find tuple property ({0})

#
# Indicates that a property call expression is missing the reference to the called property.
# args:
#   0 - the text of the property call expression
#
NullProperty_ERROR_ = Null referred property in property call ({0})

#
# Indicates that the source expression of a navigation call expression is missing.
# args:
#   0 - the text of the navigation call expression
#
NullNavigationSource_ERROR_ = Null source in navigation expression ({0})

#
# Indicates that the result type of a navigation call expression is missing.
# args:
#   0 - the text of the navigation call expression
#
NullNavigationType_ERROR_ = Null type in navigation expression ({0})

#
# Indicates that an operation call expression is missing the reference to the called operation.
# args:
#   0 - the text of the operation call expression
#
NullOperation_ERROR_ = Null operation in operation call ({0})

#
# Indicates that the source expression of an operation call expression is missing.
# args:
#   0 - the text of the operation call expression
#
NullSourceOperation_ERROR_ = Null source in operation call ({0})

#
# Indicates that an operation call expression references an operation that does
# not exist in the source type or does not conform to the arguments.
# args:
#   0 - the text of the operation call expression
#
IllegalOperation_ERROR_ = Illegal operation ({0})

#
# Indicates that the operation code referenced by an operation call expression
# does not match the internal code for the OCL pre-defined operation.
# args:
#   0 - the name of the OCL standard operation
#
IllegalOpcode_ERROR_ = Illegal opcode for ({0})

#
# Indicates that the return type of the operation referenced by an operation call
# expression differs from the result type of the expression.
# args:
#   0 - the type of the operation call expression
#
TypeConformanceOperation_ERROR_ = Operation return type does not match operation call expression type ({0})

#
# Indicates that the enumeration literal referenced by an enumeration literal
# expression belongs to a different enumeration than the expression's type.
# args:
#   0 - the name of the enumeration literal
#
IllegalEnumLiteral_ERROR_ = Illegal enumeration literal: ({0})

#
# Indicates that the variable referenced by a variable expression is of a different
# type than the expression.
# args:
#   0 - the name of the variable
#
VariableTypeMismatch_ERROR_= The type of a variable expression must match the type of the variable ({0}).

#
# Indicates that a variable declaration is missing the variable name.
#
MissingNameInVariableDeclaration_ERROR_= Missing Name in variable declaration.

#
# Indicates that a variable initialization expression does not match the variable type.
# args:
#   0 - the name of the variable
#
TypeConformanceInit_ERROR_= Init expression type does not conform to type of variable ({0}).

#
# Indicates that the condition of an 'if' expression does not result in a boolean value.
# args:
#   0 - the text of the condition expression
#
NonBooleanIfExp_ERROR_= If expression condition must be boolean-valued: ({0})

#
# Indicates that the 'then' and 'else' expressions in an 'if' expression do not
# conform to the type of the overall 'if' expression.
# args:
#   0 - the text of the complete 'if' expression
#
TypeConformanceIfExp_ERROR_= If expression type is not equal to common super type of then and else part types: ({0})

#
# Indicates that an integer literal expression type is not Integer.
#
TypeConformanceIntegerLiteral_ERROR_= Integer literal expression must be of type Integer.

#
# Indicates that a real literal expression type is not Real.
#
TypeConformanceRealLiteral_ERROR_= Real literal expression must be of type Real.

#
# Indicates that a string literal expression type is not String.
#
TypeConformanceStringLiteral_ERROR_= String literal expression must be of type String.

#
# Indicates that a boolean literal expression type is not Boolean.
#
TypeConformanceBooleanLiteral_ERROR_= Boolean literal expression must be of type Boolean.

#
# Indicates that a null literal expression type is not OclVoid.
#
TypeConformanceNullLiteral_ERROR_= Null literal expression must be of type OclVoid.

#
# Indicates that an OclInvalid literal expression type is not Invalid.
#
TypeConformanceInvalidLiteral_ERROR_= OclInvalid literal expression must be of type Invalid.

#
# Indicates that the 'in' expression type of a 'let' expression does not match
# the type of the overall 'let' expression.
# args:
#   0 - the 'let' expression type
#   1 - the 'in' expression type
#
TypeConformanceLetExp_ERROR_= Let expression type conformance error: ({0}) != ({1})

#
# Indicates that the result variable of an 'iterate' expression has a different
# type from the expression as a whole.
# args:
#   0 - the text of the complete iterate expression
#
TypeConformanceIterateExp_ERROR_= Iterate expression type must be the same as result variable type ({0})

#
# Indicates that the body of an 'iterate' expression does not conform to the result variable type.
# args:
#   0 - the text of the complete iterate expression
#
TypeConformanceIterateExpBody_ERROR_= Iterate expression body type must conform to the result type ({0})

#
# Indicates that the iteration variable of an 'iterate' expression has a different
# type from the source collection's element type.
# args:
#   0 - the text of the complete iterate expression
#
TypeConformanceIterateExpLoopVar_ERROR_= Iterate expression iterator variable must have same type as source element type ({0})

#
# Indicates that the result type of a 'forAll', 'exists', or 'isUnique' iterator
# is not Boolean.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceIteratorResult_ERROR_= Iterator result type must be boolean ({0})

#
# Indicates that the iterator variable of an iterator expression has a different
# type from the source collection's element type.  Note that iterator expressions
# are different from 'iterate' expressions.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceIteratorExpLoopVar_ERROR_= Iterator variable must have same type as source element type ({0})

#
# Indicates that the result type of a 'collect', iterator on a sequence or an
# ordered set is not a sequence.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceCollectSequence_ERROR_= Collect type must be sequence ({0})

#
# Indicates that the result type of a 'collect' iterator on a set or a bag is
# not a bag.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceCollectBag_ERROR_= Collect type must be bag ({0})

#
# Indicates that the result type of a 'closure' iterator is not a set.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceClosure_ERROR_= Closure type must be Set ({0})

#
# Indicates that the body expression of a 'closure' iterator does not conform
# to the element type of the source collection, so that recursive evaluation of
# the body is invalid.
# args:
#   0 - the type of the body expression
#   1 - the element type of the source collection
#
ElementTypeConformanceClosure_ERROR_= Closure type {{0}) does conform to source type ({1})

#
# Indicates that the result type of a 'select' or 'reject' iterator differs
# from the source collection type.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceSelectReject_ERROR_= Select/reject type must be the same as the source type ({0})

#
# Indicates that the body expression of a 'forAll', 'exists', 'any', 'select', 'reject', or 'one'
# iterator is not Boolean.
# args:
#   0 - the text of the complete iterator expression
#
TypeConformanceIteratorBodyBoolean_ERROR_= Iterate Expression body type must be boolean ({0})

#
# Indicates that the type of a collection literal expression is not a collection type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceCollectionLiteralExp_ERROR_= Missing or Illegal Type in Collection Literal Expression: ({0})

#
# Indicates that the type of a set literal expression is not a set type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceSetLiteral_ERROR_= Set literal must have SetType: ({0})

#
# Indicates that the type of an ordered set literal expression is not an ordered set type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceOrderedSetLiteral_ERROR_= Ordered set literal must have OrderedSetType: ({0})

#
# Indicates that the type of a bag literal expression is not a bag type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceBagLiteral_ERROR_= Bag literal must have BagType: ({0})

#
# Indicates that the type of a sequence literal expression is not a sequence type.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceSequenceLiteral_ERROR_= Sequence literal must have SequenceType: ({0})

#
# Indicates that the element type of an empty collection literal is not Classifier.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceEmptyCollection_ERROR_= Empty collection must have element type Classifier: ({0})

#
# Indicates that the type of a collection literal expression differs from the
# common supertype of the types of the literal parts.
# args:
#   0 - the text of the complete collection literal
#
TypeConformanceCollectionElementType_ERROR_= Collection element type does not match the supertype of the element types: ({0})

#
# Indicates that the type of a tuple literal expression is not a Tuple type.
# args:
#   0 - the text of the complete tuple literal
#
TypeConformanceTupleLiteralExp_ERROR_= Tuple literal expression must be of type Tuple: ({0}).

#
# Indicates that the number of parts of a tuple literal expression does not match
# the number of properties of the tuple type.
# args:
#   0 - the text of the complete tuple literal
#
TypeConformanceTupleLiteralExpParts_ERROR_= The tuple literal expression parts do not match the tuple type: ({0})

#
# Indicates that a tuple literal part did not match any property of the tuple type.
# args:
#   0 - the name of the tuple literal part
#   1 - the text of the complete tuple literal
#
TupleLiteralExpressionPart_ERROR_= Property ({0}) not found in tuple type: ({1})

#
# Indicates that a tuple literal includes two or more parts of the same name.
# args:
#   0 - the duplicate tuple literal part name
#   1 - the text of the complete tuple literal
#
TupleDuplicateName_ERROR_= Duplicate part name ({0}) in tuple literal: ({1})

#
# Indicates that a tuple literal part is missing the reference to the corresponding
# property of the tuple type.
# args:
#   0 - the tuple literal part name
#   1 - the text of the complete tuple literal
#
MissingPropertyInTupleLiteralPart_ERROR_= Tuple literal part ({0}) missing property reference: ({1})

#
# Indicates that a tuple literal part is missing the reference to the type of its value.
# args:
#   0 - the tuple literal part name
#   1 - the text of the complete tuple literal
#
MissingTypeInTupleLiteralPart_ERROR_= Tuple literal part ({0}) missing type reference: ({1})

#
# Indicates that a tuple literal part type differs from the type of the corresponing
# property of the tuple type.
# args:
#   0 - the tuple literal part name
#   1 - the text of the complete tuple literal
#
TuplePartType_ERROR_= Tuple literal part ({0}) type does not match property type: ({1})

#
# Indicates that a tuple literal part's value expression is not compatible with
# the type of the corresponding property in the tuple type.
# args:
#   0 - the tuple literal part name
#   1 - the text of the complete tuple literal
#
TypeConformanceTuplePartValue_ERROR_= Tuple literal part ({0}) value does not conform to tuple property type: ({1})

TypeConformanceTypeExp_ERROR_= Type of Type Expression must be TypeType: ({0})
TypeExpMissingType_ERROR_= Missing referred type in Type Expression

RecursiveContainment_ERROR_= Recursive containment not allowed for ({0})
EMFOCLConversion_ERROR_= Cannot convert EMF type ({0}) to an OCL equivalent.
UnknownOperationOwnerType_ERROR_= Unknown owner type: ({0}) for operation: ({1})
IllegalSignature_ERROR_= illegal operation signature: ({0})

IteratorSource_ERROR_= The source of an iterator must be a collection ({0})
MissingInitIterateExpLoopVar_ERROR_= Iterate Expression loop iteration variable may not be initialized ({0})

IncompleteVariableDeclaration_ERROR_ = Incomplete Variable Declaration: ({0})
IncompleteLetExp_ERROR_ = Incomplete Let Expression: ({0})
IncompleteIterateExp_ERROR_ = Incomplete Iterate Expression: ({0})
IncompleteIfExp_ERROR_= Incomplete If Expression: ({0})
IncompleteIteratorExp_ERROR_= Incomplete Iterator Expression: ({0})

MissingInitIterateExp_ERROR_ = Iterate Expression result must have an init expression ({0})

StringParse_ERROR_ = The string cannot be parsed: ({0})
ErrorMessage_ERROR_ = ERROR in ({0}): ({1})
VariableUsed_ERROR_ = Variable already used: ({0})
VariableDeclaration_ERROR_ = Variable declaration failed
OperationNotFound_ERROR_ = Cannot find operation ({0}) for the type ({1})
BadArg_ERROR_ = Bad argument expression
PackageNotFound_ERROR_ = Unable to find package
UnrecognizedContext_ERROR_ = Unrecognized context: ({0})
PropertyConstraints_ERROR_ = Property context may define at most one init and one derive expression: ({0})
BooleanForIf_ERROR_ = expect boolean condition for if statement
MissingTypeForVar_ERROR_ = Missing type for variable ({0})
MissingInitForVar_ERROR_ = Missing init expression for variable ({0})
VarInNavExp_ERROR_ = Variable cannot appear in the middle of a navigation expression: ({0})
UnrecognizedVar_ERROR_ = unrecognized variable: ({0})
DeclarationType_ERROR_ = Declaration for ({0}) must have a type
DeclarationNoInitExp_ERROR_ = Declaration for ({0}) must have an initial expression
DeclarationInitExp_ERROR_ = Declaration for ({0}) must not have an initial expression
UnrecognizedType_ERROR_ = Unknown type ({0})
UnrecognizedVarType_ERROR_ = Unrecognizable type for variable: ({0})
NoType_ERROR_ = Type not provided for variable: ({0})
NoInitExp_ERROR_ = Init expr not provided for variable: ({0})
MissingTypeDecl_ERROR_ = Missing type declaration for variable: ({0})
DuplicateNameInTuple_ERROR_ = Duplicate name in tuple ({0})
InitExpNotAllowed_ERROR_ = Initialize expressions not allowed in types: ({0})
MissingInit_ERROR_ = Missing initializer for variable: ({0})
UnrecognizedPackageOrEnum_ERROR_ = Unrecognizable package or enum ({0})
UnrecognizedEnum_ERROR_ = Unknown enumeration literal ({0})
FirstLastTypeMismatch_ERROR_ = First and last type mismatch
NullArgExpectEObj_ERROR_ = Argument is null, expect EObject
NullArgExpectlist_ERROR_ = Argument is null, expect List.
BooleanQuery_ERROR_ = Query must be a boolean-valued constraint.
InputListExpectEObjs_ERROR_ = Input list items must be EObjects
CheckBool_ERROR_ = Check can only be called on boolean valued constraints
Noncomforming_ERROR_ = AnyType: Nonconforming arguments for type ({0}) and operation ({1})
SourceEClass_ERROR_ = AnyType: the source of operation: ({0}) must be an EClass or implement Comparable
SourceOperationCompareTo_ERROR_ = AnyType: source for operation ({0}) must have compatible method: compareTo
ResultCompareToInt_ERROR_ = AnyType: the result of the compareTo method must be Integer
TypeMismatch_ERROR_ = Conformance Type Mismatch. No common supertype: ({0}), ({1})
CompareTypeMismatch_ERROR_ = TypeCompare: Conformance Type Mismatch: ({0}), ({1})
UnrecognizedCollectionOperation_ERROR_= Unrecognizable collection operation: ({0})
CollectionType_ERROR_ = Collection type conformance failure: ({0}).({1}) 
CollectionSuperType_ERROR_ = Collection.commonSuperType: conformance error: ({0}), ({1})
# duplicate
#SumOperator_ERROR_= Conformance failure: The sum() operator can only be applied to Numeric types collections, not: ({0})
SumOperator_ERROR_= OclCollection::sum only works for collections of Numeric types
TupleTypeMismatch_ERROR_= Conformance Tuple Type Mismatch: ({0}), ({1})
TupleFieldNotFound_ERROR_= Conformance Type Mismatch, field ({0}).({1}) not found in ({2})
TupleFieldNumMismatch_ERROR_= Tuple type conformance, number of fields mismatch: ({0}) ({1})
RemoveUnsupported_ERROR_= remove not supported
OCLCollectionKindNotImpl_ERROR_ = OCL collection kind ({0}) is not implemented in the java collection factory.
IsInStateSignature_ERROR_= oclIsInState() must have a single State argument
NoSuchState_ERROR_= No such state ({0}) in type ({1})
MissingStateInStateExp_ERROR_= Missing referredState in StateExp
MissingStateNameInStateExp_ERROR_= Unnamed state referenced in StateExp
UnrecognizedMessageType_ERROR_= Unrecognized operation or signal ({0}) in message expression
AmbiguousMessageType_ERROR_= Ambiguous message expression: ({0}) could be an operation or a signal
IllegalUnspecifiedValueExp_ERROR_= Unspecified values may only be used in message expressions
MissingMessageTarget_ERROR_= Missing target in message expression
MissingOperationInCallAction_ERROR_ Missing operation in CallOperationAction
MissingSignalInCallAction_ERROR_ Missing signal in SendSignalAction
MessageArgumentCount_ERROR_= Wrong number of arguments for message type ({0})
MessageArgConformance_ERROR_= Argument ({1}) does not conform to parameter ({0}) of message
DefinitionConstraintFeature_ERROR_= Unknown defined feature in definition constraint of {0}
DefinitionConstraintConformance_ERROR_= Def expression type ({0}) does not conform to defined feature type ({1})
DuplicateProperty_ERROR_= Property ({0}) already defined in type ({1})
DuplicateOperation_ERROR_= Operation ({0}) already defined in type ({1})
InitOrDerConstraintConformance_ERROR_= Initial or derived value expression type ({0}) does not conform to property "{1}" type ({2})

IllegalAtPre_ERROR_ = @pre may only be applied to model property calls
AtPreInPostcondition_ERROR_ = @pre may only be used in an operation postcondition constraint
BodyConditionNotAllowed_ERROR_ = Cannot specify body condition for void operation "{0}"
BodyConditionConformance_ERROR_ = Body condition does not conform to result type of operation "{0}": ({1}), ({2})
BodyConditionConformance2_ERROR_ = Body condition does not conform to result type of operation "{0}": {1}
OCLIsNewInPostcondition_ERROR_ = oclIsNew() may only be called in an operation postcondition constraint
IllegalQualifiers_ERROR_ = Qualifiers may only be applied to navigation calls
MismatchedQualifiers_ERROR_ = Qualifiers do not conform to expected types
MissingAssociationClass_ERROR_ = Missing AssociationClass in AssociationClassEnd: {0}
AssociationClassQualifierCount_ERROR_ = Cannot have more than one qualifier role on association class navigation
AssociationClassQualifierType_ERROR_ = Qualifier on association class navigation must be a role of the navigation source
AssociationClassAmbiguous_ERROR_ = Qualifier needed to select navigation direction in reflexive association class
BodyConditionForm_ERROR_ = Body condition must have the form "result = <expr>" on operation "{0}"
OperationConstraintBoolean_ERROR_ = Constraint must be boolean-valued on operation "{0}"

# Error indicating an attempt to parse an OCL Expression as an invariant
# constraint, but the expression does not compute a boolean value
# args:
#   0 -  the name of the context classified on which the invariant is defined
InvariantConstraintBoolean_ERROR_ = Constraint must be boolean-valued on type "{0}"

InvalidOCL_ERROR_ = Invalid OCL

ParseCSTNodeType_ERROR_ = expected parser to return {0} but got {1}

OCLParseErrorCodes_LEX_ERROR = {0} {1} unexpected character ignored
OCLParseErrorCodes_ERROR = {0} {1} parsing terminated at this token
OCLParseErrorCodes_BEFORE = {0} {1} inserted before {2}
OCLParseErrorCodes_INSERTION = {0} {1} expected after {2}
OCLParseErrorCodes_INVALID = {0} {1} unexpected input discarded
OCLParseErrorCodes_SUBSTITUTION_SECONDARY = {0} {1} expected instead of {2}
OCLParseErrorCodes_DELETION = {0} {1} unexpected token(s)
OCLParseErrorCodes_MERGE = {0} merge tokens {2} to form {1}
OCLParseErrorCodes_MISPLACED = {0} {1} misplaced construct(s)
OCLParseErrorCodes_SCOPE = {0} missing {1} to complete scope
OCLParseErrorCodes_EOF = {0} End-of-File reached after this token {1}
OCLParseErrorCodes_INVALID_TOKEN = {0} token {1} is invalid

# row(start):column(start):row(end):column(end)
ErrorReport_RowColumn = {0}:{1}:{2}:{3}