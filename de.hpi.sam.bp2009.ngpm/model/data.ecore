<?xml version="1.0" encoding="UTF-8"?>
<ecore:EPackage xmi:version="2.0"
    xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" name="data"
    nsURI="http:///data.ecore" nsPrefix="data">
  <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
    <details key="invocationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
    <details key="validationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
  </eAnnotations>
  <eSubpackages name="classes" nsURI="http:///data/classes.ecore" nsPrefix="data.classes">
    <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
      <details key="invocationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
      <details key="validationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
    </eAnnotations>
    <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
      <details key="documentation" value="BOs, BONodes, associations, regardless the association implementation (foreign keys, persistence structures, IDs, ...). Nodes have attributes that have types. Resulting is a datatype for the node that can be used, e.g., in the action language."/>
    </eAnnotations>
    <eClassifiers xsi:type="ecore:EClass" name="Association" eSuperTypes="modelmanagement.ecore#//NamedElement">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="UniquenessOnBothEndsMustBeTheSame" value="self.ends->forAll( e1, e2 : AssociationEnd |&#xD;&#xA;              e1 &lt;> e2 implies e1.type.unique = e2.type.unique)"/>
        <details key="AtMostOneCompositeEnd" value="self.ends->select(composite)->size() &lt; 2"/>
        <details key="AtLeastOneNavigableEnd" value="self.ends->select(ae:AssociationEnd | ae.navigable)->notEmpty()"/>
        <details key="AtMostOneEqualityContributionForTwoValueClasses" value="self.ends->select(contributesToEquality and type.clazz.valueType)->size() &lt; 2"/>
        <details key="AtMostOneOrderedEnd" value="self.ends->select(ae|ae.type.ordered)->size() &lt; 2"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="UniquenessOnBothEndsMustBeTheSame AtMostOneCompositeEnd AtLeastOneNavigableEnd AtMostOneEqualityContributionForTwoValueClasses AtMostOneOrderedEnd"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ends" lowerBound="2"
          upperBound="2" eType="#//classes/AssociationEnd" containment="true" eOpposite="#//classes/AssociationEnd/association"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="package_" lowerBound="1"
          eType="ecore:EClass modelmanagement.ecore#//Package" transient="true" eOpposite="modelmanagement.ecore#//Package/associations"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="timeDependency" eType="#//timedependency/TimeDependency"
          containment="true" eOpposite="#//timedependency/TimeDependency/association"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="abapAnnotation" eType="ecore:EClass abapmapping.ecore#//AbapAssociationImplementationAnnotation">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Signature" abstract="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Defines an abstract callable operation or block signature with input parameter types, return type and exception / fault types. A signature may also be implemented by association navigation expressions or link set manipulation statements.&#xD;&#xA;&#xD;&#xA;The enforcement of side effect freeness is the SignatureImplementation subclasses' responsibility."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="OnlyTrailingOptionalParameters" value="self.input->forAll(p | p.defaultValue->notEmpty() implies Sequence{(self.input->indexOf(p)+1)..self.input->size()}->forAll(&#xD;&#xA;    i | self.input->at(i).defaultValue->notEmpty()))"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="OnlyTrailingOptionalParameters"/>
      </eAnnotations>
      <eOperations name="conformsTo" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self = s then    true  else    self.conformsToExcluding(s, Sequence{}, Sequence{})  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eParameters name="s" eType="#//classes/Signature"/>
      </eOperations>
      <eOperations name="conformsToExcluding" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if s = self then    true  else    let nameConforms:Boolean = self.oclIsKindOf(MethodSignature) and s.oclIsKindOf(MethodSignature)        implies s.oclAsType(MethodSignature).name = self.oclAsType(MethodSignature).name in    nameConforms and    (s.sideEffectFree implies self.sideEffectFree) and    s.input->size() = self.input->size() and    Sequence{1..self.input->size()}->      forAll(i | s.input->at(i).getType().conformsToExcluding(self.input->at(i).getType(), excludingConforming, excludingTo)) and    s.output->size() = self.output->size() and    Sequence{1..self.output->size()}->      forAll(i | self.output->asSequence()->at(i).conformsToExcluding(s.output->asSequence()->at(i), excludingConforming, excludingTo))  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Same as conformsTo(Featured):Boolean but with the possibility to pass pairs of Featured elements that are to be considered conforming and thus don't need further exploration. This can be used to avoid endless recursions in conformance testing."/>
        </eAnnotations>
        <eParameters name="s" eType="#//classes/Signature"/>
        <eParameters name="excludingConforming" eType="#//classes/SapClass"/>
        <eParameters name="excludingTo" eType="#//classes/SapClass"/>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="sideEffectFree" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="If this flag is set, the signature's implementation must not use a link-modifying implementation on any object of an entity class. It is permissible for an implementation to create value objects. All signatures being called by an implementation must then also have this flag set.&#xD;&#xA;&#xD;&#xA;This flag is also relevant for conformance. A signature only conforms to one with this flag set if it also has this flag set.&#xD;&#xA;&#xD;&#xA;Note that activities that do not modify the link structure may still have side effects outside of the scope of this programming model, such as producing a log entry in some persistence layer about a query being executed. Such side effects that are outside of this programming model do not count as a side effect in the sense of this flag. In particular, they do not make the program's semantics depend on execution order of such signature implementations."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="faults" eType="#//classes/SapClass"
          eOpposite="#//classes/SapClass/signaturesWithFault"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="output" eType="#//classes/TypeDefinition"
          eOpposite="#//classes/TypeDefinition/signaturesWithOutput"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedTypeDefinitions"
          eType="#//classes/TypeDefinition" containment="true" eOpposite="#//classes/TypeDefinition/ownerSignature"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="input" upperBound="-1"
          eType="#//classes/Parameter" containment="true" eOpposite="#//classes/Parameter/ownerSignature"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="preconditions" upperBound="-1"
          eType="#//constraints/Constraint" containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value="preconditionForSignature"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="postconditions" upperBound="-1"
          eType="#//constraints/Constraint" containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value="postconditionForSignature"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="abapAnnotation" eType="ecore:EClass abapmapping.ecore#//AbapSignatureImplementationAnnotation">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="AssociationEnd" eSuperTypes="modelmanagement.ecore#//NamedElement">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="ExposingClassesEqualOppositeEndsType" value="self.signatureImplementations.implements_.owner->forAll(c:SignatureOwner | c = self.otherEnd().type.clazz)"/>
        <details key="NoCompositionWithValueClass" value="self.composite implies self.association.ends.type->forAll(ctd:ClassTypeDefinition | not ctd.clazz.valueType)"/>
        <details key="EqualityContributionsMustBeExposedAndNavigable" value="self.contributesToEquality implies (self.otherEnd().signatureImplementations->notEmpty() and self.otherEnd().navigable)"/>
        <details key="EqualityContributingEndOnValueMustHaveUnlimitedUpperBounds"
            value="(self.type.clazz.valueType and self.contributesToEquality and&#xD;&#xA;   self.type.clazz.getAssociationEnds()->exists(ae |&#xD;&#xA;     ae &lt;> self and ae.contributesToEquality)) implies&#xD;&#xA;  self.type.isMany()"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="ExposingClassesEqualOppositeEndsType NoCompositionWithValueClass EqualityContributionsMustBeExposedAndNavigable EqualityContributingEndOnValueMustHaveUnlimitedUpperBounds"/>
      </eAnnotations>
      <eOperations name="otherEnd" eType="#//classes/AssociationEnd">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="association.ends->select(ae|ae &lt;> self)->first()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="navigable" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Means that the association can be navigated in that direction towards this end. Note that non-navigability does not serve as a security-related feature. If all objects of the type at the other end can be enumerated and because the association has to be navigable in at least one direction, it will be possible to find out those objects on the other end that are linked to an instance which semantically implements navigation again, only potentially very slowly if the extent to enumerate is large."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="composite" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Expresses ownership that for entity-to-entity associations also implies delete propagation. Only one of the two association ends can be marked as composite. The end marked in this way attaches to the &quot;owning&quot; class whereas the otherEnd() attaches to the &quot;owned&quot; class.&#xD;&#xA;&#xD;&#xA;Composition cannot be used for value classes. Values cannot be owned, and values cannot own anything."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="contributesToEquality"
          eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="If true, this association end contributes to the equality of the exposing class. An equality-contributing association end must be exposed (maybe with private visibility) because it is relevant for the contract of that class.&#xD;&#xA;&#xD;&#xA;It is a questionable construct to have both ends contribute to equality if both classes are value classes because it would mean that values of either of the classes can be identified only in pairs. The equality definition would be recursive, and an implementation would have to understand this and cut short the recursion, comparing only all other equality-related association end values."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="association" lowerBound="1"
          eType="#//classes/Association" transient="true" eOpposite="#//classes/Association/ends"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="delegation" eType="#//classes/Delegation"
          containment="true" eOpposite="#//classes/Delegation/from"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="signatureImplementations"
          upperBound="-1" eType="#//classes/AssociationEndSignatureImplementation"
          eOpposite="#//classes/AssociationEndSignatureImplementation/end"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="type" lowerBound="1"
          eType="#//classes/ClassTypeDefinition" containment="true" eOpposite="#//classes/ClassTypeDefinition/associationEnd"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="abapAnnotation" eType="ecore:EClass abapmapping.ecore#//AbapAssociationEndImplementationAnnotation">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SapClass" eSuperTypes="#//classes/SignatureOwner behavioral.ecore#//events/EventProducer">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="OnlyValueClassesCanHaveObjectParameters" value="self.formalObjectParameters->notEmpty() implies self.valueType"/>
        <details key="OnlyObjectParameterizedClassesCanHaveConverter" value="self.converterBetweenParametrizations->notEmpty() implies self.formalObjectParameters->notEmpty()"/>
        <details key="OnlyTrailingOptionalParameters" value="self.formalObjectParameters->forAll(p | p.defaultValue->notEmpty() implies Sequence{(self.formalObjectParameters->indexOf(p)+1)..self.formalObjectParameters->size()}->forAll(&#xD;&#xA;    i | self.formalObjectParameters->at(i).defaultValue->notEmpty()))"/>
        <details key="NoRecursionForObjectParameters" value="true  --  TODO implement this"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="OnlyValueClassesCanHaveObjectParameters OnlyObjectParameterizedClassesCanHaveConverter OnlyTrailingOptionalParameters NoRecursionForObjectParameters"/>
      </eAnnotations>
      <eOperations name="isAbstract" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="not (self.allSignatures()->forAll(s:MethodSignature | not s.isAbstract()))"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eOperations name="isParameterizedClassDefinition" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.parameterization->notEmpty()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eOperations name="conformsTo" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self.oclIsUndefined() then    false  else    self.conformsToExcluding(type, Sequence{}, Sequence{})  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="A class A conforms to a class B if they are the same or if there is a chain of (TypeAdapter_i, Class_i) pairs (0&lt;=i&lt;=n) where TypeAdapter_0 adapts A to Class_0, and where Class_n is B."/>
        </eAnnotations>
        <eParameters name="type" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="allSignatures" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.allSignaturesExcluding(Set{})"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Computes all locally-defined signatures plus those signatures offered by any Class (directly, or by delegation or recursively by type adaptation) attached to this class as a type adapter, plus allSignatures() recursively of all classes to which this class delegates."/>
        </eAnnotations>
      </eOperations>
      <eOperations name="delegatesTo" eType="#//classes/SapClass">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self.oclIsKindOf(ParameterizedClassInstantiation) then    self.oclAsType(ParameterizedClassInstantiation).parameterizedClass.delegatesTo()  else    if self.oclIsKindOf(FormalTypeParameter) then      self.oclAsType(FormalTypeParameter).typeConstraint->collect(c:SapClass | c.delegatesTo())->flatten()->asSet()    else      self.getAssociationEnds().otherEnd()->select(delegation->notEmpty()).type.clazz->reject(c|c=self)->asSet()    endif  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="A class can delegate to another class via an attached association end that in turn has attached a Delegation element. The delegating class by this exposes all operations and association ends exposed by the delegate class (recursively). The semantics of such a delegation is that when invoked, the invocation will be forwarded to the delegate object transparently and recursively.&#xD;&#xA;&#xD;&#xA;Note, that TypeAdapter objects cannot delegate because they cannot have association ends attached to them. They can only expose association ends whose other end is attached to a class to which the TypeAdapter conforms."/>
        </eAnnotations>
      </eOperations>
      <eOperations name="conformsToExcluding" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if oclIsUndefined() then    false  else  if self = type then   true  else    if Sequence{1..excludingConforming->size()}->exists(i|        excludingConforming->asSequence()->at(i) = self and excludingTo->asSequence()->at(i) = type) then     true  else    self.adapters->exists(a|a.to.conformsToExcluding(type, excludingConforming->including(self), excludingTo->including(type))) or    (if self.oclIsKindOf(FormalTypeParameter) then        if self.oclAsType(FormalTypeParameter).typeConstraint->notEmpty() then            self.oclAsType(FormalTypeParameter).typeConstraint.conformsToExcluding(type, excludingConforming->including(self), excludingTo->including(type))        else            false        endif    else        false    endif)  endif  endifendif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Same as conformsTo(Featured):Boolean but with the possibility to pass pairs of Featured elements that are to be considered conforming and thus don't need further exploration. This can be used to avoid endless recursions in conformance testing."/>
        </eAnnotations>
        <eParameters name="type" eType="#//classes/SapClass"/>
        <eParameters name="excludingConforming" eType="#//classes/SapClass"/>
        <eParameters name="excludingTo" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="signaturesWithDelegation" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.signaturesWithDelegationExcluding(Set{})"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Signature declared directly by this class and those signatures obtained by delegation, recursively."/>
        </eAnnotations>
      </eOperations>
      <eOperations name="delegatedSignatures" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.delegatesTo().signaturesWithDelegation()->flatten()->asSet()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Signatures obtained by delegation recursively."/>
        </eAnnotations>
      </eOperations>
      <eOperations name="adaptedSignatures" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.adaptedSignaturesExcluding(Set{})"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Computes signatures offered by any Class (directly, or by delegation or recursively by type adaptation) attached to this class as a type adapter"/>
        </eAnnotations>
      </eOperations>
      <eOperations name="adaptedSignaturesExcluding" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if excluding->count(self)=0 then    if self.oclIsKindOf(ParameterizedClassInstantiation) then      self.oclAsType(ParameterizedClassInstantiation).parameterizedClass.adaptedSignaturesExcluding(excluding->including(self))    else      if self.oclIsKindOf(FormalTypeParameter) then        self.oclAsType(FormalTypeParameter).typeConstraint->collect(c:SapClass | c.adaptedSignaturesExcluding(excluding->including(self)))->flatten()->asSet()      else        self.adapters.allSignaturesExcluding(excluding->including(self))          ->select(s | not self.ownedSignatures->exists(os | os.conformsTo(s)))          ->flatten()->asSet()      endif    endif  else    Set{}  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Computes signatures offered by any type adapter adapting this class to another class, minus those signatures redefined in the local class"/>
        </eAnnotations>
        <eParameters name="excluding" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="allSignaturesExcluding" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if excluding->count(self)=0 then    if self.oclIsKindOf(ParameterizedClassInstantiation) then      self.oclAsType(ParameterizedClassInstantiation).parameterizedClass.allSignaturesExcluding(excluding->including(self))    else      if self.oclIsKindOf(FormalTypeParameter) then        self.oclAsType(FormalTypeParameter).typeConstraint->collect(c:SapClass | c.allSignaturesExcluding(excluding->including(self)))->flatten()->asSet()      else        self.signaturesWithDelegationExcluding(excluding)->union(self.adaptedSignaturesExcluding(excluding))      endif    endif  else    Set{}      endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Computes all locally-defined signatures plus those signatures offered by any Class (directly, or by delegation or recursively by type adaptation) attached to this class as a type adapter, plus allSignatures() recursively of all classes to which this class delegates."/>
        </eAnnotations>
        <eParameters name="excluding" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="signaturesWithDelegationExcluding" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if excluding->count(self)=0 then     if self.oclIsKindOf(ParameterizedClassInstantiation) then      self.oclAsType(ParameterizedClassInstantiation).parameterizedClass.signaturesWithDelegationExcluding(excluding->including(self))    else      if self.oclIsKindOf(FormalTypeParameter) then        self.oclAsType(FormalTypeParameter).typeConstraint->collect(c:SapClass | c.signaturesWithDelegationExcluding(excluding->including(self)))->flatten()->asSet()      else        self.ownedSignatures->union(self.delegatesTo().signaturesWithDelegationExcluding(excluding->including(self)))->flatten()->asSet()      endif    endifelse  Set{}endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Signature declared directly by this class and those signatures obtained by delegation, recursively."/>
        </eAnnotations>
        <eParameters name="excluding" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="delegatedSignaturesExcluding" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if excluding->count(self)=0 then  self.delegatesTo().signaturesWithDelegationExcluding(excluding->including(self))->flatten()->asSet()else  Set{}endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Signatures obtained by delegation recursively."/>
        </eAnnotations>
        <eParameters name="excluding" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="getConformingClasses" eType="#//classes/SapClass">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.adaptedBy.adapted.getConformingClasses()->including(self)->asSet()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eOperations name="getAssociationEnds" eType="#//classes/AssociationEnd">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.elementsOfType->collect(associationEnd->asSet())->asSet()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Retrieves those association ends that use this class in their type definition."/>
        </eAnnotations>
      </eOperations>
      <eOperations name="getEqualityRelevantAssociationEnds" eType="#//classes/AssociationEnd">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.getAssociationEnds()->select(ae|ae.contributesToEquality)"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Obtains all association ends that use this class in their type definition and that contribute to this class's equality, indicated by their contributesToEquality attribute being set to true."/>
        </eAnnotations>
      </eOperations>
      <eOperations name="getConformsToClasses" eType="#//classes/SapClass">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.adapters.to.getConformsToClasses()->including(self)->asSet()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Determines all classes to which this class conforms, directly and transitively, through chains of TypeAdapters. The result includes this class itself."/>
        </eAnnotations>
      </eOperations>
      <eOperations name="getConformsToAssociationEnds" eType="#//classes/AssociationEnd">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.getConformsToClasses().getAssociationEnds()->asSet()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Determines all association ends to whose type this class conforms. This means that an instance of this class can be inserted on that respective end of the corresponding association. For example, if there is an association between Order and Item with ends &quot;order&quot; and &quot;items&quot; and there are classes SalesOrder and SalesOrderItem conforming to Order and Item, respectively, then the &quot;order&quot; end will be returned by this method when invoked on the SalesOrder class because SalesOrder conforms to Order and therefore a SalesOrder can be inserted into the association in role &quot;order.&quot;"/>
        </eAnnotations>
      </eOperations>
      <eOperations name="getConformsToCompositeParentAssociationEnds" eType="#//classes/AssociationEnd">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.getConformsToClasses().getAssociationEnds()->select(ae|ae.composite)->asSet()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Like getConformsToAssociationEnds(), but selects only those association ends that are marked as composite."/>
        </eAnnotations>
      </eOperations>
      <eOperations name="getConformsToCompositeChildAssociationEnds" eType="#//classes/AssociationEnd">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.getConformsToClasses().getAssociationEnds()->select(ae|ae.otherEnd().composite)->asSet()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Like getConformsToAssociationEnds(), but selects only those association ends whose other ends are marked as composite."/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="instances" upperBound="-1"
          eType="ecore:EClass reflection.ecore#//Object" eOpposite="reflection.ecore#//Object/type"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="subscription" upperBound="-1"
          eType="ecore:EClass behavioral.ecore#//events/Subscription" containment="true"
          eOpposite="behavioral.ecore#//events/Subscription/subscribingClass"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="samActions" upperBound="-1"
          eType="ecore:EClass behavioral.ecore#//status_and_action_old/SAMAction"
          containment="true" eOpposite="behavioral.ecore#//status_and_action_old/SAMAction/businessObjectNode"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="samStatusVariables" upperBound="-1"
          eType="ecore:EClass behavioral.ecore#//status_and_action_old/SAMStatusVariable"
          containment="true" eOpposite="behavioral.ecore#//status_and_action_old/SAMStatusVariable/businessObjectNode"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="samDerivators" upperBound="-1"
          eType="ecore:EClass behavioral.ecore#//status_and_action_old/SAMDerivator"
          containment="true" eOpposite="behavioral.ecore#//status_and_action_old/SAMDerivator/businessObject"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="samStatusSchema" upperBound="-1"
          eType="ecore:EClass behavioral.ecore#//status_and_action_old/SAMStatusSchema"
          containment="true" eOpposite="behavioral.ecore#//status_and_action_old/SAMStatusSchema/businessObjectNode"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="behaviouralModel" upperBound="-1"
          eType="ecore:EClass behavioral.ecore#//status_and_action/assembly/StatusSchema"
          eOpposite="behavioral.ecore#//status_and_action/assembly/StatusSchema/node"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="valueType" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="If true, instances of the class will be immutable. Comparison will be by equality. Their identity is defined by value equality. Value types can of course contain associations to non-value (or &quot;entity&quot;) types.&#xD;&#xA;&#xD;&#xA;As opposed to value types, instances of entity types have identity and mutable state. They are always passed by reference. Variables only hold a reference to a shared instance. Comparing two entity objects using &quot;Equals&quot; will compare their identities."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="signaturesWithFault"
          upperBound="-1" eType="#//classes/Signature" eOpposite="#//classes/Signature/faults"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="elementsOfType" upperBound="-1"
          eType="#//classes/ClassTypeDefinition" eOpposite="#//classes/ClassTypeDefinition/clazz"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="package_" eType="ecore:EClass modelmanagement.ecore#//Package"
          transient="true" eOpposite="modelmanagement.ecore#//Package/classes"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="adaptedBy" upperBound="-1"
          eType="#//classes/TypeAdapter" eOpposite="#//classes/TypeAdapter/to"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="adapters" upperBound="-1"
          eType="#//classes/TypeAdapter" containment="true" eOpposite="#//classes/TypeAdapter/adapted"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="formalObjectParameters"
          upperBound="-1" eType="#//classes/Parameter" containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value="parameterOfClass"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="converterBetweenParametrizations"
          eType="#//classes/ConverterBetweenParametrizations" containment="true" eOpposite="#//classes/ConverterBetweenParametrizations/clazz"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="constraints" upperBound="-1"
          eType="#//constraints/Constraint" containment="true" eOpposite="#//constraints/Constraint/constrainedType"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="timeDependency" eType="#//timedependency/TimeDependency"
          containment="true" eOpposite="#//timedependency/TimeDependency/theClass"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="parameterization" eType="#//generics/ClassParameterization"
          containment="true" eOpposite="#//generics/ClassParameterization/owningClassDefinition"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="abapAnnotation" eType="ecore:EClass abapmapping.ecore#//AbapClassImplementationAnnotation">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Delegation">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Exposes all features (operations and exposed association ends) of the class to which the opposite of the &quot;from&quot; end is attached as features of the &quot;from&quot; end's class. In particular, this makes the &quot;from&quot; class conform to the type of the &quot;to&quot; association end.&#xD;&#xA;&#xD;&#xA;The lower and upper multiplicity of the &quot;from&quot; opposite's association end must be 1 because a single instance is required in order to the &quot;from&quot; type to be able to delegate to it."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="ToEndMustHaveMultiplicityOfOne" value="self.from.otherEnd().type.lowerMultiplicity = 1 and&#xD;&#xA;  self.from.otherEnd().type.upperMultiplicity = 1"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="ToEndMustHaveMultiplicityOfOne"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="allFeatures" eType="ecore:EDataType primitivetypes.ecore#//Boolean"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="from" lowerBound="1"
          eType="#//classes/AssociationEnd" transient="true" eOpposite="#//classes/AssociationEnd/delegation"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="TypedElement" abstract="true">
      <eOperations name="conformsTo" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self = typedElement or  self.getType().conformsTo(typedElement.getType())"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="A typed element consisting of a type with a multiplicity conforms to another typed element if this typed element's type conforms to the other type element's type, and this type element's multiplicity &quot;conforms&quot; to the other type element's multiplicity. In particular, equal multiplicities conform to each other.&#xD;&#xA;&#xD;&#xA;TODO: decide if and how non-equal multiplicites may still conform; for example, a single element may implicitly conform to a collection of elements of conforming type; however, additions to the single element would not be possible."/>
        </eAnnotations>
        <eParameters name="typedElement" eType="#//classes/TypedElement"/>
      </eOperations>
      <eOperations name="getType" eType="#//classes/TypeDefinition">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self.ownedTypeDefinition->notEmpty() then    self.ownedTypeDefinition  else    if self.oclIsKindOf(Variable) then      self.oclAsType(Variable).initExpression.getType()    else if self.oclIsKindOf(Constant) then      if self.oclAsType(Constant).initExpression->notEmpty() then        self.oclAsType(Constant).initExpression.getType()      else         if self.oclAsType(Constant).&quot;iterate&quot;[dataaccess::expressions::collectionExpressions::IterateAccumulator]->notEmpty() then           self.oclAsType(Constant).&quot;iterate&quot;[dataaccess::expressions::collectionExpressions::IterateAccumulator].iteratorExpression.getType()         else           null         endif      endif    else if self.oclIsKindOf(Iterator) then      if self.oclAsType(Iterator).boundToFor->notEmpty() then        self.oclAsType(Iterator).boundToFor.collection.getType()      else if self.oclAsType(Iterator).selection->notEmpty() then        if self.oclAsType(Iterator).selection.object.getType().oclIsKindOf(NestedTypeDefinition) then          -- if the selection's object has a nested type definition, un-nest by one level          self.oclAsType(Iterator).selection.object.getType().oclAsType(NestedTypeDefinition).type        else          -- In this case the tool should create a cloned tpye definition with multiplicities set to 1;          -- Just in case the tool doesn't do this and for the case where the object has upper          -- multiplicity 1, use the object's type as the default for the &quot;self&quot; iterator          self.oclAsType(Iterator).selection.object.getType()        endif      else        if self.oclAsType(Iterator).selection.object.getType().oclIsKindOf(NestedTypeDefinition) then          -- if the selection's object has a nested type definition, un-nest by one level          self.oclAsType(Iterator).&quot;iterate&quot;[dataaccess::expressions::collectionExpressions::IterateIterator].source.getType().               oclAsType(NestedTypeDefinition).type        else          -- In this case the tool should create a cloned tpye definition with multiplicities set to 1;          -- Just in case the tool doesn't do this and for the case where the object has upper          -- multiplicity 1, use the object's type as the default for the &quot;self&quot; iterator          self.oclAsType(Iterator).&quot;iterate&quot;[dataaccess::expressions::collectionExpressions::IterateIterator].source.getType()        endif      endif      endif    else if self.oclIsKindOf(Including) or self.oclIsKindOf(Excluding) then      self.oclAsType(CollectionExpression).source.getType()    else if self.oclIsKindOf(Iterate) then      self.oclAsType(Iterate).iteratorExpression.getType()    else if self.oclIsKindOf(Parameter) then      if self.oclAsType(Parameter).defaultValue->notEmpty() then        self.oclAsType(Parameter).defaultValue.getType()      else        if self.oclAsType(Parameter).ownerSignature.oclIsKindOf(MethodSignature) and        self.oclAsType(Parameter).ownerSignature.oclAsType(MethodSignature).implementation->notEmpty() and        self.oclAsType(Parameter).ownerSignature.oclAsType(MethodSignature).implementation.oclIsKindOf(AssociationEndSignatureImplementation) then  &#x9;let impl = self.oclAsType(Parameter).ownerSignature.oclAsType(MethodSignature).implementation.oclAsType(AssociationEndSignatureImplementation) in            impl.end.type        else          if self.oclAsType(Parameter).ownerSignature.oclIsKindOf(FunctionSignature) then            if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).dimension->notEmpty() then              self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).dimension.cellSet.factsType            else              if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForValueFunction->notEmpty() then                self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForValueFunction.factsType              else                if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForAggregationFunction->notEmpty() then                  if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForAggregationFunction.valueFunction->notEmpty() then                    self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForAggregationFunction.valueFunction.output                  else                    self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForAggregationFunction.factsType                  endif                else                  if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).implementation.oclIsKindOf(CellSet) then                    let pos:Integer = self.oclAsType(Parameter).ownerSignature.input->indexOf(self.oclAsType(Parameter)) in                    if pos = 1 then                      self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).implementation.oclAsType(CellSet).factsType                    else                      self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).implementation.oclAsType(CellSet).                          dimensions->at(-1+pos).characteristicFunction.output                    endif                  else                    null                  endif                endif              endif            endif          else            null          endif        endif      endif    else if self.oclIsKindOf(DimensionExpression) then      -- TODO Here, the multiplicity would have to be forced to 0..*      self.oclAsType(DimensionExpression).dimension.getType()    else if self.oclIsKindOf(VariableExpression) then      self.oclAsType(VariableExpression).variable.getType()    else if self.oclIsKindOf(SignatureCallExpression) then      self.oclAsType(SignatureCallExpression).getSignature().output    else if self.oclIsKindOf(AssociationEndNavigationExpression) then      self.oclAsType(AssociationEndNavigationExpression).toEnd.type    else if self.oclIsKindOf(Replace) then      self.oclAsType(Replace).object.getType()    else if self.oclIsKindOf(Ternary) then      -- Find the &quot;least&quot; TypeDefinition to which both, trueExpr.getType() and falseExpr.getType() conform.      -- We determine the more general of the two types; we cannot synthesize a new TypeDefinition in OCL.      -- Doing so would have to be done by explicit typing, setting the ownedTypeDefinition explicitly      if self.oclAsType(Ternary).trueExpr.getType().conformsTo(self.oclAsType(Ternary).falseExpr.getType()) then        self.oclAsType(Ternary).falseExpr.getType()      else        self.oclAsType(Ternary).trueExpr.getType()      endif    else if self.oclIsKindOf(Selection) then      self.oclAsType(Selection).object.getType()    else      null    endif    endif    endif    endif    endif    endif    endif    endif    endif    endif    endif    endif    endif  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Determined the type of the element. If the element owns a type definition, that one is assumed to be the result. Otherwise, &quot;polymorphically&quot; (we will refactor this once we can defined OCL method bodies polymorphically) we determine the type of the respective element.&#xD;&#xA;&#xD;&#xA;TODO the inference for Iterator elements used in an Iterate expression needs to resolve NestedTypeDefinitions; for non-NestedTypeDefinition type definitions it needs to reduce the multiplicity to exactly 1."/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedTypeDefinition"
          eType="#//classes/TypeDefinition" containment="true" eOpposite="#//classes/TypeDefinition/ownerTypedElement"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Context" eSuperTypes="modelmanagement.ecore#//NamedElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="An instance of a class can occur in a number of contexts. Each context has a characteristic condition that an object has to fulfill in order to &quot;be in that context.&quot;&#xD;&#xA;&#xD;&#xA;A context can specify constraints, additional events that the object may raise, or preconditions for operations of the object's class.&#xD;&#xA;&#xD;&#xA;(Currently, the metamodel only describes context-based constraints; events and preconditions may have to be added later.)"/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="ConditionMustBeBoolean" value="self.condition.getType().upperMultiplicity = 1 and&#xD;&#xA;  self.condition.getType().oclIsKindOf(ClassTypeDefinition) and&#xD;&#xA;  self.condition.getType().oclAsType(ClassTypeDefinition).clazz.name = 'Boolean'"/>
        <details key="ConstraintForRightClass" value="self.constraints->forAll(c | c.constrainedType = self.for_)"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="ConditionMustBeBoolean ConstraintForRightClass"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="for_" lowerBound="1"
          eType="#//classes/SapClass">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="constraints" upperBound="-1"
          eType="#//constraints/Constraint" containment="true" eOpposite="#//constraints/Constraint/theContext"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="condition" lowerBound="1"
          eType="ecore:EClass dataaccess.ecore#//expressions/Expression" containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Multiplicity" abstract="true">
      <eOperations name="isMany" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.upperMultiplicity > 1 or self.upperMultiplicity = -1"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="lowerMultiplicity" eType="ecore:EDataType primitivetypes.ecore#//Integer">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The lower bounds of this multiplicity."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="upperMultiplicity" eType="ecore:EDataType primitivetypes.ecore#//Integer">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The upper bounds of this multiplicity. Unlimited is encoded as -1."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="ordered" eType="ecore:EDataType primitivetypes.ecore#//Boolean"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="unique" eType="ecore:EDataType primitivetypes.ecore#//Boolean"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SignatureImplementation" abstract="true">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A signature can be implemented by a block (this would be a &quot;method&quot; in the classical sense) or, e.g., by an association navigation or by a link set manipulation statement."/>
      </eAnnotations>
      <eOperations name="getImplementedSignature" eType="#//classes/Signature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self.oclIsKindOf(FunctionSignatureImplementation) then    if self.oclAsType(FunctionSignatureImplementation).functionSignature->notEmpty() then      self.oclAsType(FunctionSignatureImplementation).functionSignature    else      self.implements_    endif  else    self.implements_  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="A block implements either a FunctionSignature or a MethodSignature. Two different associations connect the Block with the respective Signature subclasses. This operation is a convenience that chooses the one or the other, depending on which one is filled."/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="implements_" eType="#//classes/MethodSignature"
          transient="true" eOpposite="#//classes/MethodSignature/implementation"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="LinkTraversal" eSuperTypes="#//classes/AssociationEndSignatureImplementation">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Navigates an association starting on the source object on which the implementation is invoked and navigating to the *end* specified."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="OutputTypeMatchEndType" value="self.implements_.input->isEmpty() and&#xD;&#xA;  self.implements_.output.oclIsKindOf(ClassTypeDefinition) and &#xD;&#xA;  self.implements_.output.oclAsType(ClassTypeDefinition).clazz = self.end.type.clazz"/>
        <details key="MustBeNavigable" value="self.end.navigable"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="OutputTypeMatchEndType MustBeNavigable"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="LinkAddition" eSuperTypes="#//classes/LinkManipulationAtPosition">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Adds a link to the association of which *end* is one end, such that the object on which the implementation is invoked is on the other end, and the parameters passed to this implementation are in the role denoted by *end*."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="AdditionInputTypeMatchEndType" value="self.implements_.output->isEmpty() and&#xD;&#xA;  self.implements_.input->size() = 1 and &#xD;&#xA;  self.implements_.input->at(1).getType().oclIsKindOf(ClassTypeDefinition) and &#xD;&#xA;  self.implements_.input->at(1).getType().oclAsType(ClassTypeDefinition).clazz = self.end.type.clazz"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="AdditionInputTypeMatchEndType"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="LinkRemoval" eSuperTypes="#//classes/LinkManipulationAtPosition">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Removes all links from the object on which the implementation is invoked to those objects passed as parameters where the parameter objects are in the role denoted by *end*."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="RemovalTypeMatchEndType" value="self.implements_.output->isEmpty() and&#xD;&#xA;  self.implements_.input->size() = 1 and &#xD;&#xA;  self.implements_.input->at(1).getType().oclIsKindOf(ClassTypeDefinition) and &#xD;&#xA;  self.implements_.input->at(1).getType().oclAsType(ClassTypeDefinition).clazz = self.end.type.clazz"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="RemovalTypeMatchEndType"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="AssociationEndSignatureImplementation"
        abstract="true" eSuperTypes="#//classes/SignatureImplementation">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="OnlyOnOtherEndsClassOrClassConformingToItOrAdapterAdaptingToIt"
            value="(self.implements_.owner.oclIsKindOf(SapClass) and&#xD;&#xA;    self.implements_.owner.oclAsType(SapClass).conformsTo(self.end.otherEnd().type.clazz))&#xD;&#xA;  or   (self.implements_.owner.oclIsKindOf(TypeAdapter) and&#xD;&#xA;    self.implements_.owner.oclAsType(TypeAdapter).adapted.conformsTo(self.end.otherEnd().type.clazz))"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="OnlyOnOtherEndsClassOrClassConformingToItOrAdapterAdaptingToIt"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="end" lowerBound="1" eType="#//classes/AssociationEnd"
          eOpposite="#//classes/AssociationEnd/signatureImplementations"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ClassTypeDefinition" eSuperTypes="#//classes/TypeDefinition">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="ActualObjectsParametersMatchSignature" value="let numberOfMandatoryParameters =&#xD;&#xA;    self.clazz.formalObjectParameters->select(p|p.defaultValue->isEmpty())->size()&#xD;&#xA;  in&#xD;&#xA;  self.objectParameters->size() >= numberOfMandatoryParameters and&#xD;&#xA;  self.objectParameters->size() &lt;= self.clazz.formalObjectParameters->size() and&#xD;&#xA;  Sequence{1..self.objectParameters->size()}->forAll(i:Integer|&#xD;&#xA;    self.objectParameters->at(i).formalObjectParameter =&#xD;&#xA;    self.clazz.formalObjectParameters->at(i))"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="ActualObjectsParametersMatchSignature"/>
      </eAnnotations>
      <eOperations name="objectParametersConformTo" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self.effectiveObjectParameters()->size()  = ctd.effectiveObjectParameters()->size() then    self.clazz.converterBetweenParametrizations->notEmpty() or    Sequence{1..self.effectiveObjectParameters()->size()}->forAll(i |      self.effectiveObjectParameters()->at(i).evaluatesToEqualAs(ctd.effectiveObjectParameters()->at(i)))  else    false  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eParameters name="ctd" eType="#//classes/ClassTypeDefinition"/>
      </eOperations>
      <eOperations name="effectiveObjectParameters" eType="ecore:EClass dataaccess.ecore#//expressions/Expression">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.objectParameters.value->flatten()->asSequence()->union(     Sequence{(self.objectParameters->size()+1)..(self.clazz.formalObjectParameters->size())}->collect(i |              self.clazz.formalObjectParameters->at(i).defaultValue->flatten()->asSequence()))->flatten()->asSequence()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="clazz" lowerBound="1"
          eType="#//classes/SapClass" eOpposite="#//classes/SapClass/elementsOfType"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="associationEnd" eType="#//classes/AssociationEnd"
          transient="true" eOpposite="#//classes/AssociationEnd/type"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="objectParameters" upperBound="-1"
          eType="#//classes/ActualObjectParameter" eOpposite="#//classes/ActualObjectParameter/classTypeDefinitions"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedObjectParameters"
          upperBound="-1" eType="#//classes/ActualObjectParameter" containment="true"
          eOpposite="#//classes/ActualObjectParameter/owningClassTypeDefinition"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="TypeDefinition" abstract="true" eSuperTypes="#//classes/Multiplicity">
      <eOperations name="conformsTo" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self.oclIsUndefined() then    false  else if self = typeDef then    true  else    self.conformsToExcluding(typeDef, Sequence{}, Sequence{})  endif  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eParameters name="typeDef" eType="#//classes/TypeDefinition"/>
      </eOperations>
      <eOperations name="conformsToExcluding" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if oclIsUndefined() then    false  else  if self = td then    true  else   self.multiplicityConformsTo(td) and   self.conformsToIgnoringMultiplicityExcluding(td, excludingConforming, excludingTo)  endif endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Same as conformsTo(Featured):Boolean but with the possibility to pass pairs of Featured elements that are to be considered conforming and thus don't need further exploration. This can be used to avoid endless recursions in conformance testing."/>
        </eAnnotations>
        <eParameters name="td" eType="#//classes/TypeDefinition"/>
        <eParameters name="excludingConforming" eType="#//classes/SapClass"/>
        <eParameters name="excludingTo" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="multiplicityConformsTo" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="-- check for multiplicity conformance    -- multiplicity of td must include multiplicity of td    td.lowerMultiplicity &lt;= self.lowerMultiplicity    and    (        td.upperMultiplicity = -1        or         ( td.upperMultiplicity >= self.upperMultiplicity and self.upperMultiplicity &lt;> -1 )     )         -- check for conformance of orderedness and uniqueness    -- orderedness/uniqueness of td must be same or more relaxed than self's    and    (       not self.isMany()        or        ( ( self.ordered = td.ordered ) and ( self.unique = td.unique ) )        or        ( self.ordered and self.unique )        or        ( not ( td.ordered or td.unique ) )    )"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Checks if this type definition's multiplicity conforms to td's multiplicity definitions. This is the case if all instances that conform to this type definition will also conform to td.&#xD;&#xA;&#xD;&#xA;Multiplicity conforms if td includes self's multiplicity, thus td's lower multiplicity is equal or smaller, and td's upper multiplicity is equal or larger than self's.&#xD;&#xA;&#xD;&#xA;Ordereness and uniquness conform if td has more relaxed requirements. Thus, they conform if they are equal, if td is neither ordered nor unique, or if self is ordered and unique"/>
        </eAnnotations>
        <eParameters name="td" eType="#//classes/TypeDefinition"/>
      </eOperations>
      <eOperations name="conformsToIgnoringMultiplicityExcluding" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self = td then    true  else   if self.oclIsKindOf(ClassTypeDefinition) then    td.oclIsKindOf(ClassTypeDefinition) and    self.oclAsType(ClassTypeDefinition).clazz.conformsToExcluding(                td.oclAsType(ClassTypeDefinition).clazz, excludingConforming, excludingTo) and    self.oclAsType(ClassTypeDefinition).objectParametersConformTo(td.oclAsType(ClassTypeDefinition))  else    if self.oclIsKindOf(FunctionSignatureTypeDefinition) then      td.oclIsKindOf(FunctionSignatureTypeDefinition) and      self.oclAsType(FunctionSignatureTypeDefinition).signature.conformsToExcluding(           td.oclAsType(FunctionSignatureTypeDefinition).signature, excludingConforming, excludingTo)    else      td.oclIsKindOf(NestedTypeDefinition) and      self.oclAsType(NestedTypeDefinition).type.conformsToExcluding(          td.oclAsType(NestedTypeDefinition).type, excludingConforming, excludingTo)    endif  endif endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Same as conformsTo(Featured):Boolean but with the possibility to pass pairs of Featured elements that are to be considered conforming and thus don't need further exploration. This can be used to avoid endless recursions in conformance testing."/>
        </eAnnotations>
        <eParameters name="td" eType="#//classes/TypeDefinition"/>
        <eParameters name="excludingConforming" eType="#//classes/SapClass"/>
        <eParameters name="excludingTo" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="conformsToIgnoringMultiplicity" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self = typeDef then   true  else    self.conformsToIgnoringMultiplicityExcluding(typeDef, Sequence{}, Sequence{})  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eParameters name="typeDef" eType="#//classes/TypeDefinition"/>
      </eOperations>
      <eOperations name="getTypeUsage" eType="#//classes/TypedElement">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="TypedElement.allInstances()->select(te | te.getType() = self)"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eOperations name="getInnermost" eType="#//classes/TypeDefinition">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self.oclIsKindOf(NestedTypeDefinition) then    self.oclAsType(NestedTypeDefinition).type.getInnermost()  else    self  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="For nexted type definitions, navigates through to the inner type definition. For non-nested type definitions, that type definition is the result of this method."/>
        </eAnnotations>
      </eOperations>
      <eOperations name="getNestingLevel" eType="ecore:EDataType primitivetypes.ecore#//Integer">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self.oclIsKindOf(NestedTypeDefinition) then    self.oclAsType(NestedTypeDefinition).type.getNestingLevel() + 1  else    0  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="signaturesWithOutput"
          upperBound="-1" eType="#//classes/Signature" eOpposite="#//classes/Signature/output"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownerTypedElement" eType="#//classes/TypedElement"
          transient="true" eOpposite="#//classes/TypedElement/ownedTypeDefinition"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownerSignature" eType="#//classes/Signature"
          transient="true" eOpposite="#//classes/Signature/ownedTypeDefinitions"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="NestedTypeDefinition" eSuperTypes="#//classes/TypeDefinition">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="NestedIsAlwaysMany" value="self.isMany()"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="NestedIsAlwaysMany"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="op" eType="ecore:EDataType primitivetypes.ecore#//String">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Only for syntax mapping issues, hopefully disappearing again in the future. It holds the operator that syntactically introduced this nested type definition, such as &quot;[&quot; or &quot;*&quot;."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="type" lowerBound="1"
          eType="#//classes/TypeDefinition">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedTypeDefinition"
          eType="#//classes/TypeDefinition" containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value="owningNestedTypeDefinition"/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="FunctionSignatureTypeDefinition" eSuperTypes="#//classes/TypeDefinition">
      <eStructuralFeatures xsi:type="ecore:EReference" name="signature" lowerBound="1"
          eType="#//classes/Signature">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedSignature" eType="#//classes/Signature"
          containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="MethodSignature" eSuperTypes="#//classes/Signature modelmanagement.ecore#//NamedElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="a signature of a method defined in a class"/>
      </eAnnotations>
      <eOperations name="isAbstract" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.implementation->isEmpty()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="producer" eType="ecore:EClass behavioral.ecore#//events/EventProducer"
          transient="true" eOpposite="behavioral.ecore#//events/EventProducer/notificationSignatures"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="implementation" eType="#//classes/SignatureImplementation"
          containment="true" eOpposite="#//classes/SignatureImplementation/implements_"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="owner" eType="#//classes/SignatureOwner"
          transient="true" eOpposite="#//classes/SignatureOwner/ownedSignatures"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="converter" eType="#//classes/ConverterBetweenParametrizations"
          eOpposite="#//classes/ConverterBetweenParametrizations/conversionMethod"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="FunctionSignature" eSuperTypes="#//classes/Signature">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="signature definition for an anonymous function that has to be implemented by a block"/>
      </eAnnotations>
      <eOperations name="isAbstract" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.implementation->isEmpty()"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="implementation" eType="#//classes/FunctionSignatureImplementation"
          containment="true" eOpposite="#//classes/FunctionSignatureImplementation/functionSignature"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="dimension" eType="ecore:EClass dataaccess.ecore#//analytics/Dimension"
          transient="true" eOpposite="dataaccess.ecore#//analytics/Dimension/characteristicFunction"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="cellSetForValueFunction"
          eType="ecore:EClass dataaccess.ecore#//analytics/CellSet" transient="true"
          eOpposite="dataaccess.ecore#//analytics/CellSet/valueFunction"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="cellSetForAggregationFunction"
          eType="ecore:EClass dataaccess.ecore#//analytics/CellSet" transient="true"
          eOpposite="dataaccess.ecore#//analytics/CellSet/aggregationFunction"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="LinkSetting" eSuperTypes="#//classes/ExtentModifyingAssociationEndSignatureImplementation">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Replaces all links of the association of which the association end *end* is part and which connect to the object on which this implementation is invoked with their other end. The links are replaced by links from the object on which the implementation is invoked to the object(s) passed to this implementation as argument."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="InputTypeMatchEndType" value="self.implements_.output->isEmpty() and&#xD;&#xA;  self.implements_.input->size() = 1 and &#xD;&#xA;  self.implements_.input->at(1).getType().oclIsKindOf(ClassTypeDefinition) and &#xD;&#xA;  self.implements_.input->at(1).getType().oclAsType(ClassTypeDefinition).clazz = self.end.type.clazz"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="InputTypeMatchEndType"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="TypeAdapter" eSuperTypes="#//classes/SignatureOwner">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="AllSignatureConforms" value="self.ownedSignatures->forAll(selfSig:MethodSignature |&#xD;&#xA;    self.to.signaturesWithDelegation()->exists(toSig:MethodSignature |&#xD;&#xA;       selfSig.conformsTo(toSig)))"/>
        <details key="SignaturesCannotBeAbstract" value="self.ownedSignatures->forAll(selfSig:MethodSignature | not selfSig.isAbstract())"/>
        <details key="IsFullAdaptationToTo" value="self.to.signaturesWithDelegation()->forAll(toSig|&#xD;&#xA;    self.adapted.signaturesWithDelegation()->exists(adaptedSig|&#xD;&#xA;      adaptedSig.conformsTo(toSig))&#xD;&#xA;    or self.ownedSignatures->exists(ownedSig|&#xD;&#xA;      ownedSig.conformsTo(toSig)))"/>
        <details key="ValuesToValues_EntitiesToEntities" value="self.adapted.valueType = self.to.valueType"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="AllSignatureConforms SignaturesCannotBeAbstract IsFullAdaptationToTo ValuesToValues_EntitiesToEntities"/>
      </eAnnotations>
      <eOperations name="conformsTo" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="type.signaturesWithDelegation()->forAll(typeSig:MethodSignature |    self.allSignatures()->exists(selfSig:MethodSignature |       selfSig.conformsToExcluding(typeSig, Sequence{self.to}, Sequence{type})))"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="A class A conforms to a class B if for every signature that B has (either directly or by delegation, but not from any adapters), A has a conforming signature, either immediately declared in A or by delegation or through a type adapter."/>
        </eAnnotations>
        <eParameters name="type" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="conformsToExcluding" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="Sequence{1..excludingConforming->size()}->exists(i|  excludingConforming->asSequence()->at(i) = self.to and excludingTo->asSequence()->at(i) = type) or  type.signaturesWithDelegation()->forAll(typeSig:MethodSignature |         self.allSignatures()->exists(selfSig:MethodSignature |            selfSig.conformsToExcluding(typeSig,                    excludingConforming->asSequence()->append(self.to),                    excludingTo->asSequence()->append(type))))"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Same as conformsTo(Featured):Boolean but with the possibility to pass pairs of Featured elements that are to be considered conforming and thus don't need further exploration. This can be used to avoid endless recursions in conformance testing."/>
        </eAnnotations>
        <eParameters name="type" eType="#//classes/SapClass"/>
        <eParameters name="excludingConforming" eType="#//classes/SapClass"/>
        <eParameters name="excludingTo" eType="#//classes/SapClass"/>
      </eOperations>
      <eOperations name="allSignatures" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.allSignaturesExcluding(Set{})"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Computes all locally-defined signatures plus not conforming signatures offered by 'To' Class. "/>
        </eAnnotations>
      </eOperations>
      <eOperations name="allSignaturesExcluding" eType="#//classes/MethodSignature">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.to.allSignaturesExcluding(excluding)->select(s |    not self.ownedSignatures->exists(os | os.conformsTo(s)))->union(  self.ownedSignatures)"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Same as allSignatures() but with the possibility to to avoid endless recursions."/>
        </eAnnotations>
        <eParameters name="excluding" eType="#//classes/SapClass"/>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="to" lowerBound="1" eType="#//classes/SapClass"
          eOpposite="#//classes/SapClass/adaptedBy"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="adapted" lowerBound="1"
          eType="#//classes/SapClass" transient="true" eOpposite="#//classes/SapClass/adapters"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="Parameter" eSuperTypes="#//classes/NamedValue">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="DefaultValueType" value="self.defaultValue->notEmpty() implies self.defaultValue.getType().conformsTo(self.getType())"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="DefaultValueType"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownerSignature" eType="#//classes/Signature"
          transient="true" eOpposite="#//classes/Signature/input"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="defaultValue" eType="ecore:EClass dataaccess.ecore#//expressions/Expression"
          containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="NamedValue" abstract="true" eSuperTypes="modelmanagement.ecore#//NamedElement #//classes/TypedElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A value that can be used by name in the scope of a Block. Specializations are, e.g., Constant and Variable. Specializations may have different rules for initialization expressions."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="owner" eType="ecore:EClass behavioral.ecore#//actions/Block"
          transient="true" eOpposite="behavioral.ecore#//actions/Block/variables"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="PlatformSpecificImplementation">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="targetPlatform" eType="ecore:EDataType primitivetypes.ecore#//String"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="implementation" eType="ecore:EDataType primitivetypes.ecore#//String"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="NativeImpl" eSuperTypes="#//classes/SignatureImplementation">
      <eStructuralFeatures xsi:type="ecore:EReference" name="platformSpecificImplementaiton"
          upperBound="-1" eType="#//classes/PlatformSpecificImplementation" containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SignatureOwner" eSuperTypes="modelmanagement.ecore#//NamedElement">
      <eStructuralFeatures xsi:type="ecore:EReference" name="ownedSignatures" upperBound="-1"
          eType="#//classes/MethodSignature" containment="true" eOpposite="#//classes/MethodSignature/owner"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ExtentModifyingAssociationEndSignatureImplementation"
        abstract="true" eSuperTypes="#//classes/AssociationEndSignatureImplementation">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Abstract base class for all association extent-manipulating signature implementations. Groups all constraints that apply to those."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="MustNotModifyExtentIfEqualityRelevantForValueClass" value="end.association.ends->forAll(ae:AssociationEnd |&#xD;&#xA;    ae.contributesToEquality implies not ae.type.clazz.valueType)"/>
        <details key="MustNotImplementSideEffectFreeOperation" value="not self.implements_.sideEffectFree"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="MustNotModifyExtentIfEqualityRelevantForValueClass MustNotImplementSideEffectFreeOperation"/>
      </eAnnotations>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="FunctionSignatureImplementation" eSuperTypes="#//classes/SignatureImplementation">
      <eOperations name="isSideEffectFree" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="if self.oclIsKindOf(Block) then    self.oclAsType(Block).localIsSideEffectFree()  else    if self.oclIsKindOf(CellSet) then      self.oclAsType(CellSet).localIsSideEffectFree()    else      false    endif  endif"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="functionSignature" eType="#//classes/FunctionSignature"
          transient="true" eOpposite="#//classes/FunctionSignature/implementation"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ActualObjectParameter">
      <eStructuralFeatures xsi:type="ecore:EReference" name="formalObjectParameter"
          lowerBound="1" eType="#//classes/Parameter">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="classTypeDefinitions"
          upperBound="-1" eType="#//classes/ClassTypeDefinition" eOpposite="#//classes/ClassTypeDefinition/objectParameters"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="value" lowerBound="1"
          eType="ecore:EClass dataaccess.ecore#//expressions/Expression" containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="owningClassTypeDefinition"
          lowerBound="1" eType="#//classes/ClassTypeDefinition" transient="true" eOpposite="#//classes/ClassTypeDefinition/ownedObjectParameters"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ConverterBetweenParametrizations">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Specifies a method as converter method. This class is mostly used as a constraint container for such a construct."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="MustHaveConcreteMethod" value="not self.conversionMethod.isAbstract()"/>
        <details key="FormalObjectParametersConformToMethodParameters" value="self.conversionMethod.input->size() = self.clazz.formalObjectParameters->size() and&#xD;&#xA;  Sequence{1..self.conversionMethod.input->size()}->forAll(i |&#xD;&#xA;    self.clazz.formalObjectParameters->at(i).conformsTo(self.conversionMethod.input->at(i)))"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="MustHaveConcreteMethod FormalObjectParametersConformToMethodParameters"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="clazz" lowerBound="1"
          eType="#//classes/SapClass" transient="true" eOpposite="#//classes/SapClass/converterBetweenParametrizations"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="conversionMethod" lowerBound="1"
          eType="#//classes/MethodSignature" eOpposite="#//classes/MethodSignature/converter"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="LinkManipulationAtPosition" abstract="true"
        eSuperTypes="#//classes/ExtentModifyingAssociationEndSignatureImplementation">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="An implementation that optionally specifies a position in an ordered link set telling where to apply the modification."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="at" eType="ecore:EDataType primitivetypes.ecore#//Integer"/>
    </eClassifiers>
  </eSubpackages>
  <eSubpackages name="constraints" nsURI="http:///data/constraints.ecore" nsPrefix="data.constraints">
    <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
      <details key="invocationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
      <details key="validationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
    </eAnnotations>
    <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
      <details key="documentation" value="Complex data types (as opposed to the basic data types that are plain CCTS types)"/>
    </eAnnotations>
    <eClassifiers xsi:type="ecore:EClass" name="Constraint" eSuperTypes="modelmanagement.ecore#//NamedElement">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="An instance of this class defines a subset of the instances of the type it constains. It does so by providing a predicate (&quot;characteristic function&quot;). Instances of the type constrained for which the predicate holds are part of the subset, the others are not."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="ExpressionTypeMustBeBoolean" value="self.constraintExpression.getType().upperMultiplicity = 1 and&#xD;&#xA;  self.constraintExpression.getType().oclIsKindOf(ClassTypeDefinition) and&#xD;&#xA;  self.constraintExpression.getType().oclAsType(ClassTypeDefinition).clazz.name = 'Boolean'"/>
        <details key="MustBeOwned" value="self.constrainedType->notEmpty() or&#xD;&#xA;  self.theContext->notEmpty() or&#xD;&#xA;  self.preconditionForSignature->notEmpty() or&#xD;&#xA;  self.postconditionForSignature->notEmpty()"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="ExpressionTypeMustBeBoolean MustBeOwned"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="theContext" eType="#//classes/Context"
          transient="true" eOpposite="#//classes/Context/constraints"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="constrainedType" eType="#//classes/SapClass"
          transient="true" eOpposite="#//classes/SapClass/constraints"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="severityInState" lowerBound="1"
          upperBound="-1" eType="#//constraints/SeverityInState" containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value="constraint"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="constraintExpression"
          lowerBound="1" eType="ecore:EClass dataaccess.ecore#//expressions/Expression"
          containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="ObjectState">
      <eLiterals name="INITIAL"/>
      <eLiterals name="TRANSIENT" value="1"/>
      <eLiterals name="SAVED" value="2"/>
      <eLiterals name="ACTIVE" value="3"/>
      <eLiterals name="COMPLIANT" value="4"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EEnum" name="Severity">
      <eLiterals name="WARNING"/>
      <eLiterals name="ERROR" value="1"/>
      <eLiterals name="ILLEGAL" value="2"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="SeverityInState">
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="state" eType="#//constraints/ObjectState"/>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="severity" eType="#//constraints/Severity"/>
    </eClassifiers>
  </eSubpackages>
  <eSubpackages name="quantitystructure" nsURI="http:///data/quantitystructure.ecore"
      nsPrefix="data.quantitystructure">
    <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
      <details key="invocationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
      <details key="validationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
    </eAnnotations>
    <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
      <details key="documentation" value="Helps modelers to specify the numbers of instances of types, relations and the access patterns over them. This can later be used to optimize data representation, partitioning and deployment."/>
    </eAnnotations>
    <eClassifiers xsi:type="ecore:EClass" name="Dummy"/>
  </eSubpackages>
  <eSubpackages name="timedependency" nsURI="http:///data/timedependency.ecore" nsPrefix="data.timedependency">
    <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
      <details key="invocationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
      <details key="validationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
    </eAnnotations>
    <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
      <details key="documentation" value="Models the aspect of time-dependent data. If a structural feature such as a class or a property or an association is marked as time-dependent, clients expect to find time-dependent access operations for read access. If no time is specified, the time of access is implicitly assumed.&#xD;&#xA;&#xD;&#xA;Modifications to such structures keep the history of the data. Again, if no modification time is explicitly specified, the time at which the modification occurs is used implicitly.&#xD;&#xA;&#xD;&#xA;Clarify if it should be possible to &quot;modify history.&quot; In other words, should it be possible to make structural changes in data that was already recorded in the past?&#xD;&#xA;&#xD;&#xA;TODO Perhaps this package should be separated out into an own top-level metamodel package because it has dependencies on behavioral/actions and dataaccess/expressions."/>
    </eAnnotations>
    <eClassifiers xsi:type="ecore:EClass" name="TimeDependency">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="Captures the specification for how to deal in detail with the time-dependent nature of the annotated structural feature.&#xD;&#xA;&#xD;&#xA;Time dependence of a class means that the existence of an instance of that class is timie dependent. A time-dependent association means that the existence of each link of that association is time dependent.&#xD;&#xA;&#xD;&#xA;Read operations on time-dependent classes and associations (such as queries and navigation) can optionally specify a point in time or a timespan. If no time or timespan is specified, the current time is assumed.&#xD;&#xA;&#xD;&#xA;Write/update operations by default will use the current time as the point in time, or an open time interval starting at the current time (in case of a timespan feature). Any open previous timespan by default will be closed at the current time by an update.&#xD;&#xA;&#xD;&#xA;Read and update operations of time-dependent features can optionally be equipped with a time/timespan telling the temporal validity of the values updated or the values to be read."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="RecordCutoffGreaterOrEqualZero" value="self.recordCutoffInMilliseconds >= 0"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="RecordCutoffGreaterOrEqualZero"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="recordCutoffInMilliseconds"
          eType="ecore:EDataType primitivetypes.ecore#//Integer">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="The number of milliseconds for which to keep historic versions of this feature. Only values greater or equal to zero are permitted. 0 means that no historic versions are kept at all."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="canChangePast" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="If true, it is permissible to change values of the time-dependent feature for previous times."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EAttribute" name="timespan" eType="ecore:EDataType primitivetypes.ecore#//Boolean">
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="If true, data is valid over a given timespan, not only a single point in time. When writing data, the validity period is to be specified as a timespan rather than a point in time.&#xD;&#xA;&#xD;&#xA;If false, data samples are valid only at a single point in time, such as from an RFID reader or a temperature sensor. Access APIs would have to allow for conveniently finding the &quot;nearest&quot; match for a given point in time."/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="theClass" lowerBound="1"
          eType="#//classes/SapClass" transient="true" eOpposite="#//classes/SapClass/timeDependency"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="association" lowerBound="1"
          eType="#//classes/Association" transient="true" eOpposite="#//classes/Association/timeDependency"/>
    </eClassifiers>
  </eSubpackages>
  <eSubpackages name="documents" nsURI="http:///data/documents.ecore" nsPrefix="data.documents">
    <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
      <details key="invocationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
      <details key="validationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
    </eAnnotations>
    <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
      <details key="documentation" value="Structures that help referencing and managing---typically external---document repositories. Structures shall allow to reference documents in such a repository, say something about the lifecycle of documents in such a repository in connection to the life cycle of other model elements, and integrate document repository capabilities into the modeling world, such as document ranking, versioning, etc."/>
    </eAnnotations>
    <eClassifiers xsi:type="ecore:EClass" name="Dummy"/>
  </eSubpackages>
  <eSubpackages name="generics" nsURI="http:///data/generics.ecore" nsPrefix="data.generics">
    <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
      <details key="invocationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
      <details key="validationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
    </eAnnotations>
    <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
      <details key="documentation" value="Describes how types can be parameterized. Parameterizable types include classes and tuples. Classes can be declared to have a list of DataType arguments. Those arguments can then be used within a class definition wherever a DataType is allowed. If a type argument is a class, it may be used wherever a class is allowed."/>
    </eAnnotations>
    <eClassifiers xsi:type="ecore:EClass" name="FormalTypeParameter" eSuperTypes="#//classes/SapClass">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A formal type argument to the ParameterizedClass owning this parameter object. It is valid only in the scope of the classDefinition owned by the ParameterizedClass that owns this parameter object."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="UseInSignaturesOfOwningParamerizedClassOnly" value="self.elementsOfType.getTypeUsage()->forAll(s | s.oclIsKindOf(Parameter) implies &#xD;&#xA;   (s.oclAsType(Parameter).ownerSignature.oclIsKindOf(MethodSignature) and&#xD;&#xA;    s.oclAsType(Parameter).ownerSignature.oclAsType(MethodSignature).owner=self.parameterOf .owningClassDefinition)) and&#xD;&#xA;  self.elementsOfType.signaturesWithOutput->forAll(s| s.oclIsKindOf(MethodSignature) and &#xD;&#xA;    s.oclAsType(MethodSignature).owner->notEmpty() and&#xD;&#xA;    s.oclAsType(MethodSignature).owner=self.parameterOf.owningClassDefinition) and&#xD;&#xA;  self.signaturesWithFault->forAll(s| s.oclIsKindOf(MethodSignature)  and &#xD;&#xA;    s.oclAsType(MethodSignature).owner->notEmpty() and&#xD;&#xA;    s.oclAsType(MethodSignature).owner=self.parameterOf.owningClassDefinition)"/>
        <details key="UseInAssociationsOfOwningParameterizedClassOnly" value="self.elementsOfType.associationEnd->&#xD;&#xA;    forAll(ae | ae.otherEnd().type.clazz = self.parameterOf.owningClassDefinition)"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="UseInSignaturesOfOwningParamerizedClassOnly UseInAssociationsOfOwningParameterizedClassOnly"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="parameterOf" lowerBound="1"
          eType="#//generics/ClassParameterization" transient="true" eOpposite="#//generics/ClassParameterization/formalTypeParameters"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="typeConstraint" eType="#//classes/SapClass">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="actualTypeParameters"
          upperBound="-1" eType="#//generics/ActualTypeParameter" eOpposite="#//generics/ActualTypeParameter/formalTypeParameter"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ParameterizedClassInstantiation" eSuperTypes="#//classes/SapClass">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="An instantiation of a parameterized class (a class that has one or more FormalTypeParameters associated) with a set of data types that match the parameterized type's signature. The instantiation is itself usable as a Class. It may as such itself still have formal type parameters which then make it a parameterized class that itself requires instantiation before it it a fully-specified type."/>
      </eAnnotations>
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="ActualTypeParametersMatchSignature" value="self.actualTypeParametersForInstantiation->size() = self.parameterizedClass.parameterization.formalTypeParameters->size() and&#xD;&#xA;  Sequence{1..self.actualTypeParametersForInstantiation->size()}->forAll(i:Integer|&#xD;&#xA;    self.actualTypeParametersForInstantiation->at(i).formalTypeParameter =&#xD;&#xA;    self.parameterizedClass.parameterization.formalTypeParameters->at(i))"/>
        <details key="ClassMustBeParameterized" value="self.parameterizedClass.parameterization->notEmpty()"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="ActualTypeParametersMatchSignature ClassMustBeParameterized"/>
      </eAnnotations>
      <eOperations name="resolveFormalTypeParameter" eType="#//classes/SapClass">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="self.actualTypeParametersForInstantiation->select(atp:ActualTypeParameter |    atp.formalTypeParameter = ftp)->asSequence()->at(1).type"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
          <details key="documentation" value="Returns the ActualTypeParameter's type (a Class) from the actualTypeParameters association end whose formalTypeParameter is the one passed. If no such formal type parameter is found, no object (null) is returned."/>
        </eAnnotations>
        <eParameters name="ftp" eType="#//generics/FormalTypeParameter"/>
      </eOperations>
      <eOperations name="getClassParameterization" eType="#//generics/ClassParameterization">
        <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
          <details key="body" value="parameterizedClass.parameterization"/>
        </eAnnotations>
        <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
          <details key="constraints" value="body"/>
        </eAnnotations>
      </eOperations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="actualTypeParametersForInstantiation"
          lowerBound="1" upperBound="-1" eType="#//generics/ActualTypeParameter" containment="true"
          eOpposite="#//generics/ActualTypeParameter/parameterizedClassInstantiation"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="parameterizedClass" lowerBound="1"
          eType="#//classes/SapClass">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ClassParameterization">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="DistinctFormalTypeParameterNames" value="self.formalTypeParameters->forAll(i,j|i&lt;>j implies i.name&lt;>j.name)"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="DistinctFormalTypeParameterNames"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="formalTypeParameters"
          lowerBound="1" upperBound="-1" eType="#//generics/FormalTypeParameter" containment="true"
          eOpposite="#//generics/FormalTypeParameter/parameterOf"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="owningClassDefinition"
          lowerBound="1" eType="#//classes/SapClass" transient="true" eOpposite="#//classes/SapClass/parameterization"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="package_" eType="ecore:EClass modelmanagement.ecore#//Package"
          transient="true" eOpposite="modelmanagement.ecore#//Package/parameterizedClasses"/>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="ActualTypeParameter">
      <eAnnotations source="http://de.hpi.sam.bp2009.OCL">
        <details key="TypeConformsWithFormalParametersTypeConstraint" value="self.formalTypeParameter.typeConstraint->notEmpty() implies&#xD;&#xA;    self.type.conformsTo(self.formalTypeParameter.typeConstraint)"/>
      </eAnnotations>
      <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
        <details key="constraints" value="TypeConformsWithFormalParametersTypeConstraint"/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="parameterizedClassInstantiation"
          lowerBound="1" eType="#//generics/ParameterizedClassInstantiation" transient="true"
          eOpposite="#//generics/ParameterizedClassInstantiation/actualTypeParametersForInstantiation"/>
      <eStructuralFeatures xsi:type="ecore:EReference" name="type" lowerBound="1"
          eType="#//classes/SapClass">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value="actualTypeParametersOfClass"/>
        </eAnnotations>
      </eStructuralFeatures>
      <eStructuralFeatures xsi:type="ecore:EReference" name="formalTypeParameter"
          lowerBound="1" eType="#//generics/FormalTypeParameter" eOpposite="#//generics/FormalTypeParameter/actualTypeParameters"/>
    </eClassifiers>
  </eSubpackages>
  <eSubpackages name="tuples" nsURI="http:///data/tuples.ecore" nsPrefix="data.tuples">
    <eAnnotations source="http://www.eclipse.org/emf/2002/Ecore">
      <details key="invocationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
      <details key="validationDelegates" value="http://de.hpi.sam.bp2009.OCL"/>
    </eAnnotations>
    <eClassifiers xsi:type="ecore:EClass" name="TupleTypeDefinition" eSuperTypes="#//classes/TypeDefinition">
      <eAnnotations source="http://www.eclipse.org/emf/2002/GenModel">
        <details key="documentation" value="A tuple type defines named and typed elements. Conformance for tuple types is less strict. It need not be explicitly defined as is required for classes. This allows tuple types to conform to each other based on their structure."/>
      </eAnnotations>
      <eStructuralFeatures xsi:type="ecore:EReference" name="elements" lowerBound="1"
          upperBound="-1" eType="#//tuples/TupleElement" containment="true">
        <eAnnotations source="http://schema.omg.org/spec/MOF/2.0/emof.xml">
          <details key="Property.oppositeRoleName" value=""/>
        </eAnnotations>
      </eStructuralFeatures>
    </eClassifiers>
    <eClassifiers xsi:type="ecore:EClass" name="TupleElement" eSuperTypes="modelmanagement.ecore#//NamedElement #//classes/TypedElement"/>
  </eSubpackages>
</ecore:EPackage>
