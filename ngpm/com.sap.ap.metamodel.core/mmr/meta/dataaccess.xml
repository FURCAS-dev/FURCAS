<?xml version = '1.0' encoding = 'ISO-8859-1' ?>
<!-- <!DOCTYPE XMI SYSTEM 'Model1311.DTD' > -->
<XMI xmi.version = '1.1' xmlns:Model='omg.org/mof.Model/1.3' timestamp = 'Wed Mar 10 13:04:34 2010' >
 <XMI.header>
  <XMI.documentation>
   <XMI.exporter>Unisys.JCR.1</XMI.exporter>
   <XMI.exporterVersion>1.3.2</XMI.exporterVersion>
  </XMI.documentation>
  <XMI.metamodel xmi.name = 'org.omg.mof.Model' xmi.version = '1.3'/>
 </XMI.header>
<XMI.content>
<!-- ==================== dataaccess    [Package] ==================== -->
<Model:Package xmi.id = 'a453E0CD8006C' 
  name = 'dataaccess' annotation = '' 
  isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' >
  <Model:Namespace.contents>
    <!-- ==================== dataaccess.expressions    [Package] ==================== -->
    <Model:Package xmi.id = 'a45191D730367' 
      name = 'expressions' annotation = 'Specifies an expression language that allows its users for form expressions over objects and values, producing other objects and values.' 
      isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' >
      <Model:Namespace.contents>
        <!-- ==================== dataaccess.expressions.literals    [Package] ==================== -->
        <Model:Package xmi.id = 'a4717D1DA0359' 
          name = 'literals' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' >
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.literals.Literal    [Class] ==================== -->
            <Model:Class xmi.id = 'a454746D10018' 
              name = 'Literal' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.annotation>A literal of any primitive type, such as "This is a string" or 123 or an enumeration literal or a literal denoting a value of an implicit anonymous class, or a block, or a literal that denotes a (potentially anonymous) class.

The exact type of a literal may not always be possible to decide completely, particularly when it comes to constrained types over primitive types. This can only come in through "post types" and type inference, e.g., in an assignment statement where the type of the lvalue is known.</Model:ModelElement.annotation>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:GeneralizableElement.supertypes>
              <Model:Namespace.contents>
                <!-- ==================== dataaccess.expressions.literals.Literal.literal    [Attribute] ==================== -->
                <Model:Attribute xmi.id = 'a45D9808702F7' 
                  name = 'literal' annotation = 'Represents the value of this literal as a string. Final interpretation has to happen by the type of the literal expression. For string literals this is particularly straightforward. For numbers and dates, specific formats as defined by the respective types may apply.' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' 
                  isDerived = 'false' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'PrimitiveTypes.xml|a39A2BDA60394'/>
                  </Model:TypedElement.type>
                </Model:Attribute>
              </Model:Namespace.contents>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.literals.BinaryLiteral    [Class] ==================== -->
            <Model:Class xmi.id = 'a4717D1FE0387' 
              name = 'BinaryLiteral' annotation = '' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a454746D10018'/>  <!-- dataaccess.expressions.literals.Literal -->
              </Model:GeneralizableElement.supertypes>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.literals.StringLiteral    [Class] ==================== -->
            <Model:Class xmi.id = 'a4717D20103C6' 
              name = 'StringLiteral' annotation = '' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a454746D10018'/>  <!-- dataaccess.expressions.literals.Literal -->
              </Model:GeneralizableElement.supertypes>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.literals.NumberLiteral    [Class] ==================== -->
            <Model:Class xmi.id = 'a4717D202026E' 
              name = 'NumberLiteral' annotation = '' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a454746D10018'/>  <!-- dataaccess.expressions.literals.Literal -->
              </Model:GeneralizableElement.supertypes>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.literals.TimePointLiteral    [Class] ==================== -->
            <Model:Class xmi.id = 'a4717D2030107' 
              name = 'TimePointLiteral' annotation = '' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a454746D10018'/>  <!-- dataaccess.expressions.literals.Literal -->
              </Model:GeneralizableElement.supertypes>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.literals.BooleanLiteral    [Class] ==================== -->
            <Model:Class xmi.id = 'a4717D204001C' 
              name = 'BooleanLiteral' annotation = '' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a454746D10018'/>  <!-- dataaccess.expressions.literals.Literal -->
              </Model:GeneralizableElement.supertypes>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.literals.ObjectLiteral    [Class] ==================== -->
            <Model:Class xmi.id = 'a4717D20502BC' 
              name = 'ObjectLiteral' annotation = '' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.constraints>
                <Model:Constraint xmi.idref = 'a4974924900EA'/>  <!-- dataaccess.expressions.literals.ObjectLiteral.ObjectLiteralsForValueClassesOnly -->
                <Model:Constraint xmi.idref = 'a4974927802DE'/>  <!-- dataaccess.expressions.literals.ObjectLiteral.ObjectLiteralPropertiesOnRightClass -->
                <Model:Constraint xmi.idref = 'a4A0E960C0028'/>  <!-- dataaccess.expressions.literals.ObjectLiteral.ValuesMustBeProvidedForAllMandatoryProperties -->
              </Model:ModelElement.constraints>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:GeneralizableElement.supertypes>
              <Model:Namespace.contents>
                <!-- ==================== dataaccess.expressions.literals.ObjectLiteral.valueClass    [Reference] ==================== -->
                <Model:Reference xmi.id = 'ra497490F90222' 
                  name = 'valueClass' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a4432171B031E'/>
                  </Model:TypedElement.type>
                  <Model:Reference.referencedEnd>
                    <Model:AssociationEnd xmi.idref = 'a497490F90222'/>
                  </Model:Reference.referencedEnd>
                </Model:Reference>
                <!-- ==================== dataaccess.expressions.literals.ObjectLiteral.propertyValues    [Reference] ==================== -->
                <Model:Reference xmi.id = 'ra497491CE0157' 
                  name = 'propertyValues' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a4974918A0232'/>  <!-- dataaccess.expressions.literals.ValueInit -->
                  </Model:TypedElement.type>
                  <Model:Reference.referencedEnd>
                    <Model:AssociationEnd xmi.idref = 'a497491CE0157'/>
                  </Model:Reference.referencedEnd>
                </Model:Reference>
                <!-- ==================== dataaccess.expressions.literals.ObjectLiteral.isEqualTo    [Operation] ==================== -->
                <Model:Operation xmi.id = 'a4A0D2FFB01C5' 
                  name = 'isEqualTo' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isQuery = 'false' >
                  <Model:Namespace.contents>
                    <Model:Parameter xmi.id = 'XX.97' 
                      name = '*return' annotation = '' 
                      direction = 'return_dir' >
                      <Model:Parameter.multiplicity>
                        <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                      </Model:Parameter.multiplicity>
                      <Model:TypedElement.type>
                        <Model:Classifier xml:link = 'simple' href = 'PrimitiveTypes.xml|a39A2BDA60392'/>
                      </Model:TypedElement.type>
                    </Model:Parameter>
                    <Model:Parameter xmi.id = 'XX.98' 
                      name = 'o' annotation = '' 
                      direction = 'in_dir' >
                      <Model:Parameter.multiplicity>
                        <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                      </Model:Parameter.multiplicity>
                      <Model:TypedElement.type>
                        <Model:Classifier xmi.idref = 'a4717D20502BC'/>  <!-- dataaccess.expressions.literals.ObjectLiteral -->
                      </Model:TypedElement.type>
                    </Model:Parameter>
                  </Model:Namespace.contents>
                </Model:Operation>
                <!-- ==================== dataaccess.expressions.literals.ObjectLiteral.ObjectLiteralsForValueClassesOnly    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a4974924900EA' 
                  name = 'ObjectLiteralsForValueClassesOnly' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectLiteral
inv:
  self.valueClass.valueType</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a4717D20502BC'/>  <!-- dataaccess.expressions.literals.ObjectLiteral -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
                <!-- ==================== dataaccess.expressions.literals.ObjectLiteral.ObjectLiteralPropertiesOnRightClass    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a4974927802DE' 
                  name = 'ObjectLiteralPropertiesOnRightClass' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectLiteral
inv:
  self.propertyValues-&gt;forAll(vi|vi.forEnd.otherEnd().type.clazz = self.valueClass)</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a4717D20502BC'/>  <!-- dataaccess.expressions.literals.ObjectLiteral -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
                <!-- ==================== dataaccess.expressions.literals.ObjectLiteral.ValuesMustBeProvidedForAllMandatoryProperties    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a4A0E960C0028' 
                  name = 'ValuesMustBeProvidedForAllMandatoryProperties' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectLiteral
inv:
  self.valueClass.getEqualityRelevantAssociationEnds()-&gt;select(ae | ae.otherEnd().type.lowerMultiplicity &gt; 0)-&gt;forAll(ae |
      self.propertyValues-&gt;exists(pv | pv.forEnd.otherEnd() = ae))</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a4717D20502BC'/>  <!-- dataaccess.expressions.literals.ObjectLiteral -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
              </Model:Namespace.contents>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.literals.org.omg.sap2mof.OperationCodeOcl=context ObjectLiteral::isEqualTo(o:ObjectLiteral):Boolean...    [Tag] ==================== -->
            <Model:Tag xmi.id = 'G.860' 
              name = 'org.omg.sap2mof.OperationCodeOcl=context ObjectLiteral::isEqualTo(o:ObjectLiteral):Boolean...' annotation = '' 
              tagId = 'org.omg.sap2mof.OperationCodeOcl' >
              <Model:Tag.values>
                <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectLiteral::isEqualTo(o:ObjectLiteral):Boolean
body:
  self.valueClass = o.valueClass and
  self.propertyValues-&gt;size() = o.propertyValues-&gt;size() and
  self.propertyValues-&gt;forAll(pv | o.propertyValues-&gt;exists(opv | opv.forEnd = pv.forEnd and opv.value.evaluatesToEqualAs(pv.value)))</XMI.any>
              </Model:Tag.values>
              <Model:Tag.elements>
                <Model:ModelElement xmi.idref = 'a4A0D2FFB01C5'/>  <!-- dataaccess.expressions.literals.ObjectLiteral.isEqualTo -->
              </Model:Tag.elements>
            </Model:Tag>
            <!-- ==================== dataaccess.expressions.literals.ValueInit    [Class] ==================== -->
            <Model:Class xmi.id = 'a4974918A0232' 
              name = 'ValueInit' annotation = 'Provides an initialization value for an association end whose other end is attached to a value class. The expression&apos;s type must conform to the association end&apos;s type.' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.constraints>
                <Model:Constraint xmi.idref = 'a4B26673A01D4'/>  <!-- dataaccess.expressions.literals.ValueInit.ValueInitTypeConforms -->
              </Model:ModelElement.constraints>
              <Model:Namespace.contents>
                <!-- ==================== dataaccess.expressions.literals.ValueInit.forEnd    [Reference] ==================== -->
                <Model:Reference xmi.id = 'ra497491EE0251' 
                  name = 'forEnd' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a44EC55FB03B8'/>
                  </Model:TypedElement.type>
                  <Model:Reference.referencedEnd>
                    <Model:AssociationEnd xmi.idref = 'a497491EE0251'/>
                  </Model:Reference.referencedEnd>
                </Model:Reference>
                <!-- ==================== dataaccess.expressions.literals.ValueInit.value    [Reference] ==================== -->
                <Model:Reference xmi.id = 'ra49749219005D' 
                  name = 'value' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
                  </Model:TypedElement.type>
                  <Model:Reference.referencedEnd>
                    <Model:AssociationEnd xmi.idref = 'a49749219005D'/>
                  </Model:Reference.referencedEnd>
                </Model:Reference>
                <!-- ==================== dataaccess.expressions.literals.ValueInit.ValueInitTypeConforms    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a4B26673A01D4' 
                  name = 'ValueInitTypeConforms' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context ValueInit
inv:
  self.value.getType().conformsTo(self.forEnd.type)</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a4974918A0232'/>  <!-- dataaccess.expressions.literals.ValueInit -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
              </Model:Namespace.contents>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.literals.A_valueClass_objectLiteral    [Association] ==================== -->
            <Model:Association xmi.id = 'a497490F800AB' 
              name = 'A_valueClass_objectLiteral' annotation = '' 
              isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
              isDerived = 'false' >
              <Model:Namespace.contents>
                <Model:AssociationEnd xmi.id = 'a497490F90222' 
                  name = 'valueClass' annotation = '' 
                  isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a4432171B031E'/>
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
                <Model:AssociationEnd xmi.id = 'a497490F903D8' 
                  name = 'objectLiteral' annotation = '' 
                  isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a4717D20502BC'/>  <!-- dataaccess.expressions.literals.ObjectLiteral -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
              </Model:Namespace.contents>
            </Model:Association>
            <!-- ==================== dataaccess.expressions.literals.A_propertyValues_objectLiteral    [Association] ==================== -->
            <Model:Association xmi.id = 'a497491CD01B5' 
              name = 'A_propertyValues_objectLiteral' annotation = '' 
              isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
              isDerived = 'false' >
              <Model:Namespace.contents>
                <Model:AssociationEnd xmi.id = 'a497491CE0157' 
                  name = 'propertyValues' annotation = '' 
                  isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a4974918A0232'/>  <!-- dataaccess.expressions.literals.ValueInit -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
                <Model:AssociationEnd xmi.id = 'a497491CE0159' 
                  name = 'objectLiteral' annotation = '' 
                  isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a4717D20502BC'/>  <!-- dataaccess.expressions.literals.ObjectLiteral -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
              </Model:Namespace.contents>
            </Model:Association>
            <!-- ==================== dataaccess.expressions.literals.A_forEnd_valueInit    [Association] ==================== -->
            <Model:Association xmi.id = 'a497491EE003E' 
              name = 'A_forEnd_valueInit' annotation = '' 
              isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
              isDerived = 'false' >
              <Model:Namespace.contents>
                <Model:AssociationEnd xmi.id = 'a497491EE0251' 
                  name = 'forEnd' annotation = '' 
                  isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a44EC55FB03B8'/>
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
                <Model:AssociationEnd xmi.id = 'a497491EE0290' 
                  name = 'valueInit' annotation = '' 
                  isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a4974918A0232'/>  <!-- dataaccess.expressions.literals.ValueInit -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
              </Model:Namespace.contents>
            </Model:Association>
            <!-- ==================== dataaccess.expressions.literals.A_value_valueInit    [Association] ==================== -->
            <Model:Association xmi.id = 'a497492170138' 
              name = 'A_value_valueInit' annotation = '' 
              isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
              isDerived = 'false' >
              <Model:Namespace.contents>
                <Model:AssociationEnd xmi.id = 'a49749219005D' 
                  name = 'value' annotation = '' 
                  isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
                <Model:AssociationEnd xmi.id = 'a4974921900FA' 
                  name = 'valueInit' annotation = '' 
                  isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a4974918A0232'/>  <!-- dataaccess.expressions.literals.ValueInit -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
              </Model:Namespace.contents>
            </Model:Association>
          </Model:Namespace.contents>
        </Model:Package>
        <!-- ==================== dataaccess.expressions.collectionExpressions    [Package] ==================== -->
        <Model:Package xmi.id = 'a4759564F00AB' 
          name = 'collectionExpressions' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' >
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.collectionExpressions.Including    [Class] ==================== -->
            <Model:Class xmi.id = 'a475956720213' 
              name = 'Including' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.annotation>Produces a new value which includes the *argument* object. If the *argument* object was already included in the *source* and the multiplicity of the *source* has the *unique* attribute set to *true*, the *what* object will not be added a second time and the resulting expression will be equal to the *source* expression's value.

If the *source* expression had multiplicity 1, the resulting expression's multiplicity is *, regardless of whether an object actually gets added.</Model:ModelElement.annotation>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a4ADF36A4001F'/>  <!-- dataaccess.expressions.collectionExpressions.CollectionExpressionWithArgument -->
              </Model:GeneralizableElement.supertypes>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.collectionExpressions.Excluding    [Class] ==================== -->
            <Model:Class xmi.id = 'a47595673001F' 
              name = 'Excluding' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.annotation>Produces a new value which includes one less occurrence of the *argument* object than *source* or no occurrence if *source* did not contain an occurrence.

If the *source* expression had multiplicity a..b, the resulting expression's multiplicity is Max(a-1, 0)..b, regardless of whether an object actually gets removed.</Model:ModelElement.annotation>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a4ADF36A4001F'/>  <!-- dataaccess.expressions.collectionExpressions.CollectionExpressionWithArgument -->
              </Model:GeneralizableElement.supertypes>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.collectionExpressions.IncludingAt    [Class] ==================== -->
            <Model:Class xmi.id = 'a475956750280' 
              name = 'IncludingAt' annotation = 'Like Including, produced a new value based on the *source* value that includes the *argument* object. In addition, *IncludingAt* specifies the position where to include the *argument* object. The multiplicity of source and resulting value have ordered=true. If *source* already includes an object equal to *argument* and the *source* multiplicity has unique=true, that element will afterwards be at the requested position or at the end of the resulting value if the *at* position is greater or equal the *source*&apos;s cardinality.' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a47B5ABDC038A'/>  <!-- dataaccess.expressions.collectionExpressions.WithPosition -->
                <Model:GeneralizableElement xmi.idref = 'a475956720213'/>  <!-- dataaccess.expressions.collectionExpressions.Including -->
              </Model:GeneralizableElement.supertypes>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.collectionExpressions.Iterate    [Class] ==================== -->
            <Model:Class xmi.id = 'a47595676008C' 
              name = 'Iterate' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.annotation>Given the number of iterators variables, assigns all possible tuples of values from the source expression to the iterators (combinatorial product). In particular, if only only one iterator variable is provided, this variable will "loop" through the values in the source expression. If the source expression has an ordered multiplicity, the iteration order corresponds with that order. Otherwise, iteration order is arbitrary and undefined.

For each combination of iterator variable values, the iteratorExpression will be evaluated. The result of each evaluation is assigned to the accumulator variable.

The iteratorExpression can use all iterators variables as well as the accumulator if one is declared, and of course all other variables in scope as well (block variables, etc.). If an accumulator is declared, an initial value must be provided for it.

The result of the Iterate expression is the value that the accumulator has when the iteration terminates or the value of the last iteratorExpression evaluation if no accumulator has been provided. By this rationale, the type of the Iterate expression equals the type of the iteratorExpression.</Model:ModelElement.annotation>
              <Model:ModelElement.constraints>
                <Model:Constraint xmi.idref = 'a47B5BE680167'/>  <!-- dataaccess.expressions.collectionExpressions.Iterate.AccumulatorTypeEqualsExpressionType -->
              </Model:ModelElement.constraints>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a47595F60033C'/>  <!-- dataaccess.expressions.collectionExpressions.CollectionExpression -->
              </Model:GeneralizableElement.supertypes>
              <Model:Namespace.contents>
                <!-- ==================== dataaccess.expressions.collectionExpressions.Iterate.iterators    [Reference] ==================== -->
                <Model:Reference xmi.id = 'ra4759625303C8' 
                  name = 'iterators' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'false' is_unique = 'true' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
                  </Model:TypedElement.type>
                  <Model:Reference.referencedEnd>
                    <Model:AssociationEnd xmi.idref = 'a4759625303C8'/>
                  </Model:Reference.referencedEnd>
                </Model:Reference>
                <!-- ==================== dataaccess.expressions.collectionExpressions.Iterate.accumulator    [Reference] ==================== -->
                <Model:Reference xmi.id = 'ra475963230109' 
                  name = 'accumulator' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A717EE033C'/>
                  </Model:TypedElement.type>
                  <Model:Reference.referencedEnd>
                    <Model:AssociationEnd xmi.idref = 'a475963230109'/>
                  </Model:Reference.referencedEnd>
                </Model:Reference>
                <!-- ==================== dataaccess.expressions.collectionExpressions.Iterate.iteratorExpression    [Reference] ==================== -->
                <Model:Reference xmi.id = 'ra475963450186' 
                  name = 'iteratorExpression' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
                  </Model:TypedElement.type>
                  <Model:Reference.referencedEnd>
                    <Model:AssociationEnd xmi.idref = 'a475963450186'/>
                  </Model:Reference.referencedEnd>
                </Model:Reference>
                <!-- ==================== dataaccess.expressions.collectionExpressions.Iterate.AccumulatorTypeEqualsExpressionType    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a47B5BE680167' 
                  name = 'AccumulatorTypeEqualsExpressionType' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context Iterate
inv:
  self.accumulator-&gt;notEmpty() implies
  (self.accumulator.ownedTypeDefinition-&gt;notEmpty() implies
     self.accumulator.ownedTypeDefinition.conformsTo(self.iteratorExpression.getType()))</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a47595676008C'/>  <!-- dataaccess.expressions.collectionExpressions.Iterate -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
              </Model:Namespace.contents>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.collectionExpressions.org.omg.sap2mof.store=no    [Tag] ==================== -->
            <Model:Tag xmi.id = 'G.862' 
              name = 'org.omg.sap2mof.store=no' annotation = '' 
              tagId = 'org.omg.sap2mof.store' >
              <Model:Tag.values>
                <XMI.any xmi.type = 'string' xmi.name = ''>no</XMI.any>
              </Model:Tag.values>
              <Model:Tag.elements>
                <Model:ModelElement xmi.idref = 'ra475963450186'/>  <!-- dataaccess.expressions.collectionExpressions.Iterate.iteratorExpression -->
                <Model:ModelElement xmi.idref = 'a475963450186'/>
              </Model:Tag.elements>
            </Model:Tag>
            <!-- ==================== dataaccess.expressions.collectionExpressions.CollectionExpression    [Class] ==================== -->
            <Model:Class xmi.id = 'a47595F60033C' 
              name = 'CollectionExpression' annotation = '' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:GeneralizableElement.supertypes>
              <Model:Namespace.contents>
                <!-- ==================== dataaccess.expressions.collectionExpressions.CollectionExpression.source    [Reference] ==================== -->
                <Model:Reference xmi.id = 'ra47595F930196' 
                  name = 'source' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
                  </Model:TypedElement.type>
                  <Model:Reference.referencedEnd>
                    <Model:AssociationEnd xmi.idref = 'a47595F930196'/>
                  </Model:Reference.referencedEnd>
                </Model:Reference>
              </Model:Namespace.contents>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.collectionExpressions.ExcludingAt    [Class] ==================== -->
            <Model:Class xmi.id = 'a47B5ABAC0232' 
              name = 'ExcludingAt' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.annotation>Like Excluding, but useful if multiple occurrences of the *argument* value exist. This expression removes the occurrence at the position specified by *at*. For this purpose, the argument value must have ordered=true, and so will the resulting value. If at position *at* there is no object that equals *argument* or the *at* position is outside the valid bounds, the resulting expression equals the *source* expression.

If the argument is a multi-object (cardinality &gt; 1), it needs to be ordered, and the argument's object sequence needs to exist at the position specified by *at*. If only a subsequence prefix is matched at position *at*, only that subsequence prefix will be excluded.</Model:ModelElement.annotation>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a47B5ABDC038A'/>  <!-- dataaccess.expressions.collectionExpressions.WithPosition -->
                <Model:GeneralizableElement xmi.idref = 'a47595673001F'/>  <!-- dataaccess.expressions.collectionExpressions.Excluding -->
              </Model:GeneralizableElement.supertypes>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.collectionExpressions.WithPosition    [Class] ==================== -->
            <Model:Class xmi.id = 'a47B5ABDC038A' 
              name = 'WithPosition' annotation = '' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.constraints>
                <Model:Constraint xmi.idref = 'a493E4C61031C'/>  <!-- dataaccess.expressions.collectionExpressions.WithPosition.SourceMustBeOrdered -->
              </Model:ModelElement.constraints>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a4B8504AE03C8'/>  <!-- dataaccess.expressions.ExpressionWithArgument -->
              </Model:GeneralizableElement.supertypes>
              <Model:Namespace.contents>
                <!-- ==================== dataaccess.expressions.collectionExpressions.WithPosition.at    [Attribute] ==================== -->
                <Model:Attribute xmi.id = 'a47595959002E' 
                  name = 'at' annotation = 'a position in an object with upper multiplicity &gt;1 and ordered=true.' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' 
                  isDerived = 'false' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'PrimitiveTypes.xml|a3B538AB300B3'/>
                  </Model:TypedElement.type>
                </Model:Attribute>
                <!-- ==================== dataaccess.expressions.collectionExpressions.WithPosition.SourceMustBeOrdered    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a493E4C61031C' 
                  name = 'SourceMustBeOrdered' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context WithPosition
inv:
  self.argument.getType().ordered</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a47B5ABDC038A'/>  <!-- dataaccess.expressions.collectionExpressions.WithPosition -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
              </Model:Namespace.contents>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.collectionExpressions.CollectionExpressionWithArgument    [Class] ==================== -->
            <Model:Class xmi.id = 'a4ADF36A4001F' 
              name = 'CollectionExpressionWithArgument' annotation = '' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.constraints>
                <Model:Constraint xmi.idref = 'a4ADF362100EA'/>  <!-- dataaccess.expressions.collectionExpressions.CollectionExpressionWithArgument.ArgumentTypeMustConformToCollectionExpressionType -->
              </Model:ModelElement.constraints>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a4B8504AE03C8'/>  <!-- dataaccess.expressions.ExpressionWithArgument -->
                <Model:GeneralizableElement xmi.idref = 'a47595F60033C'/>  <!-- dataaccess.expressions.collectionExpressions.CollectionExpression -->
              </Model:GeneralizableElement.supertypes>
              <Model:Namespace.contents>
                <!-- ==================== dataaccess.expressions.collectionExpressions.CollectionExpressionWithArgument.ArgumentTypeMustConformToCollectionExpressionType    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a4ADF362100EA' 
                  name = 'ArgumentTypeMustConformToCollectionExpressionType' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context CollectionExpressionWithArgument
inv:
  let snl : Integer = source.getType().getNestingLevel() in let anl : Integer = argument.getType().getNestingLevel() in
    if snl = anl then
      source.getType().conformsToIgnoringMultiplicity(argument.getType())
    else
      if snl = (anl + 1) then
        source.getType().oclAsType(NestedTypeDefinition).type.conformsToIgnoringMultiplicity(argument.getType())
      else
        if (snl + 1) = anl then
          source.getType().conformsToIgnoringMultiplicity(argument.getType().oclAsType(NestedTypeDefinition).type)
        else
          false
        endif
      endif
    endif</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a4ADF36A4001F'/>  <!-- dataaccess.expressions.collectionExpressions.CollectionExpressionWithArgument -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
              </Model:Namespace.contents>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.collectionExpressions.SourceOfCollectionExpression    [Association] ==================== -->
            <Model:Association xmi.id = 'a47595F91004E' 
              name = 'SourceOfCollectionExpression' annotation = '' 
              isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
              isDerived = 'false' >
              <Model:Namespace.contents>
                <Model:AssociationEnd xmi.id = 'a47595F930196' 
                  name = 'source' annotation = '' 
                  isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
                <Model:AssociationEnd xmi.id = 'a47595F9301C5' 
                  name = 'collectionExpression' annotation = '' 
                  isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a47595F60033C'/>  <!-- dataaccess.expressions.collectionExpressions.CollectionExpression -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
              </Model:Namespace.contents>
            </Model:Association>
            <!-- ==================== dataaccess.expressions.collectionExpressions.IterateIterator    [Association] ==================== -->
            <Model:Association xmi.id = 'a4759625301D4' 
              name = 'IterateIterator' annotation = '' 
              isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
              isDerived = 'false' >
              <Model:Namespace.contents>
                <Model:AssociationEnd xmi.id = 'a4759625303C8' 
                  name = 'iterators' annotation = '' 
                  isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'false' is_unique = 'true' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
                <Model:AssociationEnd xmi.id = 'a4759625303D8' 
                  name = 'iterate' annotation = '' 
                  isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a47595676008C'/>  <!-- dataaccess.expressions.collectionExpressions.Iterate -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
              </Model:Namespace.contents>
            </Model:Association>
            <!-- ==================== dataaccess.expressions.collectionExpressions.IterateAccumulator    [Association] ==================== -->
            <Model:Association xmi.id = 'a47596322030D' 
              name = 'IterateAccumulator' annotation = 'Conceptually, the accumulator is not a constant in the usual sense. It changes its value with each iteration. However, syntactically, it shares all properties with a constant such as requiring an initialization expression and not being assignable otherwise.' 
              isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
              isDerived = 'false' >
              <Model:Namespace.contents>
                <Model:AssociationEnd xmi.id = 'a475963230109' 
                  name = 'accumulator' annotation = '' 
                  isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A717EE033C'/>
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
                <Model:AssociationEnd xmi.id = 'a475963230119' 
                  name = 'iterate' annotation = '' 
                  isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a47595676008C'/>  <!-- dataaccess.expressions.collectionExpressions.Iterate -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
              </Model:Namespace.contents>
            </Model:Association>
            <!-- ==================== dataaccess.expressions.collectionExpressions.A_iteratorExpression_inIterator    [Association] ==================== -->
            <Model:Association xmi.id = 'a47596342006D' 
              name = 'A_iteratorExpression_inIterator' annotation = '' 
              isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
              isDerived = 'false' >
              <Model:Namespace.contents>
                <Model:AssociationEnd xmi.id = 'a475963450186' 
                  name = 'iteratorExpression' annotation = '' 
                  isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
                <Model:AssociationEnd xmi.id = 'a475963450196' 
                  name = 'inIterator' annotation = '' 
                  isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a47595676008C'/>  <!-- dataaccess.expressions.collectionExpressions.Iterate -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
              </Model:Namespace.contents>
            </Model:Association>
          </Model:Namespace.contents>
        </Model:Package>
        <!-- ==================== dataaccess.expressions.fp    [Package] ==================== -->
        <Model:Package xmi.id = 'a47A0755F0195' 
          name = 'fp' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' >
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.fp.AnonymousFunctionExpr    [Class] ==================== -->
            <Model:Class xmi.id = 'a47A0757E02EC' 
              name = 'AnonymousFunctionExpr' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.annotation>The type of expression of this type is a FunctionSignatureTypeDefinition. The value of this expression can be invoked which results in an invocation of the assoicated block.

The expression must own a FunctionSignatureTypeDefinition in the role ownedTypeDefinition that has a valid implementation for its FunctionSignature.

Note that there can be other expressions that evaluate to a function, such as an access to a variable that has a FunctionSignatureTypeDefinition as its type. AnonymousFunctionExpr really is the constructor for a function with implementation. This expression may then, e.g., be bound to variables or passed as parameter or returned by a method or function.</Model:ModelElement.annotation>
              <Model:ModelElement.constraints>
                <Model:Constraint xmi.idref = 'a47D67B7D03C2'/>  <!-- dataaccess.expressions.fp.AnonymousFunctionExpr.TypeMustBeSignatureTypeDefinitionWithImplementation -->
                <Model:Constraint xmi.idref = 'a47D68B1D0094'/>  <!-- dataaccess.expressions.fp.AnonymousFunctionExpr.HasToOwnSignatureTypeDefinition -->
                <Model:Constraint xmi.idref = 'a48A038A2002E'/>  <!-- dataaccess.expressions.fp.AnonymousFunctionExpr.SignatureMustBeFunctionSignature -->
              </Model:ModelElement.constraints>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:GeneralizableElement.supertypes>
              <Model:Namespace.contents>
                <!-- ==================== dataaccess.expressions.fp.AnonymousFunctionExpr.getImplementation    [Operation] ==================== -->
                <Model:Operation xmi.id = 'a47FF305F00CB' 
                  name = 'getImplementation' annotation = 'Determines the Block implementing the function to which this expression evaluates by navigating to the FunctionSignatureTypeDefinition that tells this expression&apos;s type, and from there obtaining the signature&apos;s implementation.' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isQuery = 'true' >
                  <Model:Namespace.contents>
                    <Model:Parameter xmi.id = 'XX.99' 
                      name = '*return' annotation = '' 
                      direction = 'return_dir' >
                      <Model:Parameter.multiplicity>
                        <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                      </Model:Parameter.multiplicity>
                      <Model:TypedElement.type>
                        <Model:Classifier xml:link = 'simple' href = 'data.xml|a4974995A0069'/>
                      </Model:TypedElement.type>
                    </Model:Parameter>
                  </Model:Namespace.contents>
                </Model:Operation>
                <!-- ==================== dataaccess.expressions.fp.AnonymousFunctionExpr.TypeMustBeSignatureTypeDefinitionWithImplementation    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a47D67B7D03C2' 
                  name = 'TypeMustBeSignatureTypeDefinitionWithImplementation' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context AnonymousFunctionExpr
inv:
  self.getType().oclIsKindOf(FunctionSignatureTypeDefinition) and
  self.getType().oclAsType(FunctionSignatureTypeDefinition).signature.oclAsType(FunctionSignature).implementation-&gt;notEmpty()</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a47A0757E02EC'/>  <!-- dataaccess.expressions.fp.AnonymousFunctionExpr -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
                <!-- ==================== dataaccess.expressions.fp.AnonymousFunctionExpr.HasToOwnSignatureTypeDefinition    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a47D68B1D0094' 
                  name = 'HasToOwnSignatureTypeDefinition' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context AnonymousFunctionExpr
inv:
  self.ownedTypeDefinition-&gt;notEmpty()</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a47A0757E02EC'/>  <!-- dataaccess.expressions.fp.AnonymousFunctionExpr -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
                <!-- ==================== dataaccess.expressions.fp.AnonymousFunctionExpr.SignatureMustBeFunctionSignature    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a48A038A2002E' 
                  name = 'SignatureMustBeFunctionSignature' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context AnonymousFunctionExpr
inv:
  self.ownedTypeDefinition.oclAsType(FunctionSignatureTypeDefinition).signature.oclIsKindOf(FunctionSignature)</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a47A0757E02EC'/>  <!-- dataaccess.expressions.fp.AnonymousFunctionExpr -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
              </Model:Namespace.contents>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.fp.org.omg.sap2mof.OperationCodeOcl=context AnonymousFunctionExpr::getImplementation():FunctionSignatureImplementation...    [Tag] ==================== -->
            <Model:Tag xmi.id = 'G.864' 
              name = 'org.omg.sap2mof.OperationCodeOcl=context AnonymousFunctionExpr::getImplementation():FunctionSignatureImplementation...' annotation = '' 
              tagId = 'org.omg.sap2mof.OperationCodeOcl' >
              <Model:Tag.values>
                <XMI.any xmi.type = 'string' xmi.name = ''>context AnonymousFunctionExpr::getImplementation():FunctionSignatureImplementation
body:
  self.ownedTypeDefinition.oclAsType(FunctionSignatureTypeDefinition).signature.oclAsType(FunctionSignature).implementation</XMI.any>
              </Model:Tag.values>
              <Model:Tag.elements>
                <Model:ModelElement xmi.idref = 'a47FF305F00CB'/>  <!-- dataaccess.expressions.fp.AnonymousFunctionExpr.getImplementation -->
              </Model:Tag.elements>
            </Model:Tag>
            <!-- ==================== dataaccess.expressions.fp.FunctionFromMethodExpr    [Class] ==================== -->
            <Model:Class xmi.id = 'a487F6B6D0177' 
              name = 'FunctionFromMethodExpr' annotation = 'The getType() implementation for this expression type could infer the function type definition from the method signature. However, this would require constructing such a value from within OCL.' 
              isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
              isSingleton = 'false' >
              <Model:ModelElement.constraints>
                <Model:Constraint xmi.idref = 'a4880917802CE'/>  <!-- dataaccess.expressions.fp.FunctionFromMethodExpr.SignatureAvailableOnObjectsClass -->
                <Model:Constraint xmi.idref = 'a4880946302CE'/>  <!-- dataaccess.expressions.fp.FunctionFromMethodExpr.MethodSignatureConformsToFunctionSignature -->
              </Model:ModelElement.constraints>
              <Model:GeneralizableElement.supertypes>
                <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
              </Model:GeneralizableElement.supertypes>
              <Model:Namespace.contents>
                <!-- ==================== dataaccess.expressions.fp.FunctionFromMethodExpr.method    [Reference] ==================== -->
                <Model:Reference xmi.id = 'ra488086DD0167' 
                  name = 'method' annotation = '' 
                  scope = 'instance_level' visibility = 'public_vis' 
                  isChangeable = 'true' >
                  <Model:StructuralFeature.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:StructuralFeature.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D15030D'/>
                  </Model:TypedElement.type>
                  <Model:Reference.referencedEnd>
                    <Model:AssociationEnd xmi.idref = 'a488086DD0167'/>
                  </Model:Reference.referencedEnd>
                </Model:Reference>
                <!-- ==================== dataaccess.expressions.fp.FunctionFromMethodExpr.SignatureAvailableOnObjectsClass    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a4880917802CE' 
                  name = 'SignatureAvailableOnObjectsClass' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context FunctionFromMethodExpr
inv:
  self.object.getType().oclIsKindOf(ClassTypeDefinition) and
  self.object.getType().oclAsType(ClassTypeDefinition).clazz.conformsTo(self.method.owner.oclAsType(SapClass))</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a487F6B6D0177'/>  <!-- dataaccess.expressions.fp.FunctionFromMethodExpr -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
                <!-- ==================== dataaccess.expressions.fp.FunctionFromMethodExpr.MethodSignatureConformsToFunctionSignature    [Constraint] ==================== -->
                <Model:Constraint xmi.id = 'a4880946302CE' 
                  name = 'MethodSignatureConformsToFunctionSignature' annotation = '' 
                  language = 'OCL' evaluationPolicy = 'deferred' >
                  <Model:Constraint.expression>
                    <XMI.any xmi.type = 'string' xmi.name = ''>context FunctionFromMethodExpr
inv:
    self.getType().oclIsKindOf(FunctionSignatureTypeDefinition) and
    self.method.conformsTo(self.getType().oclAsType(FunctionSignatureTypeDefinition).signature)</XMI.any>
                  </Model:Constraint.expression>
                  <Model:Constraint.constrainedElements>
                    <Model:ModelElement xmi.idref = 'a487F6B6D0177'/>  <!-- dataaccess.expressions.fp.FunctionFromMethodExpr -->
                  </Model:Constraint.constrainedElements>
                </Model:Constraint>
              </Model:Namespace.contents>
            </Model:Class>
            <!-- ==================== dataaccess.expressions.fp.A_method_functionFromMethodExpr    [Association] ==================== -->
            <Model:Association xmi.id = 'a488086DC003E' 
              name = 'A_method_functionFromMethodExpr' annotation = '' 
              isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
              isDerived = 'false' >
              <Model:Namespace.contents>
                <Model:AssociationEnd xmi.id = 'a488086DD0167' 
                  name = 'method' annotation = '' 
                  isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D15030D'/>
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
                <Model:AssociationEnd xmi.id = 'a488086DD0186' 
                  name = 'functionFromMethodExpr' annotation = '' 
                  isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
                  <Model:AssociationEnd.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
                  </Model:AssociationEnd.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a487F6B6D0177'/>  <!-- dataaccess.expressions.fp.FunctionFromMethodExpr -->
                  </Model:TypedElement.type>
                </Model:AssociationEnd>
              </Model:Namespace.contents>
            </Model:Association>
          </Model:Namespace.contents>
        </Model:Package>
        <!-- ==================== dataaccess.expressions.Expression    [Class] ==================== -->
        <Model:Class xmi.id = 'a450E63AB03A2' 
          name = 'Expression' annotation = 'An expression that evaluates to an object.' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xml:link = 'simple' href = 'data.xml|a4717B7BC031A'/>
            <Model:GeneralizableElement xml:link = 'simple' href = 'data.xml|a4B85514B0119'/>
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.Expression.isSideEffectFree    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a489D64AF0399' 
              name = 'isSideEffectFree' annotation = 'Tells if this expression is side effect-free. An expression has a side effect if it invokes a method or a function that is not described as side effect-free. It is important to note that this has to be checked recursively for nested expressions.' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.100' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'PrimitiveTypes.xml|a39A2BDA60392'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.expressions.Expression.evaluatesToEqualAs    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a49C0CF0601F4' 
              name = 'evaluatesToEqualAs' annotation = 'A conservative estimation that returns true if provably this and the passed expression will evaluate to equal objects. false means that the two expressions may evaluate to different results, not excluding that they can still have equal results; it&apos;s just not (yet) provable here.' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.101' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'PrimitiveTypes.xml|a39A2BDA60392'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
                <Model:Parameter xmi.id = 'XX.102' 
                  name = 'e' annotation = '' 
                  direction = 'in_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.expressions.Expression.getUsedAliases    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4B277D73000F' 
              name = 'getUsedAliases' annotation = 'Computes the Iterator objects that are defined by a FromClause of an OqlQuery and that are used in a VariableExpression somewhere inside this expression. Needs to handle all side effect-free expression types. By the current definition, this excludes, e.g., ObjectCreationExpression and therefore its initializers method call expressions.' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.103' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.expressions.Expression.getNamedValuesInScope    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4B83E38F033C' 
              name = 'getNamedValuesInScope' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.104' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a4522A56F0149'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.expressions.Expression.getOwningExpression    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4B83F58702BF' 
              name = 'getOwningExpression' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:ModelElement.annotation>If this expression is composed by another expression, determines the composing expression. Otherwise, an empty result is returned.

The issue with this operation is that each time a new inbound composite relatioship is added to Expression, this operation needs to be extended accordingly.</Model:ModelElement.annotation>
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.105' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.expressions.Expression.getOwningClass    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4B84EE28030D' 
              name = 'getOwningClass' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.106' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a4432171B031E'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.OperationCodeOcl=context Expression::isSideEffectFree():Boolean...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.865' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context Expression::isSideEffectFree():Boolean...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context Expression::isSideEffectFree():Boolean
body:
  let parametersAndSignatureAreSideEffectFree:Boolean =
    self.oclIsKindOf(SignatureCallExpression) implies
      (self.oclAsType(SignatureCallExpression).parameters-&gt;forAll(p|p.isSideEffectFree())
       and self.oclAsType(SignatureCallExpression).getSignature().sideEffectFree)
  in
  if self.oclIsKindOf(ObjectBasedExpression) then
    self.oclAsType(ObjectBasedExpression).object.isSideEffectFree() and
    if self.oclIsKindOf(SignatureCallExpression) then
      parametersAndSignatureAreSideEffectFree
    else
      if self.oclIsKindOf(Replace) then
        self.oclAsType(Replace).with.isSideEffectFree()
      else
        if self.oclIsKindOf(ExpressionWithArgument) and self.oclAsType(ExpressionWithArgument).argument-&gt;notEmpty() then
          self.oclAsType(ExpressionWithArgument).argument.isSideEffectFree()
        else
          true
        endif
      endif
    endif
  else if self.oclIsKindOf(FunctionCallExpression) then
    parametersAndSignatureAreSideEffectFree and self.oclAsType(FunctionCallExpression).calledBlock.isSideEffectFree()
  else if self.oclIsKindOf(Equals) then
    self.oclAsType(Equals).left.isSideEffectFree() and self.oclAsType(Equals).right.isSideEffectFree()
  else if self.oclIsKindOf(ObjectCreationExpression) then
    self.oclAsType(ObjectCreationExpression).classToInstantiate.valueType
  else if self.oclIsKindOf(DimensionExpression) then
    self.oclAsType(DimensionExpression).dimension.ownerSignature.sideEffectFree
  else if self.oclIsKindOf(Ternary) then
    self.oclAsType(Ternary).condition.isSideEffectFree() and
    self.oclAsType(Ternary).trueExpr.isSideEffectFree() and
    self.oclAsType(Ternary).falseExpr.isSideEffectFree()
  else if self.oclIsKindOf(CollectionExpression) then
    self.oclAsType(CollectionExpression).source.isSideEffectFree() and
    if self.oclIsKindOf(Iterate) then
      (self.oclAsType(Iterate).accumulator.initExpression-&gt;notEmpty() implies
         self.oclAsType(Iterate).accumulator.initExpression.isSideEffectFree()) and
      self.oclAsType(Iterate).iteratorExpression.isSideEffectFree()
    else
      true
    endif
  else if self.oclIsKindOf(ObjectLiteral) then
    self.oclAsType(ObjectLiteral).propertyValues.value-&gt;forAll(v|v.isSideEffectFree())
  else if self.oclIsKindOf(All) or self.oclIsKindOf(Replace) or self.oclIsKindOf(This) or self.oclIsKindOf(VariableExpression) or
  self.oclIsKindOf(Literal) or self.oclIsKindOf(AnonymousFunctionExpr) then
    true
  else if self.oclIsKindOf(Selection) then
    self.oclAsType(Selection).object.isSideEffectFree()
  else
    false
  endif
  endif
  endif
  endif
  endif
  endif
  endif
  endif
  endif
  endif</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a489D64AF0399'/>  <!-- dataaccess.expressions.Expression.isSideEffectFree -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.OperationCodeOcl=context Expression::evaluatesToEqualAs(e:Expression):Boolean...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.866' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context Expression::evaluatesToEqualAs(e:Expression):Boolean...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context Expression::evaluatesToEqualAs(e:Expression):Boolean
body:
  if self=e then
    true
  else
  if self.oclIsKindOf(NumberLiteral) and e.oclIsKindOf(NumberLiteral) then
    self.oclAsType(NumberLiteral).literal=e.oclAsType(NumberLiteral).literal
  else
    if self.oclIsKindOf(StringLiteral) and e.oclIsKindOf(StringLiteral) then
      self.oclAsType(StringLiteral).literal=e.oclAsType(StringLiteral).literal
    else
      if self.oclIsKindOf(ObjectLiteral) and e.oclIsKindOf(ObjectLiteral) then
        self.oclAsType(ObjectLiteral).isEqualTo(e.oclAsType(ObjectLiteral))
      else
        if self.oclIsKindOf(VariableExpression) and e.oclIsKindOf(VariableExpression) then
          self.oclAsType(VariableExpression).variable = e.oclAsType(VariableExpression).variable
        else
          false
        endif
      endif
    endif
  endif
  endif</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a49C0CF0601F4'/>  <!-- dataaccess.expressions.Expression.evaluatesToEqualAs -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.OperationCodeOcl=context Expression::getUsedAliases():Set(Iterator)...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.867' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context Expression::getUsedAliases():Set(Iterator)...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context Expression::getUsedAliases():Set(Iterator)
body:
  if self.oclIsKindOf(VariableExpression) then
    if self.oclAsType(VariableExpression).variable.oclIsKindOf(Iterator) then
      self.oclAsType(VariableExpression).variable.oclAsType(Iterator)-&gt;select(i | i.fromClause-&gt;notEmpty())-&gt;asSet()
    else
      Set{}
    endif
  else
    if self.oclIsKindOf(Replace) then
      self.oclAsType(Replace).object.getUsedAliases()-&gt;union(
      self.oclAsType(Replace).steps.filterFunction.getUsedAliases()-&gt;flatten()-&gt;asSet())-&gt;union(
      self.oclAsType(Replace).with.getUsedAliases())
    else
      if self.oclIsKindOf(Selection) then
        self.oclAsType(Selection).object.getUsedAliases()-&gt;union(
        self.oclAsType(Selection).selectionExpr.getUsedAliases())
      else
        if self.oclIsKindOf(ObjectBasedExpression) then
          let objectAliases = self.oclAsType(ObjectBasedExpression).object.getUsedAliases() in
          if self.oclIsKindOf(MethodCallExpression) then
            objectAliases-&gt;union(self.oclAsType(MethodCallExpression).parameters.getUsedAliases()-&gt;flatten()-&gt;asSet())
          else
            objectAliases
          endif
        else
          if self.oclIsKindOf(Equals) then
            self.oclAsType(Equals).left.getUsedAliases()-&gt;union(self.oclAsType(Equals).right.getUsedAliases())
          else
            if self.oclIsKindOf(FunctionCallExpression) then
              self.oclAsType(FunctionCallExpression).calledBlock.getUsedAliases()-&gt;union(
                           self.oclAsType(FunctionCallExpression).parameters.getUsedAliases()-&gt;flatten()-&gt;asSet())
            else
              if self.oclIsKindOf(Ternary) then
                let sat = self.oclAsType(Ternary) in
                sat.condition.getUsedAliases()-&gt;union(sat.trueExpr.getUsedAliases())-&gt;union(sat.falseExpr.getUsedAliases())
             else
                 if self.oclIsKindOf(CollectionExpressionWithArgument) then
                  self.oclAsType(CollectionExpressionWithArgument).argument.getUsedAliases()-&gt;union(
                  self.oclAsType(CollectionExpressionWithArgument).source.getUsedAliases())
                else
                  if self.oclIsKindOf(Iterate) then
                    self.oclAsType(Iterate).iteratorExpression.getUsedAliases()-&gt;union(
                    self.oclAsType(Iterate).accumulator.initExpression.getUsedAliases())-&gt;union(
                    self.oclAsType(Iterate).source.getUsedAliases())
                  else
                    if self.oclIsKindOf(OqlQuery) then
                      self.oclAsType(OqlQuery).fromClauses.fromExpression.getUsedAliases()-&gt;flatten()-&gt;asSet()-&gt;union(
                      self.oclAsType(OqlQuery).condition.getUsedAliases())
                    else
                      Set{}
                    endif
                  endif
                endif
              endif
            endif
          endif
        endif
      endif
    endif
  endif</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4B277D73000F'/>  <!-- dataaccess.expressions.Expression.getUsedAliases -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.OperationCodeOcl=context Expression::getNamedValuesInScope():Set(NamedValue)...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.868' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context Expression::getNamedValuesInScope():Set(NamedValue)...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context Expression::getNamedValuesInScope():Set(NamedValue)
body:
  self.addNamedValuesWithNewNames(

  -- First, collect those NamedValues defined immediately for this expression:
  -- an iterate's body expression sees the iterators and the accumulator
  let accumulator:Set(NamedValue)=self.inIterator.accumulator-&gt;asSet() in
  let iterators:Set(NamedValue)=self.inIterator.iterators-&gt;asSet() in
  -- an OQL "from" clause sees all aliases left of it
  let oqlAliases:Set(NamedValue)=(if self.fromClause-&gt;notEmpty() then
    let fromClauses = self.fromClause.fromClauseOfOqlQuery.fromClauses in
    let fcIndex = fromClauses-&gt;indexOf(self.fromClause) in
      Sequence{1..-1+fcIndex}-&gt;collect(i | fromClauses-&gt;at(i).alias)-&gt;asSet()
  else
    Set{}
  endif)-&gt;union(
  -- an OQL "where" clause sees all aliases defined by any of the OQL expression's "from" entries
  self.conditionOfOqlQuery.fromClauses.alias-&gt;asSet()) in
  -- a Selection defines an implicit iterator for its filter expression
  let selectionIterator:Set(NamedValue)=self.selection.iterator-&gt;asSet() in
  -- a GroupBy's mapExpression sees all dimension iterators and the groupedFacts iterator
  let groupByMapExpressionIterators:Set(NamedValue)=self.mapExpressionOfGroupBy.groupedFacts-&gt;asSet()-&gt;union(
                                                    self.mapExpressionOfGroupBy.dimensions.iterator-&gt;asSet()) in
  -- a GroupBy's dimension expression sees the facts iterator
  let groupByDimensionFactIterator:Set(NamedValue)=self.dimension.groupBy.fact-&gt;asSet() in

  accumulator-&gt;union(iterators)-&gt;union(oqlAliases)-&gt;union(selectionIterator)-&gt;union(groupByMapExpressionIterators)-&gt;
  union(groupByDimensionFactIterator),

  -- Then, add those defined by owning structures such as owning statements or owning expressions
  -- an expression that is used by an ExpressionStatement or as condition in a Conditional sees all named values that the statement sees
  if self.actualObjectParameter.owningClassTypeDefinition-&gt;notEmpty() then
    self.actualObjectParameter.owningClassTypeDefinition.getNamedValuesInScope()
  else
    if self.initExpressionFor.namedValueDeclaration-&gt;notEmpty() then
      self.initExpressionFor.namedValueDeclaration.getNamedValuesInScope()
    else
      if self.expressionStatement-&gt;notEmpty() then
        self.expressionStatement.getNamedValuesInScope()
      else
        if self.conditional-&gt;notEmpty() then
          if self.conditional.oclIsKindOf(ConditionalStatement) then
            self.conditional.oclAsType(ConditionalStatement).getNamedValuesInScope()
          else
            self.conditional.oclAsType(ConditionalExpression).getNamedValuesInScope()
          endif
        else
          if self.argumentOf-&gt;notEmpty() and self.argumentOf.oclIsKindOf(StatementWithArgument) then
            self.argumentOf.oclAsType(StatementWithArgument).getNamedValuesInScope()
          else
            -- add all variables in scope for owning expressions
            let oe = self.getOwningExpression() in
              if oe-&gt;isEmpty() then
                Set{}
              else
                oe.getNamedValuesInScope()
              endif
          endif
        endif
      endif
    endif
  endif
  )</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4B83E38F033C'/>  <!-- dataaccess.expressions.Expression.getNamedValuesInScope -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.OperationCodeOcl=context Expression::getOwningExpression():Expression...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.869' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context Expression::getOwningExpression():Expression...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context Expression::getOwningExpression():Expression
body:
  let objectBasedExpressions:Set(Expression)=self.objectBasedExpression-&gt;asSet() in
  let argumentsOf:Set(Expression)=self.argumentOf-&gt;select(ao | ao.oclIsKindOf(Expression)).oclAsType(ExpressionWithArgument)-&gt;asSet() in
  let equals:Set(Expression)=Set{}-&gt;union(self.leftOfEquals-&gt;asSet())-&gt;union(self.rightOfEquals-&gt;asSet()) in
  let blocksOfFunctionCallExpression:Set(Expression)=self.blockOfFunctionCallExpression-&gt;asSet() in
  let signatureCalls:Set(Expression)=self.usedAsArgumentInSignatureCall-&gt;asSet() in
  let creationExpression:Set(Expression)=if self.oclIsKindOf(MethodCallExpression) then
    self.oclAsType(MethodCallExpression).creationExpression-&gt;asSet()
  else
    Set{}
  endif in
  let ternary:Set(Expression)=self.trueOfTernary-&gt;asSet()-&gt;union(self.falseOfTernary-&gt;asSet()) in
  let conditional:Set(Expression)=if self.conditional-&gt;notEmpty() and self.conditional.oclIsKindOf(ConditionalExpression) then
    self.conditional.oclAsType(ConditionalExpression)-&gt;asSet()
  else
    Set{}
  endif in
  let replace:Set(Expression)=self.withOfReplace-&gt;asSet()-&gt;union(self.navigationStep.replace-&gt;asSet()) in
  let oqlQuery:Set(Expression)=self.conditionOfOqlQuery-&gt;asSet()-&gt;union(self.fromClause.fromClauseOfOqlQuery-&gt;asSet()) in
  let selection:Set(Expression)=self.selection-&gt;asSet() in
  let objectLiteral:Set(Expression)=self.valueInit.objectLiteral-&gt;asSet() in
  let iterator:Set(Expression)=self.inIterator-&gt;asSet() in
  let collectionExpression:Set(Expression)=self.collectionExpression-&gt;asSet() in
  let all:Set(Expression)=self.all-&gt;asSet() in
  let valueInitInObjectLiteral:Set(Expression)=self.valueInit.objectLiteral-&gt;asSet() in
  let dimensionExpression:Set(Expression)=self.cellSetOfDimensionExpression-&gt;asSet()-&gt;union(
                                                                   self.factsOfDimensionExpression-&gt;asSet()) in
  let groupByExpression:Set(Expression)=self.dimension.groupBy-&gt;asSet() in

  objectBasedExpressions-&gt;union(argumentsOf)-&gt;union(equals)-&gt;union(blocksOfFunctionCallExpression)-&gt;union(
  signatureCalls)-&gt;union(creationExpression)-&gt;union(ternary)-&gt;union(conditional)-&gt;union(replace)-&gt;union(
  oqlQuery)-&gt;union(selection)-&gt;union(objectLiteral)-&gt;union(iterator)-&gt;union(collectionExpression)-&gt;union(
  all)-&gt;union(valueInitInObjectLiteral)-&gt;union(dimensionExpression)-&gt;union(groupByExpression)-&gt;any(true)</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4B83F58702BF'/>  <!-- dataaccess.expressions.Expression.getOwningExpression -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.OperationCodeOcl=context Expression::getOwningClass():SapClass...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.870' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context Expression::getOwningClass():SapClass...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context Expression::getOwningClass():SapClass
body:
  let oe = self.getOwningExpression() in
  if oe-&gt;notEmpty() then
    oe.getOwningClass()
  else
    if self.expressionStatement-&gt;notEmpty() then
      self.expressionStatement.getOwningClass()
    else
      if self.conditional-&gt;notEmpty() and self.conditional.oclIsKindOf(Statement) then
        self.conditional.oclAsType(ConditionalStatement).getOwningClass()
      else
        null
      endif
    endif
  endif</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4B84EE28030D'/>  <!-- dataaccess.expressions.Expression.getOwningClass -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.VariableExpression    [Class] ==================== -->
        <Model:Class xmi.id = 'a4522AC6A022F' 
          name = 'VariableExpression' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>The variable referenced by this type of expression must be visible within the scope where this expression occurs.

TODO: How to determine the block containing this VariableExpression? This will be important to determine if the variable is visible.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4522AE490300'/>  <!-- dataaccess.expressions.VariableExpression.VariableExpressionType -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.VariableExpression.variable    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4522AE0E00C0' 
              name = 'variable' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a4522A56F0149'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4522AE0E00C0'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.VariableExpression.VariableExpressionType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4522AE490300' 
              name = 'VariableExpressionType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context VariableExpression
inv:
    self.getType().conformsTo(self.variable.getType())</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4522AC6A022F'/>  <!-- dataaccess.expressions.VariableExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.MethodCallExpression    [Class] ==================== -->
        <Model:Class xmi.id = 'a4522E05D00A8' 
          name = 'MethodCallExpression' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>The MethodCallExpression executes an implementation of the signature using the "parameters" expressions as arguments on the object evaluated by the "object" expression. For that, first the "object" expression is evaluated. the parameter expressions (if provided) are evaluated and then passed to the implementation.

The object expression must evaluate to a single value, i.e., a TypeDefinition with upperMultiplicity = 1.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4548A9B600A7'/>  <!-- dataaccess.expressions.MethodCallExpression.ObjectMustSupportOperation -->
            <Model:Constraint xmi.idref = 'a48A9EB710138'/>  <!-- dataaccess.expressions.MethodCallExpression.OutputMultiplicities -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
            <Model:GeneralizableElement xmi.idref = 'a47F3B80500BD'/>  <!-- dataaccess.expressions.SignatureCallExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.MethodCallExpression.methodSignature    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4939041D010B' 
              name = 'methodSignature' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D15030D'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4939041D010B'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.MethodCallExpression.creationExpression    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B1CF930036D' 
              name = 'creationExpression' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a454BA26C0254'/>  <!-- dataaccess.expressions.ObjectCreationExpression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B1CF930036D'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.MethodCallExpression.asynchronous    [Attribute] ==================== -->
            <Model:Attribute xmi.id = 'a4549FF6500B0' 
              name = 'asynchronous' annotation = 'An operation may be invoked asynchronously. If the operation returns a value, it is ignored, as are any exceptions raised by the operation. An OperationExpression with this attribute set to true has itself no type and therefore cannot reasonably be used in a side effect-free expression but only as a statement.' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' 
              isDerived = 'false' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'PrimitiveTypes.xml|a39A2BDA60392'/>
              </Model:TypedElement.type>
            </Model:Attribute>
            <!-- ==================== dataaccess.expressions.MethodCallExpression.ObjectMustSupportOperation    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4548A9B600A7' 
              name = 'ObjectMustSupportOperation' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context MethodCallExpression
inv:
  self.object.getType().getInnermost().oclIsKindOf(ClassTypeDefinition) and
  self.object.getType().getInnermost().oclAsType(ClassTypeDefinition).clazz.conformsTo(self.methodSignature.owner.oclAsType(SapClass))</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4522E05D00A8'/>  <!-- dataaccess.expressions.MethodCallExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.MethodCallExpression.OutputMultiplicities    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a48A9EB710138' 
              name = 'OutputMultiplicities' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context MethodCallExpression
inv:
  (self.object.getType().isMany() implies (self.getType().isMany() and not self.getType().unique)) and
  (self.object.getType().lowerMultiplicity = 0 implies (self.getType()-&gt;isEmpty() or self.getType().lowerMultiplicity = 0))</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4522E05D00A8'/>  <!-- dataaccess.expressions.MethodCallExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.store=no    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.871' 
          name = 'org.omg.sap2mof.store=no' annotation = '' 
          tagId = 'org.omg.sap2mof.store' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>no</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'ra4B1CF930036D'/>  <!-- dataaccess.expressions.MethodCallExpression.creationExpression -->
            <Model:ModelElement xmi.idref = 'ra499D404600CB'/>  <!-- dataaccess.expressions.Replace.steps -->
            <Model:ModelElement xmi.idref = 'a499D404600CB'/>
            <Model:ModelElement xmi.idref = 'a4B1CF930036D'/>
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.ObjectBasedExpression    [Class] ==================== -->
        <Model:Class xmi.id = 'a453E0FC80335' 
          name = 'ObjectBasedExpression' annotation = 'A specific type of expression that is evaluated in the context of a specific object. Another expression is used to determine this object. An example for such an expression would be association navigation, where the object where the navigation starts has to be specified by the "object" expression.' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.ObjectBasedExpression.object    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4536496701B4' 
              name = 'object' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4536496701B4'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.ObjectCreationExpression    [Class] ==================== -->
        <Model:Class xmi.id = 'a454BA26C0254' 
          name = 'ObjectCreationExpression' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a454BA2AC006C'/>  <!-- dataaccess.expressions.ObjectCreationExpression.CannotInstantiateAbstractClass -->
            <Model:Constraint xmi.idref = 'a4759551601E4'/>  <!-- dataaccess.expressions.ObjectCreationExpression.ExpressionType -->
            <Model:Constraint xmi.idref = 'a47862616005D'/>  <!-- dataaccess.expressions.ObjectCreationExpression.HasToOwnTypeDefinition -->
            <Model:Constraint xmi.idref = 'a4A08420603CA'/>  <!-- dataaccess.expressions.ObjectCreationExpression.CannotInstantiateValueClass -->
            <Model:Constraint xmi.idref = 'a4B1CF9F603B4'/>  <!-- dataaccess.expressions.ObjectCreationExpression.NoDuplicateInitializers -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.ObjectCreationExpression.classToInstantiate    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra454BA28C00A2' 
              name = 'classToInstantiate' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a4432171B031E'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a454BA28C00A2'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.ObjectCreationExpression.initializers    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B1CF930036B' 
              name = 'initializers' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4522E05D00A8'/>  <!-- dataaccess.expressions.MethodCallExpression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B1CF930036B'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.ObjectCreationExpression.CannotInstantiateAbstractClass    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a454BA2AC006C' 
              name = 'CannotInstantiateAbstractClass' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectCreationExpression
inv:
    not self.classToInstantiate.isAbstract()</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a454BA26C0254'/>  <!-- dataaccess.expressions.ObjectCreationExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.ObjectCreationExpression.ExpressionType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4759551601E4' 
              name = 'ExpressionType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectCreationExpression
inv:
  self.getType().oclIsKindOf(ClassTypeDefinition) and
  self.getType().oclAsType(ClassTypeDefinition).clazz = self.classToInstantiate and
  self.getType().lowerMultiplicity = 1 and
  self.getType().upperMultiplicity = 1</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a454BA26C0254'/>  <!-- dataaccess.expressions.ObjectCreationExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.ObjectCreationExpression.HasToOwnTypeDefinition    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a47862616005D' 
              name = 'HasToOwnTypeDefinition' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectCreationExpression
inv:
  self.ownedTypeDefinition-&gt;notEmpty()</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a454BA26C0254'/>  <!-- dataaccess.expressions.ObjectCreationExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.ObjectCreationExpression.CannotInstantiateValueClass    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4A08420603CA' 
              name = 'CannotInstantiateValueClass' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectCreationExpression
inv:
    not self.classToInstantiate.valueType</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a454BA26C0254'/>  <!-- dataaccess.expressions.ObjectCreationExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.ObjectCreationExpression.NoDuplicateInitializers    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B1CF9F603B4' 
              name = 'NoDuplicateInitializers' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectCreationExpression
inv:
    self.initializers-&gt;forAll( a, b | a &lt;&gt; b implies a.methodSignature &lt;&gt; b.methodSignature )</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a454BA26C0254'/>  <!-- dataaccess.expressions.ObjectCreationExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.store=yes    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.872' 
          name = 'org.omg.sap2mof.store=yes' annotation = '' 
          tagId = 'org.omg.sap2mof.store' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>yes</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'ra4B1CF930036B'/>  <!-- dataaccess.expressions.ObjectCreationExpression.initializers -->
            <Model:ModelElement xmi.idref = 'ra499D404600CD'/>  <!-- dataaccess.expressions.NavigationStep.replace -->
            <Model:ModelElement xmi.idref = 'a499D404600CD'/>
            <Model:ModelElement xmi.idref = 'a4B1CF930036B'/>
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.FunctionCallExpression    [Class] ==================== -->
        <Model:Class xmi.id = 'a45473F620076' 
          name = 'FunctionCallExpression' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>An expression that is computed by first evaluating "calledBlock" and invoking the resulting block passing the "argument" expression. The value returned by the block constitutes the value of this expression. If the block terminates with a fault, the evaluation of this expression terminates with this fault.

The type of the object computed by the "parameters" expression must conform to the input parameter types of the signature called.

If the calledBock evaluates to more than one callable function, all functions will be called. Invocation ordering depends on the side effect-freeness of the signatures called.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4786256B0109'/>  <!-- dataaccess.expressions.FunctionCallExpression.ResultType -->
            <Model:Constraint xmi.idref = 'a4AD977480271'/>  <!-- dataaccess.expressions.FunctionCallExpression.CalledBlockMustBeFunction -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a47F3B80500BD'/>  <!-- dataaccess.expressions.SignatureCallExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.FunctionCallExpression.calledBlock    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra45473F6A0302' 
              name = 'calledBlock' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a45473F6A0302'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.FunctionCallExpression.ResultType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4786256B0109' 
              name = 'ResultType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context FunctionCallExpression
inv:
  let fstd:FunctionSignatureTypeDefinition = self.calledBlock.getType().getInnermost().oclAsType(FunctionSignatureTypeDefinition) in

  if fstd.isMany() then
    -- calling multiple functions; test is somewhat fuzzy because it doesn't test condormance of nesting structure exactly
    self.getType().isMany() and not self.getType().unique and
    fstd.signature.output.getInnermost().conformsTo(self.getType().getInnermost()) and
    (fstd.lowerMultiplicity = 0 implies (self.getType()-&gt;isEmpty() or self.getType().lowerMultiplicity = 0))
  else
    -- calling a single function
    fstd.signature.output.conformsTo(self.getType()) and 
    (fstd.lowerMultiplicity = 0 implies (self.getType()-&gt;isEmpty() or self.getType().lowerMultiplicity = 0))
  endif

</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a45473F620076'/>  <!-- dataaccess.expressions.FunctionCallExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.FunctionCallExpression.CalledBlockMustBeFunction    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4AD977480271' 
              name = 'CalledBlockMustBeFunction' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context FunctionCallExpression
inv:
  self.calledBlock.getType().getInnermost().oclIsKindOf(FunctionSignatureTypeDefinition)</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a45473F620076'/>  <!-- dataaccess.expressions.FunctionCallExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.WithArgument    [Class] ==================== -->
        <Model:Class xmi.id = 'a4577E587019C' 
          name = 'WithArgument' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.WithArgument.argument    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4577E58D025A' 
              name = 'argument' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4577E58D025A'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.This    [Class] ==================== -->
        <Model:Class xmi.id = 'a45A9433E03D2' 
          name = 'This' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>Statically, the This expression has the type that owns its occurrence. This means, in order to determine this, the getType implementation needs to ascend the composition hierarchy until it finds a Class somewhere. The problem, again, is that an OCL expression cannot manufacture the result required becauce currently TypeDefinition is still an "entity type," meaning a MOF class whose instances have ID and an explicit life cycle.

Therefore, currently This has to own its type definition, unfortunately.</Model:ModelElement.annotation>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.Equals    [Class] ==================== -->
        <Model:Class xmi.id = 'a475958230399' 
          name = 'Equals' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>compares two or more values/objects. Entity type instances are compared based on their identity. Value type instances are compared by their value. The type of an Equals expression is Boolean.

The getType() implementation can only infer the type once TypeDefinition is a value type, values of which can be constructed in an OCL expression.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4B06B6950157'/>  <!-- dataaccess.expressions.Equals.ConformaceOneWayOrAnother -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.Equals.left    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4759584402DE' 
              name = 'left' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4759584402DE'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.Equals.right    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra49765700006E' 
              name = 'right' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a49765700006E'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.Equals.ConformaceOneWayOrAnother    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B06B6950157' 
              name = 'ConformaceOneWayOrAnother' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Equals
inv:
  self.left.getType().conformsTo(self.right.getType()) or
  self.right.getType().conformsTo(self.left.getType())</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a475958230399'/>  <!-- dataaccess.expressions.Equals -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.AssociationEndNavigationExpression    [Class] ==================== -->
        <Model:Class xmi.id = 'a478620130157' 
          name = 'AssociationEndNavigationExpression' annotation = 'Navigates from the "object" across the "toEnd"&apos;s association to the "toEnd". The expression evaluates to the objects at the "toEnd" that are associated with the "object" based on the end&apos;s association.' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a478620BF032C'/>  <!-- dataaccess.expressions.AssociationEndNavigationExpression.ObjectTypeMustMatch -->
            <Model:Constraint xmi.idref = 'a478621470399'/>  <!-- dataaccess.expressions.AssociationEndNavigationExpression.ResultType -->
            <Model:Constraint xmi.idref = 'a4873524B034B'/>  <!-- dataaccess.expressions.AssociationEndNavigationExpression.EndMustBeNavigable -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.AssociationEndNavigationExpression.toEnd    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4786205E00AB' 
              name = 'toEnd' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a44EC55FB03B8'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4786205E00AB'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.AssociationEndNavigationExpression.ObjectTypeMustMatch    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a478620BF032C' 
              name = 'ObjectTypeMustMatch' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context AssociationEndNavigationExpression
inv:
  self.object.getType().conformsToIgnoringMultiplicity(self.toEnd.otherEnd().type)</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a478620130157'/>  <!-- dataaccess.expressions.AssociationEndNavigationExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.AssociationEndNavigationExpression.ResultType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a478621470399' 
              name = 'ResultType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context AssociationEndNavigationExpression
inv:
  self.getType() = self.toEnd.type</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a478620130157'/>  <!-- dataaccess.expressions.AssociationEndNavigationExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.AssociationEndNavigationExpression.EndMustBeNavigable    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4873524B034B' 
              name = 'EndMustBeNavigable' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context AssociationEndNavigationExpression
inv:
  self.toEnd.navigable</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a478620130157'/>  <!-- dataaccess.expressions.AssociationEndNavigationExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.SignatureCallExpression    [Class] ==================== -->
        <Model:Class xmi.id = 'a47F3B80500BD' 
          name = 'SignatureCallExpression' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a47F3BCCA0255'/>  <!-- dataaccess.expressions.SignatureCallExpression.ParametersTypesMustMatchSignatureParametersTypes -->
            <Model:Constraint xmi.idref = 'a48A9EA3E0213'/>  <!-- dataaccess.expressions.SignatureCallExpression.CallTypeMustMatchSignatureOutput -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.SignatureCallExpression.parameters    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra47F3B8AC0339' 
              name = 'parameters' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'true' is_unique = 'true' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a47F3B8AC0339'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.SignatureCallExpression.getSignature    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4939043400CB' 
              name = 'getSignature' annotation = 'For FunctionCallExpression, this retrieves the signature from the type of the calledBlock expression which is required to be a FunctionSignatureTypeDefinition. For MethodCallExpression, it obtains the signature by navigating to the methodSignature role.' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.107' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a4432198602CB'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.expressions.SignatureCallExpression.getMultiplicityOfCallTarget    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4AD4791F02AF' 
              name = 'getMultiplicityOfCallTarget' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.108' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a47554DA003A9'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.expressions.SignatureCallExpression.ParametersTypesMustMatchSignatureParametersTypes    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a47F3BCCA0255' 
              name = 'ParametersTypesMustMatchSignatureParametersTypes' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context SignatureCallExpression
inv:
  let numberOfMandatoryParameters =
    self.getSignature().input-&gt;select(p|p.defaultValue-&gt;isEmpty())-&gt;size()
  in
  self.parameters-&gt;size() &gt;= numberOfMandatoryParameters and
  self.parameters-&gt;size() &lt;= self.getSignature().input-&gt;size() and
  self.parameters-&gt;forAll(parameter |
    parameter.getType().conformsTo(self.getSignature().input-&gt;at(self.parameters-&gt;indexOf(parameter)).getType()) )</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a47F3B80500BD'/>  <!-- dataaccess.expressions.SignatureCallExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.SignatureCallExpression.CallTypeMustMatchSignatureOutput    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a48A9EA3E0213' 
              name = 'CallTypeMustMatchSignatureOutput' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context SignatureCallExpression
inv:
    if self.getSignature().output.oclIsUndefined() then
        self.getType().oclIsUndefined()
    else 
        if self.getMultiplicityOfCallTarget().isMany() and self.getSignature().output.isMany() then
            let ntd = self.getType().oclAsType(NestedTypeDefinition) in
                self.getType().oclIsKindOf(NestedTypeDefinition) and 
                ntd.unique = false and
                ntd.ordered = self.getMultiplicityOfCallTarget().ordered and
                ntd.lowerMultiplicity = self.getMultiplicityOfCallTarget().lowerMultiplicity and
                ntd.upperMultiplicity = self.getMultiplicityOfCallTarget().upperMultiplicity and
                self.getSignature().output.conformsTo(ntd.type)
        else
            let target = self.getMultiplicityOfCallTarget() in let output = self.getSignature().output in 
                ( output.isMany() implies self.getType().unique = output.unique ) and
                ( ( output.isMany() or target.isMany() ) implies ( self.getType().ordered = (output.ordered or target.ordered) ) ) and
                ( self.getType().lowerMultiplicity = (output.lowerMultiplicity * target.lowerMultiplicity)) and
                ( self.getType().upperMultiplicity = (if output.isMany() or target.isMany() then 
                                                        -1 
                                                    else 
                                                        output.upperMultiplicity * target.upperMultiplicity 
                                                    endif)) and
                self.getType().conformsToIgnoringMultiplicity(output)
        endif
    endif</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a47F3B80500BD'/>  <!-- dataaccess.expressions.SignatureCallExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.OperationCodeOcl=context SignatureCallExpression::getSignature():Signature...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.873' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context SignatureCallExpression::getSignature():Signature...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context SignatureCallExpression::getSignature():Signature
body:
  if self.oclIsKindOf(FunctionCallExpression) then
    self.oclAsType(FunctionCallExpression).calledBlock.getType().getInnermost().oclAsType(FunctionSignatureTypeDefinition).signature
  else
    self.oclAsType(MethodCallExpression).methodSignature
  endif
</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4939043400CB'/>  <!-- dataaccess.expressions.SignatureCallExpression.getSignature -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.org.omg.sap2mof.OperationCodeOcl=context SignatureCallExpression::getMultiplicityOfCallTarget():Multiplicity...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.874' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context SignatureCallExpression::getMultiplicityOfCallTarget():Multiplicity...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context SignatureCallExpression::getMultiplicityOfCallTarget():Multiplicity
body:
  if self.oclIsKindOf(FunctionCallExpression) then
      self.oclAsType(FunctionCallExpression).calledBlock.getType()
  else
      self.oclAsType(MethodCallExpression).object.getType()
  endif</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4AD4791F02AF'/>  <!-- dataaccess.expressions.SignatureCallExpression.getMultiplicityOfCallTarget -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.expressions.ObjectCount    [Class] ==================== -->
        <Model:Class xmi.id = 'a48E9DE8C030D' 
          name = 'ObjectCount' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>Computes the Number 1 for single objects, and the number of objects in a multi-valued object otherwise.

Type inference in getType() can be done once TypeDefinition is a value type that can be constructed in OCL.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a48E9DFA5007D'/>  <!-- dataaccess.expressions.ObjectCount.TypeIsNumber -->
            <Model:Constraint xmi.idref = 'a48E9DFB5035B'/>  <!-- dataaccess.expressions.ObjectCount.MultiplicityIsOne -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.ObjectCount.TypeIsNumber    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a48E9DFA5007D' 
              name = 'TypeIsNumber' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectCount
inv:
  self.getType().oclIsKindOf(ClassTypeDefinition) and
  self.getType().oclAsType(ClassTypeDefinition).clazz.name = 'Number'</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a48E9DE8C030D'/>  <!-- dataaccess.expressions.ObjectCount -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.ObjectCount.MultiplicityIsOne    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a48E9DFB5035B' 
              name = 'MultiplicityIsOne' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context ObjectCount
inv:
  self.getType().upperMultiplicity = 1 and
  self.getType().lowerMultiplicity = 1</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a48E9DE8C030D'/>  <!-- dataaccess.expressions.ObjectCount -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.Replace    [Class] ==================== -->
        <Model:Class xmi.id = 'a499C2988038A' 
          name = 'Replace' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>An abstract-syntactical convenience to construct a value from an existing one, replacing a component somewhere in the possibly deep structure that the value has.

The replacement always produces a value of the same type as the source value. It can provide a navigation path, following associations, staying withing values, with the last path component being allowed to end at an entity or a value class. Each path segment may add a constraint which makes sense specifically for multiplicities greater than one.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a499C2A90033C'/>  <!-- dataaccess.expressions.Replace.SourceObjectIsOfValueType -->
            <Model:Constraint xmi.idref = 'a499D6B0F0399'/>  <!-- dataaccess.expressions.Replace.WithTypeConformsToLastStepsType -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.Replace.steps    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra499D404600CB' 
              name = 'steps' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'true' is_unique = 'true' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a499D4031000F'/>  <!-- dataaccess.expressions.NavigationStep -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a499D404600CB'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.Replace.with    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra499D69C7029F' 
              name = 'with' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a499D69C7029F'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.Replace.SourceObjectIsOfValueType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a499C2A90033C' 
              name = 'SourceObjectIsOfValueType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Replace
inv:
  self.object.getType().oclIsKindOf(ClassTypeDefinition) and
  self.object.getType().oclAsType(ClassTypeDefinition).clazz.valueType</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a499C2988038A'/>  <!-- dataaccess.expressions.Replace -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.Replace.WithTypeConformsToLastStepsType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a499D6B0F0399' 
              name = 'WithTypeConformsToLastStepsType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Replace
inv:
  self.with.getType().conformsTo(self.steps-&gt;at(self.steps-&gt;size()).to.type)</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a499C2988038A'/>  <!-- dataaccess.expressions.Replace -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.NavigationStep    [Class] ==================== -->
        <Model:Class xmi.id = 'a499D4031000F' 
          name = 'NavigationStep' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a499D5D4403B9'/>  <!-- dataaccess.expressions.NavigationStep.FromEndAttachesToOutputOfPreviousStep -->
            <Model:Constraint xmi.idref = 'a499D8ECA002E'/>  <!-- dataaccess.expressions.NavigationStep.FilterFunctionExpressionHasFunctionType -->
            <Model:Constraint xmi.idref = 'a499E87D601C5'/>  <!-- dataaccess.expressions.NavigationStep.FromEndMustBeEqualityRelevant -->
          </Model:ModelElement.constraints>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.NavigationStep.replace    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra499D404600CD' 
              name = 'replace' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a499C2988038A'/>  <!-- dataaccess.expressions.Replace -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a499D404600CD'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.NavigationStep.to    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra499D416F01F4' 
              name = 'to' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a44EC55FB03B8'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a499D416F01F4'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.NavigationStep.filterFunction    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra499D5BB701A5' 
              name = 'filterFunction' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a499D5BB701A5'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.NavigationStep.FromEndAttachesToOutputOfPreviousStep    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a499D5D4403B9' 
              name = 'FromEndAttachesToOutputOfPreviousStep' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context NavigationStep
inv:
  let i = self.replace.steps-&gt;indexOf(self) in
  let t = if i=1 then self.replace.object.getType().oclAsType(ClassTypeDefinition) else self.replace.steps-&gt;at(-1 + i).to.type endif in

  self.to.otherEnd().type.clazz.conformsTo(t.clazz)</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a499D4031000F'/>  <!-- dataaccess.expressions.NavigationStep -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.NavigationStep.FilterFunctionExpressionHasFunctionType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a499D8ECA002E' 
              name = 'FilterFunctionExpressionHasFunctionType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context NavigationStep
inv:
  self.filterFunction-&gt;notEmpty() implies self.filterFunction.getType().oclIsKindOf(FunctionSignatureTypeDefinition)</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a499D4031000F'/>  <!-- dataaccess.expressions.NavigationStep -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.NavigationStep.FromEndMustBeEqualityRelevant    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a499E87D601C5' 
              name = 'FromEndMustBeEqualityRelevant' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context NavigationStep
inv:
  to.otherEnd().contributesToEquality</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a499D4031000F'/>  <!-- dataaccess.expressions.NavigationStep -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.Head    [Class] ==================== -->
        <Model:Class xmi.id = 'a49BFCF80001E' 
          name = 'Head' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a49BFD86F023A'/>  <!-- dataaccess.expressions.Head.IsOrdered -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.Head.IsOrdered    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a49BFD86F023A' 
              name = 'IsOrdered' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Head
inv:
  self.object.getType().ordered</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a49BFCF80001E'/>  <!-- dataaccess.expressions.Head -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.Tail    [Class] ==================== -->
        <Model:Class xmi.id = 'a49BFCF9E020B' 
          name = 'Tail' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a49BFD8380366'/>  <!-- dataaccess.expressions.Tail.IsOrdered -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.Tail.IsOrdered    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a49BFD8380366' 
              name = 'IsOrdered' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Tail
inv:
  self.object.getType().ordered</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a49BFCF9E020B'/>  <!-- dataaccess.expressions.Tail -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.AsList    [Class] ==================== -->
        <Model:Class xmi.id = 'a49BFD73E033E' 
          name = 'AsList' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
          </Model:GeneralizableElement.supertypes>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.Conditional    [Class] ==================== -->
        <Model:Class xmi.id = 'a45471B4401F7' 
          name = 'Conditional' annotation = 'Some statement depending on a Boolean expression' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a45471BB2005B'/>  <!-- dataaccess.expressions.Conditional.ConditionMustBeBoolean -->
          </Model:ModelElement.constraints>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.Conditional.condition    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra45471B930205' 
              name = 'condition' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a45471B930205'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.Conditional.ConditionMustBeBoolean    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a45471BB2005B' 
              name = 'ConditionMustBeBoolean' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Conditional
inv:
  self.condition.getType().upperMultiplicity = 1 and
  self.condition.getType().oclIsKindOf(ClassTypeDefinition) and
  self.condition.getType().oclAsType(ClassTypeDefinition).clazz.name = 'Boolean'</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a45471B4401F7'/>  <!-- dataaccess.expressions.Conditional -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.Ternary    [Class] ==================== -->
        <Model:Class xmi.id = 'a4A389707002E' 
          name = 'Ternary' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4A38997702EE'/>  <!-- dataaccess.expressions.Ternary.TrueAndFalseExprsConformToResultType -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
            <Model:GeneralizableElement xmi.idref = 'a4B8523C90167'/>  <!-- dataaccess.expressions.ConditionalExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.Ternary.falseExpr    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4A3897E7030D' 
              name = 'falseExpr' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4A3897E7030D'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.Ternary.trueExpr    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4A3897EA02EE' 
              name = 'trueExpr' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4A3897EA02EE'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.expressions.Ternary.TrueAndFalseExprsConformToResultType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4A38997702EE' 
              name = 'TrueAndFalseExprsConformToResultType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Ternary
inv:
  self.trueExpr.getType().conformsTo(self.getType()) or
  self.falseExpr.getType().conformsTo(self.getType())</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4A389707002E'/>  <!-- dataaccess.expressions.Ternary -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.ContentEquals    [Class] ==================== -->
        <Model:Class xmi.id = 'a4B06A82B0109' 
          name = 'ContentEquals' annotation = 'Compares two entity objects by the content of those associations marked as equality relevant for the entity.' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4B06A8560213'/>  <!-- dataaccess.expressions.ContentEquals.ContentEqualsOnlyForEntities -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a475958230399'/>  <!-- dataaccess.expressions.Equals -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.ContentEquals.ContentEqualsOnlyForEntities    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B06A8560213' 
              name = 'ContentEqualsOnlyForEntities' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context ContentEquals
inv:
  self.left.getType().getInnermost().oclIsKindOf(ClassTypeDefinition) and
  self.right.getType().getInnermost().oclIsKindOf(ClassTypeDefinition) and
  not self.left.getType().getInnermost().oclAsType(ClassTypeDefinition).clazz.valueType and
  not self.right.getType().getInnermost().oclAsType(ClassTypeDefinition).clazz.valueType</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B06A82B0109'/>  <!-- dataaccess.expressions.ContentEquals -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.ExpressionWithArgument    [Class] ==================== -->
        <Model:Class xmi.id = 'a4B8504AE03C8' 
          name = 'ExpressionWithArgument' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a4577E587019C'/>  <!-- dataaccess.expressions.WithArgument -->
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.ConditionalExpression    [Class] ==================== -->
        <Model:Class xmi.id = 'a4B8523C90167' 
          name = 'ConditionalExpression' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'true' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a45471B4401F7'/>  <!-- dataaccess.expressions.Conditional -->
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.Map    [Class] ==================== -->
        <Model:Class xmi.id = 'a4B8D1E5103B9' 
          name = 'Map' annotation = 'A map expression operates on a (multi-)object (therefore it is an ObjectBaseExpression) and subjects each element of this (multi-)object as argument to the function expected as argument (therefore, it is an ExpressionWithArgument). The single multiplicity of the object expression must conform to the single input argument of the function signature of the FunctionSignatureTypeDefinition defining the type of the argument.' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4B8D1F31002E'/>  <!-- dataaccess.expressions.Map.ObjectTypeMustConformToFunctionArgument -->
            <Model:Constraint xmi.idref = 'a4B8D1F720222'/>  <!-- dataaccess.expressions.Map.ArgumentMustBeSingleArgumentFunctionWithNonVoidOutput -->
            <Model:Constraint xmi.idref = 'a4B8D38680222'/>  <!-- dataaccess.expressions.Map.MapFunctionMustBeSideEffectFree -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a4B8504AE03C8'/>  <!-- dataaccess.expressions.ExpressionWithArgument -->
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.expressions.Map.ObjectTypeMustConformToFunctionArgument    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B8D1F31002E' 
              name = 'ObjectTypeMustConformToFunctionArgument' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Map
inv:
  let fstd = self.argument.getType() in
  let sig = fstd.oclAsType(FunctionSignatureTypeDefinition).signature in
  let t = self.object.getType() in
  let argT = sig.input-&gt;at(1).getType() in
  -- if multiplicities match including multiplicities, that's ok
  t.conformsTo(argT) or
  -- otherwise, pick single multiplicity from object and try again
  t.conformsToIgnoringMultiplicity(argT) or
  (t.oclIsKindOf(NestedTypeDefinition) and t.oclAsType(NestedTypeDefinition).type.conformsTo(argT))</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B8D1E5103B9'/>  <!-- dataaccess.expressions.Map -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.Map.ArgumentMustBeSingleArgumentFunctionWithNonVoidOutput    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B8D1F720222' 
              name = 'ArgumentMustBeSingleArgumentFunctionWithNonVoidOutput' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Map
inv:
  let fstd = self.argument.getType() in
  fstd.oclIsKindOf(FunctionSignatureTypeDefinition) and
  (let sig = fstd.oclAsType(FunctionSignatureTypeDefinition).signature in
  (sig.output-&gt;notEmpty() and
  sig.input-&gt;size() = 1))</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B8D1E5103B9'/>  <!-- dataaccess.expressions.Map -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.expressions.Map.MapFunctionMustBeSideEffectFree    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B8D38680222' 
              name = 'MapFunctionMustBeSideEffectFree' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Map
inv:
  self.argument.getType().oclAsType(FunctionSignatureTypeDefinition).signature.sideEffectFree</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B8D1E5103B9'/>  <!-- dataaccess.expressions.Map -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.expressions.A_variable_variableExpression    [Association] ==================== -->
        <Model:Association xmi.id = 'a4522AE0D02E6' 
          name = 'A_variable_variableExpression' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4522AE0E00C0' 
              name = 'variable' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a4522A56F0149'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4522AE0E00CB' 
              name = 'variableExpression' annotation = '' 
              isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4522AC6A022F'/>  <!-- dataaccess.expressions.VariableExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_object_objectBasedExpression    [Association] ==================== -->
        <Model:Association xmi.id = 'a453649650215' 
          name = 'A_object_objectBasedExpression' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4536496701B4' 
              name = 'object' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4536496701C8' 
              name = 'objectBasedExpression' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_classToInstantiate_objectCreationExpression    [Association] ==================== -->
        <Model:Association xmi.id = 'a454BA28B0154' 
          name = 'A_classToInstantiate_objectCreationExpression' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a454BA28C00A2' 
              name = 'classToInstantiate' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a4432171B031E'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a454BA28C0156' 
              name = 'objectCreationExpression' annotation = '' 
              isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a454BA26C0254'/>  <!-- dataaccess.expressions.ObjectCreationExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_argumentOf_argument    [Association] ==================== -->
        <Model:Association xmi.id = 'a4577E58D0258' 
          name = 'A_argumentOf_argument' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4577E58D0259' 
              name = 'argumentOf' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4577E587019C'/>  <!-- dataaccess.expressions.WithArgument -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4577E58D025A' 
              name = 'argument' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_calledBlock_blockOfFunctionCallExpression    [Association] ==================== -->
        <Model:Association xmi.id = 'a45473F690329' 
          name = 'A_calledBlock_blockOfFunctionCallExpression' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a45473F6A0302' 
              name = 'calledBlock' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a45473F6A0316' 
              name = 'blockOfFunctionCallExpression' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a45473F620076'/>  <!-- dataaccess.expressions.FunctionCallExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_left_leftOfEquals    [Association] ==================== -->
        <Model:Association xmi.id = 'a4759584301D4' 
          name = 'A_left_leftOfEquals' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4759584402DE' 
              name = 'left' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4759584402FD' 
              name = 'leftOfEquals' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a475958230399'/>  <!-- dataaccess.expressions.Equals -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_toEnd_associationEndNavigationExpression    [Association] ==================== -->
        <Model:Association xmi.id = 'a4786205D0261' 
          name = 'A_toEnd_associationEndNavigationExpression' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4786205E00AB' 
              name = 'toEnd' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a44EC55FB03B8'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4786205E00BB' 
              name = 'associationEndNavigationExpression' annotation = '' 
              isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a478620130157'/>  <!-- dataaccess.expressions.AssociationEndNavigationExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.SignatureCallParameters    [Association] ==================== -->
        <Model:Association xmi.id = 'a47F3B8AB019D' 
          name = 'SignatureCallParameters' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a47F3B8AC0339' 
              name = 'parameters' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'true' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a47F3B8AC036B' 
              name = 'usedAsArgumentInSignatureCall' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a47F3B80500BD'/>  <!-- dataaccess.expressions.SignatureCallExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.SignatureCallToSignature    [Association] ==================== -->
        <Model:Association xmi.id = 'a4939041D0109' 
          name = 'SignatureCallToSignature' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4939041D010A' 
              name = 'methodCallExpression' annotation = '' 
              isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4522E05D00A8'/>  <!-- dataaccess.expressions.MethodCallExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4939041D010B' 
              name = 'methodSignature' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D15030D'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_right_rightOfEquals    [Association] ==================== -->
        <Model:Association xmi.id = 'a497656FD0205' 
          name = 'A_right_rightOfEquals' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a49765700006E' 
              name = 'right' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a49765700009D' 
              name = 'rightOfEquals' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a475958230399'/>  <!-- dataaccess.expressions.Equals -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_steps_replace    [Association] ==================== -->
        <Model:Association xmi.id = 'a499D40450261' 
          name = 'A_steps_replace' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a499D404600CB' 
              name = 'steps' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'true' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a499D4031000F'/>  <!-- dataaccess.expressions.NavigationStep -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a499D404600CD' 
              name = 'replace' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a499C2988038A'/>  <!-- dataaccess.expressions.Replace -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_to_navigationStep    [Association] ==================== -->
        <Model:Association xmi.id = 'a499D416E03A9' 
          name = 'A_to_navigationStep' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:ModelElement.annotation>If the opposite assoication end to which the step navigates connects only to a class *conforming* to the output of the previous step, this implicitly means a type filtering: only those instances will pass whose type conforms to the class to which *to*'s other end connects.

For example, if an Address value class has a property of type Province, and there are classes ProvinceWithLanguage that conforms to Province and has a property *language*, a navigation step to the "language" end will eliminate all provinces whose type does not conform to ProvinceWithLanguage.</Model:ModelElement.annotation>
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a499D416F01F4' 
              name = 'to' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a44EC55FB03B8'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a499D416F0213' 
              name = 'navigationStep' annotation = '' 
              isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a499D4031000F'/>  <!-- dataaccess.expressions.NavigationStep -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_filterFunction_navigationStep    [Association] ==================== -->
        <Model:Association xmi.id = 'a499D5BB500FA' 
          name = 'A_filterFunction_navigationStep' annotation = 'If specified, the expression must evaluate to a function such that the association end&apos;s (to) type definition conforms to the function&apos;s single input argument&apos;s type definition and the output is a single Boolean object.' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a499D5BB701A5' 
              name = 'filterFunction' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a499D5BB70203' 
              name = 'navigationStep' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a499D4031000F'/>  <!-- dataaccess.expressions.NavigationStep -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_with_withOfReplace    [Association] ==================== -->
        <Model:Association xmi.id = 'a499D69C401C5' 
          name = 'A_with_withOfReplace' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a499D69C7029F' 
              name = 'with' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a499D69C702DE' 
              name = 'withOfReplace' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a499C2988038A'/>  <!-- dataaccess.expressions.Replace -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_falseExpr_falseOfTernary    [Association] ==================== -->
        <Model:Association xmi.id = 'a4A3897E603B9' 
          name = 'A_falseExpr_falseOfTernary' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4A3897E7030D' 
              name = 'falseExpr' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4A3897E7035B' 
              name = 'falseOfTernary' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4A389707002E'/>  <!-- dataaccess.expressions.Ternary -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_trueExpr_trueOfTernary    [Association] ==================== -->
        <Model:Association xmi.id = 'a4A3897E80280' 
          name = 'A_trueExpr_trueOfTernary' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4A3897EA02EE' 
              name = 'trueExpr' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4A3897EA034B' 
              name = 'trueOfTernary' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4A389707002E'/>  <!-- dataaccess.expressions.Ternary -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_condition_conditional    [Association] ==================== -->
        <Model:Association xmi.id = 'a45471B920394' 
          name = 'A_condition_conditional' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a45471B930205' 
              name = 'condition' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a45471B93020F' 
              name = 'conditional' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a45471B4401F7'/>  <!-- dataaccess.expressions.Conditional -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.expressions.A_initializers_creationExpression    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B1CF92F02A0' 
          name = 'A_initializers_creationExpression' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B1CF930036B' 
              name = 'initializers' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4522E05D00A8'/>  <!-- dataaccess.expressions.MethodCallExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B1CF930036D' 
              name = 'creationExpression' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a454BA26C0254'/>  <!-- dataaccess.expressions.ObjectCreationExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
      </Model:Namespace.contents>
    </Model:Package>
    <Model:Import xmi.id = 'G.859' 
      name = 'PrimitiveTypes' annotation = '' 
      visibility = 'public_vis' isClustered = 'false' >
      <Model:Import.importedNamespace>
        <Model:Namespace xml:link = 'simple' href = 'PrimitiveTypes.xml|a3B5389EE0204'/>
      </Model:Import.importedNamespace>
    </Model:Import>
    <Model:Import xmi.id = 'G.861' 
      name = 'data' annotation = '' 
      visibility = 'public_vis' isClustered = 'false' >
      <Model:Import.importedNamespace>
        <Model:Namespace xml:link = 'simple' href = 'data.xml|a453E0C08006D'/>
      </Model:Import.importedNamespace>
    </Model:Import>
    <Model:Import xmi.id = 'G.863' 
      name = 'behavioral' annotation = '' 
      visibility = 'public_vis' isClustered = 'false' >
      <Model:Import.importedNamespace>
        <Model:Namespace xml:link = 'simple' href = 'behavioral.xml|a446B1EEC006B'/>
      </Model:Import.importedNamespace>
    </Model:Import>
    <!-- ==================== dataaccess.query    [Package] ==================== -->
    <Model:Package xmi.id = 'a44D7528D0275' 
      name = 'query' 
      isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' >
      <Model:ModelElement.annotation>A query language (overlap with rules package?) based on the structural package (BO, BONodes, associations, attributes). The language is independent of the mapping to the persistence layer but can be mapped to efficient queries in the persistence layer for those BOs that have a declared persistence mapping. Look closely at FSI, its query and view builder and how they have structured their metadata.

Should this be a subset of the expression language?
Note the particular issues around *retrieval* (as opposed to just querying IDs) as mentioned by Maic Wintel. Modeling of aspects to retrieve by a query?

What about regular expressions?

TODO: Most queries by means of their projection (SELECT) clause will implicitly define a tuple type, and the value returned by the query is a multi-object of that tuple type. We need to think about what these types exactly are (currently we don't support tuple types). Are they classes that are implicitly defined by the query? Or does a class explicitly have to be defined whose associations then can assume the values of the individual columns? Can that class somehow be referenced otherwise? What happens when the result of a query is assigned to a variable that uses type inference? I would hope that the implicit result class of the query is used as the variable's type. But is there / should there also be explicit ways of referencing this type?</Model:ModelElement.annotation>
      <Model:Namespace.contents>
        <!-- ==================== dataaccess.query.Selection    [Class] ==================== -->
        <Model:Class xmi.id = 'a4ACC4F790222' 
          name = 'Selection' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>Filters the (multi-)object based on the "condition" predicate. The expression can assume an implicit iterator variable "self" to be in scope which holds a single element of the (multi-)object from which to select. self's basic type is the same as that of "object" but with single multiplicity.

The expression's type must be Boolean. If the expression evaluates to true, the single object is part of the resulting object, otherwise not.

The Selection expression's result type is the same as object's type.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4ACC5585000F'/>  <!-- dataaccess.query.Selection.ConditionMustBeSideEffectFree -->
            <Model:Constraint xmi.idref = 'a4ACC97CE016B'/>  <!-- dataaccess.query.Selection.ConditionMustBeBooleanOrNumeric -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.query.Selection.iterator    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4ACC52B70147' 
              name = 'iterator' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4ACC52B70147'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.query.Selection.selectionExpr    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4ACC97760213' 
              name = 'selectionExpr' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4ACC97760213'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.query.Selection.ConditionMustBeSideEffectFree    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4ACC5585000F' 
              name = 'ConditionMustBeSideEffectFree' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Selection
inv:
  self.selectionExpr.isSideEffectFree()</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4ACC4F790222'/>  <!-- dataaccess.query.Selection -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.query.Selection.ConditionMustBeBooleanOrNumeric    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4ACC97CE016B' 
              name = 'ConditionMustBeBooleanOrNumeric' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Selection
inv:
  self.selectionExpr.getType().oclIsKindOf(ClassTypeDefinition) and
 (
    (
      self.selectionExpr.getType().oclAsType(ClassTypeDefinition).clazz.name = 'Boolean' and
      self.selectionExpr.getType().upperMultiplicity = 1
    )
    or
    (
      self.selectionExpr.getType().oclAsType(ClassTypeDefinition).clazz.name = 'Number' 
      and 
      self.object.getType().ordered
    )
  )</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4ACC4F790222'/>  <!-- dataaccess.query.Selection -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.query.org.omg.sap2mof.store=no    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.875' 
          name = 'org.omg.sap2mof.store=no' annotation = '' 
          tagId = 'org.omg.sap2mof.store' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>no</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'ra4ACC52B70147'/>  <!-- dataaccess.query.Selection.iterator -->
            <Model:ModelElement xmi.idref = 'ra4B275626034B'/>  <!-- dataaccess.query.OqlQuery.condition -->
            <Model:ModelElement xmi.idref = 'ra4B275661031C'/>  <!-- dataaccess.query.OqlQuery.fromClauses -->
            <Model:ModelElement xmi.idref = 'ra4B2757550148'/>  <!-- dataaccess.query.FromClause.fromExpression -->
            <Model:ModelElement xmi.idref = 'ra4B2757AD033C'/>  <!-- dataaccess.query.FromClause.alias -->
            <Model:ModelElement xmi.idref = 'a4ACC52B70147'/>
            <Model:ModelElement xmi.idref = 'a4B275626034B'/>
            <Model:ModelElement xmi.idref = 'a4B275661031C'/>
            <Model:ModelElement xmi.idref = 'a4B2757550148'/>
            <Model:ModelElement xmi.idref = 'a4B2757AD033C'/>
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.query.OqlQuery    [Class] ==================== -->
        <Model:Class xmi.id = 'a4B2755FC01F4' 
          name = 'OqlQuery' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4B2758E502DE'/>  <!-- dataaccess.query.OqlQuery.ConditionMustBeBoolean -->
            <Model:Constraint xmi.idref = 'a4B2759490109'/>  <!-- dataaccess.query.OqlQuery.WhereClauseMustBeSideEffectFree -->
            <Model:Constraint xmi.idref = 'a4B2784AF030D'/>  <!-- dataaccess.query.OqlQuery.HasValueType -->
            <Model:Constraint xmi.idref = 'a4B27A2F403B9'/>  <!-- dataaccess.query.OqlQuery.SelectedIteratorsMustHaveClassTypeDefinitionAsType -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.query.OqlQuery.condition    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B275626034B' 
              name = 'condition' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B275626034B'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.query.OqlQuery.fromClauses    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B275661031C' 
              name = 'fromClauses' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'true' is_unique = 'true' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B275602036B'/>  <!-- dataaccess.query.FromClause -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B275661031C'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.query.OqlQuery.selected    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B2783A9032C' 
              name = 'selected' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B2783A9032C'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.query.OqlQuery.ConditionMustBeBoolean    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B2758E502DE' 
              name = 'ConditionMustBeBoolean' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context OqlQuery
inv:
  self.condition-&gt;notEmpty() implies
    (self.condition.getType().oclIsKindOf(ClassTypeDefinition) and
     self.condition.getType().oclAsType(ClassTypeDefinition).clazz.name='Boolean')</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B2755FC01F4'/>  <!-- dataaccess.query.OqlQuery -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.query.OqlQuery.WhereClauseMustBeSideEffectFree    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B2759490109' 
              name = 'WhereClauseMustBeSideEffectFree' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context OqlQuery
inv:
  self.condition-&gt;forAll(c | c.isSideEffectFree())</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B2755FC01F4'/>  <!-- dataaccess.query.OqlQuery -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.query.OqlQuery.HasValueType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B2784AF030D' 
              name = 'HasValueType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context OqlQuery
inv:
  self.getType().oclIsKindOf(ClassTypeDefinition) and self.getType().oclAsType(ClassTypeDefinition).clazz.valueType</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B2755FC01F4'/>  <!-- dataaccess.query.OqlQuery -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.query.OqlQuery.SelectedIteratorsMustHaveClassTypeDefinitionAsType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B27A2F403B9' 
              name = 'SelectedIteratorsMustHaveClassTypeDefinitionAsType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context OqlQuery
inv:
  self.selected-&gt;forAll(i | i.getType().oclIsKindOf(ClassTypeDefinition))</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B2755FC01F4'/>  <!-- dataaccess.query.OqlQuery -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.query.FromClause    [Class] ==================== -->
        <Model:Class xmi.id = 'a4B275602036B' 
          name = 'FromClause' annotation = '' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4B2758BD0186'/>  <!-- dataaccess.query.FromClause.FromClausesMustBeSideEffectFree -->
          </Model:ModelElement.constraints>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.query.FromClause.fromClauseOfOqlQuery    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B275661031E' 
              name = 'fromClauseOfOqlQuery' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B2755FC01F4'/>  <!-- dataaccess.query.OqlQuery -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B275661031E'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.query.FromClause.fromExpression    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B2757550148' 
              name = 'fromExpression' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B2757550148'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.query.FromClause.alias    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B2757AD033C' 
              name = 'alias' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B2757AD033C'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.query.FromClause.FromClausesMustBeSideEffectFree    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B2758BD0186' 
              name = 'FromClausesMustBeSideEffectFree' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context FromClause
inv:
  self.fromExpression.isSideEffectFree()</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B275602036B'/>  <!-- dataaccess.query.FromClause -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.query.org.omg.sap2mof.store=yes    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.876' 
          name = 'org.omg.sap2mof.store=yes' annotation = '' 
          tagId = 'org.omg.sap2mof.store' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>yes</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'ra4B275661031E'/>  <!-- dataaccess.query.FromClause.fromClauseOfOqlQuery -->
            <Model:ModelElement xmi.idref = 'a4ACC52B70149'/>
            <Model:ModelElement xmi.idref = 'a4B275626038A'/>
            <Model:ModelElement xmi.idref = 'a4B275661031E'/>
            <Model:ModelElement xmi.idref = 'a4B2757550186'/>
            <Model:ModelElement xmi.idref = 'a4B2757AD033E'/>
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.query.A_iterator_selection    [Association] ==================== -->
        <Model:Association xmi.id = 'a4ACC52B7004D' 
          name = 'A_iterator_selection' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4ACC52B70147' 
              name = 'iterator' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4ACC52B70149' 
              name = 'selection' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4ACC4F790222'/>  <!-- dataaccess.query.Selection -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.query.A_selectionExpr_selection    [Association] ==================== -->
        <Model:Association xmi.id = 'a4ACC97750261' 
          name = 'A_selectionExpr_selection' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4ACC97760213' 
              name = 'selectionExpr' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4ACC97760242' 
              name = 'selection' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4ACC4F790222'/>  <!-- dataaccess.query.Selection -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.query.A_condition_conditionOfOqlQuery    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B275624037A' 
          name = 'A_condition_conditionOfOqlQuery' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B275626034B' 
              name = 'condition' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B275626038A' 
              name = 'conditionOfOqlQuery' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B2755FC01F4'/>  <!-- dataaccess.query.OqlQuery -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.query.A_fromClauses_fromClauseOfOqlQuery    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B27566000EA' 
          name = 'A_fromClauses_fromClauseOfOqlQuery' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B275661031C' 
              name = 'fromClauses' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'true' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B275602036B'/>  <!-- dataaccess.query.FromClause -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B275661031E' 
              name = 'fromClauseOfOqlQuery' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B2755FC01F4'/>  <!-- dataaccess.query.OqlQuery -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.query.A_fromExpression_fromClause    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B2757530203' 
          name = 'A_fromExpression_fromClause' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B2757550148' 
              name = 'fromExpression' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B2757550186' 
              name = 'fromClause' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B275602036B'/>  <!-- dataaccess.query.FromClause -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.query.A_alias_fromClause    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B2757AD01B5' 
          name = 'A_alias_fromClause' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B2757AD033C' 
              name = 'alias' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B2757AD033E' 
              name = 'fromClause' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B275602036B'/>  <!-- dataaccess.query.FromClause -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.query.A_selected_oqlQuery    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B2783A7003E' 
          name = 'A_selected_oqlQuery' annotation = 'an implicit select will explicitly put all defined aliases into this association' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B2783A9032C' 
              name = 'selected' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B2783A9033C' 
              name = 'oqlQuery' annotation = '' 
              isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B2755FC01F4'/>  <!-- dataaccess.query.OqlQuery -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
      </Model:Namespace.contents>
    </Model:Package>
    <!-- ==================== dataaccess.analytics    [Package] ==================== -->
    <Model:Package xmi.id = 'a446B1F110187' 
      name = 'analytics' annotation = 'This is the home for the definitions of what InfoObjects, InfoCubes, extractors, queries and views are.' 
      isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' >
      <Model:Namespace.contents>
        <!-- ==================== dataaccess.analytics.Dimension    [Class] ==================== -->
        <Model:Class xmi.id = 'a4717B68901E2' 
          name = 'Dimension' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>Dimensions define characteristics of the elements in a cell set according to which they may be grouped. A dimension defines a block that receives a value from the cell set's domain (its "facts" expression) and that determines the characteristic for that value in this dimension.

For example, if a cell set's domain is the set of all SalesOrderItems, one dimension could be the Product, and therefore the product dimension's block would determine the product of the SalesOrderItem.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4717E22F0387'/>  <!-- dataaccess.analytics.Dimension.BlockSignatureMustMatch -->
            <Model:Constraint xmi.idref = 'a48EA1C710213'/>  <!-- dataaccess.analytics.Dimension.CharacteristicFunctionMustNotBeAbstract -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xml:link = 'simple' href = 'modelmanagement.xml|a45013C240030'/>
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.analytics.Dimension.cellSet    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4717D8CE0118' 
              name = 'cellSet' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4718603E0213'/>  <!-- dataaccess.analytics.CellSet -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4717D8CE0118'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.Dimension.characteristicFunction    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4717DDE30368' 
              name = 'characteristicFunction' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D190077'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4717DDE30368'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.Dimension.BlockSignatureMustMatch    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4717E22F0387' 
              name = 'BlockSignatureMustMatch' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Dimension
inv:
  self.characteristicFunction.input-&gt;size() = 1 and 
  self.cellSet.factsType.conformsToIgnoringMultiplicity(self.characteristicFunction.input-&gt;at(1).getType())
    -- Add the following again once we have NestedTypeDefinitions under control...
    -- and  self.characteristicFunction.input-&gt;at(1).getType().upperMultiplicity = 1
</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4717B68901E2'/>  <!-- dataaccess.analytics.Dimension -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.analytics.Dimension.CharacteristicFunctionMustNotBeAbstract    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a48EA1C710213' 
              name = 'CharacteristicFunctionMustNotBeAbstract' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context Dimension
inv:
  not self.characteristicFunction.isAbstract()</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4717B68901E2'/>  <!-- dataaccess.analytics.Dimension -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.analytics.CellSet    [Class] ==================== -->
        <Model:Class xmi.id = 'a4718603E0213' 
          name = 'CellSet' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>A cell set computes an aggregated view on a domain of values, aggregated according to the different values for the different dimensions, using the aggregation function defined by the cell set. The domain (fact base) type is specified by factsType.

It subclasses FunctionSignatureImplementation. The function signature that a CellSet implements takes as its first argument a value whose type conforms to factsType, furthermore one argument per dimension and returns the aggregated cell value for the coordinate specified by the parameters. Therefore, the aggregationFunction's output type must conform to the CellSet's function signature's output type.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a47187338009C'/>  <!-- dataaccess.analytics.CellSet.ValueFunctionSignatureMustMatch -->
            <Model:Constraint xmi.idref = 'a47187406009C'/>  <!-- dataaccess.analytics.CellSet.AggregationFunctionSignatureMustMatch -->
            <Model:Constraint xmi.idref = 'a48EA1CA100BB'/>  <!-- dataaccess.analytics.CellSet.AggregationFunctionMustNotBeAbstract -->
            <Model:Constraint xmi.idref = 'a48EA1CCC02CE'/>  <!-- dataaccess.analytics.CellSet.ValueFunctionMustNotBeAbstract -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xml:link = 'simple' href = 'data.xml|a4974995A0069'/>
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.analytics.CellSet.dimensions    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4717D8CE0116' 
              name = 'dimensions' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'true' is_unique = 'true' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4717B68901E2'/>  <!-- dataaccess.analytics.Dimension -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4717D8CE0116'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.CellSet.valueFunction    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4717E2CB0210' 
              name = 'valueFunction' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D190077'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4717E2CB0210'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.CellSet.aggregationFunction    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4718722602FD' 
              name = 'aggregationFunction' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D190077'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4718722602FD'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.CellSet.factsType    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4A37E21E022F' 
              name = 'factsType' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47B9A97A00CB'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4A37E21E022F'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.CellSet.keyFigureType    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4717E3CB02DC' 
              name = 'keyFigureType' annotation = 'Determines the type over which to aggregate. If no valueFunction is provided, this is the type of the cell set&apos;s elements. Otherwise, this is the type output by the valueFunction.' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.109' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a47B9A97A00CB'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.analytics.CellSet.cellType    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4718752302EE' 
              name = 'cellType' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.110' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'data.xml|a47B9A97A00CB'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.analytics.CellSet.localIsSideEffectFree    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4A377FAC02CE' 
              name = 'localIsSideEffectFree' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.111' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'PrimitiveTypes.xml|a39A2BDA60392'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.analytics.CellSet.ValueFunctionSignatureMustMatch    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a47187338009C' 
              name = 'ValueFunctionSignatureMustMatch' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context CellSet
inv:
  self.valueFunction-&gt;notEmpty() implies
    (self.valueFunction.input-&gt;size() = 1 and
     self.factsType.conformsToIgnoringMultiplicity(self.valueFunction.input-&gt;at(1).getType())
    -- Add the following again once we have NestedTypeDefinitions under control...
    -- and  self.valueFunction.input-&gt;at(1).getType().upperMultiplicity = 1
    )</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4718603E0213'/>  <!-- dataaccess.analytics.CellSet -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.analytics.CellSet.AggregationFunctionSignatureMustMatch    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a47187406009C' 
              name = 'AggregationFunctionSignatureMustMatch' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context CellSet
inv:
  self.aggregationFunction.input-&gt;size() = 1 and 
  self.keyFigureType().conformsTo(self.aggregationFunction.input-&gt;at(1).getType())</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4718603E0213'/>  <!-- dataaccess.analytics.CellSet -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.analytics.CellSet.AggregationFunctionMustNotBeAbstract    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a48EA1CA100BB' 
              name = 'AggregationFunctionMustNotBeAbstract' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context CellSet
inv:
  not self.aggregationFunction.isAbstract()</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4718603E0213'/>  <!-- dataaccess.analytics.CellSet -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.analytics.CellSet.ValueFunctionMustNotBeAbstract    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a48EA1CCC02CE' 
              name = 'ValueFunctionMustNotBeAbstract' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context CellSet
inv:
  self.valueFunction-&gt;forAll(vf | not vf.isAbstract())</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4718603E0213'/>  <!-- dataaccess.analytics.CellSet -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.analytics.org.omg.sap2mof.store=no    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.877' 
          name = 'org.omg.sap2mof.store=no' annotation = '' 
          tagId = 'org.omg.sap2mof.store' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>no</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'ra4717D8CE0116'/>  <!-- dataaccess.analytics.CellSet.dimensions -->
            <Model:ModelElement xmi.idref = 'a4717D8CE0116'/>
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.analytics.org.omg.sap2mof.OperationCodeOcl=context CellSet::keyFigureType():TypeDefinition...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.878' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context CellSet::keyFigureType():TypeDefinition...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context CellSet::keyFigureType():TypeDefinition
body:
  if self.valueFunction-&gt;isEmpty() then
    self.factsType
  else
    self.valueFunction.output
  endif</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4717E3CB02DC'/>  <!-- dataaccess.analytics.CellSet.keyFigureType -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.analytics.org.omg.sap2mof.OperationCodeOcl=context CellSet::cellType():TypeDefinition...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.879' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context CellSet::cellType():TypeDefinition...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context CellSet::cellType():TypeDefinition
body:
  self.aggregationFunction.output</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4718752302EE'/>  <!-- dataaccess.analytics.CellSet.cellType -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.analytics.org.omg.sap2mof.OperationCodeOcl=context CellSet::localIsSideEffectFree():Boolean...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.880' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context CellSet::localIsSideEffectFree():Boolean...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context CellSet::localIsSideEffectFree():Boolean
body:
  self.dimensions-&gt;forAll(d|d.characteristicFunction.sideEffectFree) and
  (self.valueFunction-&gt;notEmpty() implies self.valueFunction.sideEffectFree) and
  self.aggregationFunction.sideEffectFree</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4A377FAC02CE'/>  <!-- dataaccess.analytics.CellSet.localIsSideEffectFree -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.analytics.DimensionExpression    [Class] ==================== -->
        <Model:Class xmi.id = 'a4718AA7E0167' 
          name = 'DimensionExpression' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>For the given cell set, obtain all distinct characteristic values of the given dimension. For example, for a CellSet based on SalesOrderItem with one Dimension being Product, yield all products for which a SalesOrderItem exists in the CellSet.

The type of this DimensionExpression is Set&lt;self.dimension.type&gt;</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4A3A52A8002E'/>  <!-- dataaccess.analytics.DimensionExpression.FactsTypeConformsToFirstFunctionParameterType -->
            <Model:Constraint xmi.idref = 'a4A3A56810399'/>  <!-- dataaccess.analytics.DimensionExpression.CellSetExpressionMustHaveFunctionSignatureType -->
            <Model:Constraint xmi.idref = 'a4A3A56B40157'/>  <!-- dataaccess.analytics.DimensionExpression.DimensionParameterIsNotFirst -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.analytics.DimensionExpression.cellSet    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4718AACC0167' 
              name = 'cellSet' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4718AACC0167'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.DimensionExpression.dimension    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4718AB19002E' 
              name = 'dimension' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47F12A7E0062'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4718AB19002E'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.DimensionExpression.facts    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4A3A526302DE' 
              name = 'facts' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4A3A526302DE'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.DimensionExpression.FactsTypeConformsToFirstFunctionParameterType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4A3A52A8002E' 
              name = 'FactsTypeConformsToFirstFunctionParameterType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context DimensionExpression
inv:
  self.facts.getType().conformsTo(self.dimension.ownerSignature.input-&gt;at(1).getType())</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4718AA7E0167'/>  <!-- dataaccess.analytics.DimensionExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.analytics.DimensionExpression.CellSetExpressionMustHaveFunctionSignatureType    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4A3A56810399' 
              name = 'CellSetExpressionMustHaveFunctionSignatureType' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context DimensionExpression
inv:
  self.cellSet.getType().oclIsKindOf(FunctionSignatureTypeDefinition)</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4718AA7E0167'/>  <!-- dataaccess.analytics.DimensionExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.analytics.DimensionExpression.DimensionParameterIsNotFirst    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4A3A56B40157' 
              name = 'DimensionParameterIsNotFirst' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context DimensionExpression
inv:
  self.dimension.ownerSignature.input-&gt;indexOf(self.dimension) &gt; 1</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4718AA7E0167'/>  <!-- dataaccess.analytics.DimensionExpression -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.analytics.GroupBy    [Class] ==================== -->
        <Model:Class xmi.id = 'a4B8E7AA300CB' 
          name = 'GroupBy' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.annotation>Groups the "object" expression's evaluation result by assigning each of its objects to the "fact" iterator, then evaluating all dimensions' expressions. Those objects having equal dimension results for all dimensions are put into one group. If no mapExpression is provided, the collection of those groups is the result of the GroupBy expression.

If a mapExpression is provided, each group is assigned to the groupedFacts iterator, all dimension values for the respective group are assigned to their iterator and the mapExpression is evaluated with all these iterators in scope. The map expression's output type is raised in multiplicity by one "level". However, the GroupBy's type always has non-unique multiplicity.</Model:ModelElement.annotation>
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4B8E82EC0242'/>  <!-- dataaccess.analytics.GroupBy.GroupedFactsIteratorMustExistIfMapExpressionExists -->
            <Model:Constraint xmi.idref = 'a4B8E8AC4030D'/>  <!-- dataaccess.analytics.GroupBy.MapExpressionMustBeSideEffectFree -->
            <Model:Constraint xmi.idref = 'a4B8E8B480261'/>  <!-- dataaccess.analytics.GroupBy.GroupByIteratorsMustHaveDistinctNames -->
          </Model:ModelElement.constraints>
          <Model:GeneralizableElement.supertypes>
            <Model:GeneralizableElement xmi.idref = 'a453E0FC80335'/>  <!-- dataaccess.expressions.ObjectBasedExpression -->
          </Model:GeneralizableElement.supertypes>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.analytics.GroupBy.dimensions    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B8E7B60004E' 
              name = 'dimensions' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B8E7B4F007D'/>  <!-- dataaccess.analytics.DimensionDefinition -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B8E7B60004E'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.GroupBy.fact    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B8E7BFA01A5' 
              name = 'fact' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B8E7BFA01A5'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.GroupBy.mapExpression    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B8E809B01A5' 
              name = 'mapExpression' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B8E809B01A5'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.GroupBy.groupedFacts    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B8E81160138' 
              name = 'groupedFacts' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B8E81160138'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.GroupBy.GroupedFactsIteratorMustExistIfMapExpressionExists    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B8E82EC0242' 
              name = 'GroupedFactsIteratorMustExistIfMapExpressionExists' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context GroupBy
inv:
  self.mapExpression-&gt;notEmpty() implies self.groupedFacts-&gt;notEmpty()</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B8E7AA300CB'/>  <!-- dataaccess.analytics.GroupBy -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.analytics.GroupBy.MapExpressionMustBeSideEffectFree    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B8E8AC4030D' 
              name = 'MapExpressionMustBeSideEffectFree' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context GroupBy
inv:
  if self.mapExpression-&gt;notEmpty() then
    self.mapExpression.isSideEffectFree()
  else
    true
  endif</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B8E7AA300CB'/>  <!-- dataaccess.analytics.GroupBy -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
            <!-- ==================== dataaccess.analytics.GroupBy.GroupByIteratorsMustHaveDistinctNames    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B8E8B480261' 
              name = 'GroupByIteratorsMustHaveDistinctNames' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context GroupBy
inv:
  self.dimensions.iterator-&gt;asSet()-&gt;union(self.groupedFacts-&gt;asSet())-&gt;union(self.fact-&gt;asSet())-&gt;forAll(i, j | i&lt;&gt;j implies i.name&lt;&gt;j.name)</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B8E7AA300CB'/>  <!-- dataaccess.analytics.GroupBy -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.analytics.DimensionDefinition    [Class] ==================== -->
        <Model:Class xmi.id = 'a4B8E7B4F007D' 
          name = 'DimensionDefinition' annotation = 'A dimension definition is not named. It owns a named iterator that can be used by the mapExpression.' 
          isRoot = 'false' isLeaf = 'false' isAbstract = 'false' visibility = 'public_vis' 
          isSingleton = 'false' >
          <Model:ModelElement.constraints>
            <Model:Constraint xmi.idref = 'a4B8E8B0803A9'/>  <!-- dataaccess.analytics.DimensionDefinition.DimensionExpressionMustBeSideEffectFree -->
          </Model:ModelElement.constraints>
          <Model:Namespace.contents>
            <!-- ==================== dataaccess.analytics.DimensionDefinition.expression    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B8E7B8F02FD' 
              name = 'expression' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B8E7B8F02FD'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.DimensionDefinition.iterator    [Reference] ==================== -->
            <Model:Reference xmi.id = 'ra4B8E7C2D004E' 
              name = 'iterator' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isChangeable = 'true' >
              <Model:StructuralFeature.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:StructuralFeature.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
              <Model:Reference.referencedEnd>
                <Model:AssociationEnd xmi.idref = 'a4B8E7C2D004E'/>
              </Model:Reference.referencedEnd>
            </Model:Reference>
            <!-- ==================== dataaccess.analytics.DimensionDefinition.getName    [Operation] ==================== -->
            <Model:Operation xmi.id = 'a4B8E83A102CE' 
              name = 'getName' annotation = '' 
              scope = 'instance_level' visibility = 'public_vis' 
              isQuery = 'true' >
              <Model:Namespace.contents>
                <Model:Parameter xmi.id = 'XX.112' 
                  name = '*return' annotation = '' 
                  direction = 'return_dir' >
                  <Model:Parameter.multiplicity>
                    <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
                  </Model:Parameter.multiplicity>
                  <Model:TypedElement.type>
                    <Model:Classifier xml:link = 'simple' href = 'PrimitiveTypes.xml|a39A2BDA60394'/>
                  </Model:TypedElement.type>
                </Model:Parameter>
              </Model:Namespace.contents>
            </Model:Operation>
            <!-- ==================== dataaccess.analytics.DimensionDefinition.DimensionExpressionMustBeSideEffectFree    [Constraint] ==================== -->
            <Model:Constraint xmi.id = 'a4B8E8B0803A9' 
              name = 'DimensionExpressionMustBeSideEffectFree' annotation = '' 
              language = 'OCL' evaluationPolicy = 'deferred' >
              <Model:Constraint.expression>
                <XMI.any xmi.type = 'string' xmi.name = ''>context DimensionDefinition
inv:
  self.expression.isSideEffectFree()</XMI.any>
              </Model:Constraint.expression>
              <Model:Constraint.constrainedElements>
                <Model:ModelElement xmi.idref = 'a4B8E7B4F007D'/>  <!-- dataaccess.analytics.DimensionDefinition -->
              </Model:Constraint.constrainedElements>
            </Model:Constraint>
          </Model:Namespace.contents>
        </Model:Class>
        <!-- ==================== dataaccess.analytics.org.omg.sap2mof.OperationCodeOcl=context DimensionDefinition::getName():String...    [Tag] ==================== -->
        <Model:Tag xmi.id = 'G.881' 
          name = 'org.omg.sap2mof.OperationCodeOcl=context DimensionDefinition::getName():String...' annotation = '' 
          tagId = 'org.omg.sap2mof.OperationCodeOcl' >
          <Model:Tag.values>
            <XMI.any xmi.type = 'string' xmi.name = ''>context DimensionDefinition::getName():String
body:
  self.iterator.name</XMI.any>
          </Model:Tag.values>
          <Model:Tag.elements>
            <Model:ModelElement xmi.idref = 'a4B8E83A102CE'/>  <!-- dataaccess.analytics.DimensionDefinition.getName -->
          </Model:Tag.elements>
        </Model:Tag>
        <!-- ==================== dataaccess.analytics.A_dimensions_cellSet    [Association] ==================== -->
        <Model:Association xmi.id = 'a4717D8CD01F1' 
          name = 'A_dimensions_cellSet' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4717D8CE0116' 
              name = 'dimensions' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'true' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4717B68901E2'/>  <!-- dataaccess.analytics.Dimension -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4717D8CE0118' 
              name = 'cellSet' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4718603E0213'/>  <!-- dataaccess.analytics.CellSet -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_characteristicFunction_dimension    [Association] ==================== -->
        <Model:Association xmi.id = 'a4717DDE30107' 
          name = 'A_characteristicFunction_dimension' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:ModelElement.annotation>A dimension defines functionality that can be used to determine the value of that dimension for a particular cell's value. For example, if a cell contains a SalesOrder object, one dimension may determine the time when the order came in. Another dimension from the order who the customer was.

The block specified to determined this value has to have a signature whose input type is the type of the CellSet's cells, and whose output type equals the type of the dimension.</Model:ModelElement.annotation>
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4717DDE30368' 
              name = 'characteristicFunction' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D190077'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4717DDE30378' 
              name = 'dimension' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4717B68901E2'/>  <!-- dataaccess.analytics.Dimension -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_valueFunction_cellSetForValueFunction    [Association] ==================== -->
        <Model:Association xmi.id = 'a4717E2C60397' 
          name = 'A_valueFunction_cellSetForValueFunction' annotation = 'The function that is used to convert the cell set&apos;s domain values  (e.g., a SalesOrderItem object) into an aggregable value (e.g., the price of the SalesOrderItem). If not provided, the cell value is used itself, as if an identity function had been provided.' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4717E2CB0210' 
              name = 'valueFunction' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D190077'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4717E2CB0212' 
              name = 'cellSetForValueFunction' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4718603E0213'/>  <!-- dataaccess.analytics.CellSet -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_aggregationFunction_cellSetForAggregationFunction    [Association] ==================== -->
        <Model:Association xmi.id = 'a4718722400DA' 
          name = 'A_aggregationFunction_cellSetForAggregationFunction' annotation = 'Defines the function that the cell set uses to aggregate values with equal characteristics in all dimensions.' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4718722602FD' 
              name = 'aggregationFunction' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47D67D190077'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4718722602FF' 
              name = 'cellSetForAggregationFunction' annotation = '' 
              isNavigable = 'true' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4718603E0213'/>  <!-- dataaccess.analytics.CellSet -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_cellSet_cellSetOfDimensionExpression    [Association] ==================== -->
        <Model:Association xmi.id = 'a4718AAC90290' 
          name = 'A_cellSet_cellSetOfDimensionExpression' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4718AACC0167' 
              name = 'cellSet' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4718AACC0169' 
              name = 'cellSetOfDimensionExpression' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4718AA7E0167'/>  <!-- dataaccess.analytics.DimensionExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_dimension_dimensionExpression    [Association] ==================== -->
        <Model:Association xmi.id = 'a4718AB170222' 
          name = 'A_dimension_dimensionExpression' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4718AB19002E' 
              name = 'dimension' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47F12A7E0062'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4718AB190030' 
              name = 'dimensionExpression' annotation = '' 
              isNavigable = 'false' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4718AA7E0167'/>  <!-- dataaccess.analytics.DimensionExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_factsType_cellSet    [Association] ==================== -->
        <Model:Association xmi.id = 'a4A37E21E022E' 
          name = 'A_factsType_cellSet' annotation = 'The domain expression for a cell set is expected to deliver a collection of objects that form the base data over which the cell set aggregates.' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4A37E21E022F' 
              name = 'factsType' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'data.xml|a47B9A97A00CB'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4A37E21E0230' 
              name = 'cellSet' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4718603E0213'/>  <!-- dataaccess.analytics.CellSet -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_facts_factsOfDimensionExpression    [Association] ==================== -->
        <Model:Association xmi.id = 'a4A3A5263001F' 
          name = 'A_facts_factsOfDimensionExpression' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4A3A526302DE' 
              name = 'facts' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4A3A5263032C' 
              name = 'factsOfDimensionExpression' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4718AA7E0167'/>  <!-- dataaccess.analytics.DimensionExpression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_dimensions_groupBy    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B8E7B5F0251' 
          name = 'A_dimensions_groupBy' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B8E7B60004E' 
              name = 'dimensions' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '-1' is_ordered = 'false' is_unique = 'true' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B8E7B4F007D'/>  <!-- dataaccess.analytics.DimensionDefinition -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B8E7B600050' 
              name = 'groupBy' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B8E7AA300CB'/>  <!-- dataaccess.analytics.GroupBy -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_expression_dimension    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B8E7B8C01C5' 
          name = 'A_expression_dimension' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B8E7B8F02FD' 
              name = 'expression' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B8E7B8F034B' 
              name = 'dimension' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B8E7B4F007D'/>  <!-- dataaccess.analytics.DimensionDefinition -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_fact_factOfGroupBy    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B8E7BF9034B' 
          name = 'A_fact_factOfGroupBy' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B8E7BFA01A5' 
              name = 'fact' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B8E7BFA01B5' 
              name = 'factOfGroupBy' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B8E7AA300CB'/>  <!-- dataaccess.analytics.GroupBy -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_iterator_dimension    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B8E7C2C0251' 
          name = 'A_iterator_dimension' annotation = '' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B8E7C2D004E' 
              name = 'iterator' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '1' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B8E7C2D005D' 
              name = 'dimension' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B8E7B4F007D'/>  <!-- dataaccess.analytics.DimensionDefinition -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_mapExpression_mapExpressionOfGroupBy    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B8E80990000' 
          name = 'A_mapExpression_mapExpressionOfGroupBy' annotation = 'The mapExpression is optional. If provided, it has the groupedFacts iterator in scope, as well as all dimensions&apos; iterators.' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B8E809B01A5' 
              name = 'mapExpression' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a450E63AB03A2'/>  <!-- dataaccess.expressions.Expression -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B8E809B01E4' 
              name = 'mapExpressionOfGroupBy' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B8E7AA300CB'/>  <!-- dataaccess.analytics.GroupBy -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
        <!-- ==================== dataaccess.analytics.A_groupedFacts_groupedFactsOfGroupBy    [Association] ==================== -->
        <Model:Association xmi.id = 'a4B8E8115033C' 
          name = 'A_groupedFacts_groupedFactsOfGroupBy' annotation = 'The groupedFacts iterator exists if a mapExpression is provided and is in scope for the mapExpression. It represents the group of facts that all have the same values for all dimension expressions.' 
          isRoot = 'true' isLeaf = 'true' isAbstract = 'false' visibility = 'public_vis' 
          isDerived = 'false' >
          <Model:Namespace.contents>
            <Model:AssociationEnd xmi.id = 'a4B8E81160138' 
              name = 'groupedFacts' annotation = '' 
              isNavigable = 'true' aggregation = 'none' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xml:link = 'simple' href = 'behavioral.xml|a47A719D200EA'/>
              </Model:TypedElement.type>
            </Model:AssociationEnd>
            <Model:AssociationEnd xmi.id = 'a4B8E81160148' 
              name = 'groupedFactsOfGroupBy' annotation = '' 
              isNavigable = 'false' aggregation = 'composite' isChangeable = 'true' >
              <Model:AssociationEnd.multiplicity>
                <Model:MultiplicityType lower = '0' upper = '1' is_ordered = 'false' is_unique = 'false' />
              </Model:AssociationEnd.multiplicity>
              <Model:TypedElement.type>
                <Model:Classifier xmi.idref = 'a4B8E7AA300CB'/>  <!-- dataaccess.analytics.GroupBy -->
              </Model:TypedElement.type>
            </Model:AssociationEnd>
          </Model:Namespace.contents>
        </Model:Association>
      </Model:Namespace.contents>
    </Model:Package>
    <Model:Import xmi.id = 'G.882' 
      name = 'modelmanagement' annotation = '' 
      visibility = 'public_vis' isClustered = 'false' >
      <Model:Import.importedNamespace>
        <Model:Namespace xml:link = 'simple' href = 'modelmanagement.xml|a44D74C00013D'/>
      </Model:Import.importedNamespace>
    </Model:Import>
  </Model:Namespace.contents>
</Model:Package>
</XMI.content>
</XMI>
