package com.sap.ide.cts.parser.incremental;

import static com.sap.furcas.runtime.textblocks.modifcation.TbChangeUtil.addToBlockAt;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.ocl.ecore.opposites.OppositeEndFinder;

import com.sap.furcas.metamodel.FURCAS.TCS.ClassTemplate;
import com.sap.furcas.metamodel.FURCAS.TCS.Template;
import com.sap.furcas.metamodel.FURCAS.textblockdefinition.TextBlockDefinition;
import com.sap.furcas.metamodel.FURCAS.textblockdefinition.TextblockdefinitionFactory;
import com.sap.furcas.metamodel.FURCAS.textblockdefinition.TextblockdefinitionPackage;
import com.sap.furcas.metamodel.FURCAS.textblocks.AbstractToken;
import com.sap.furcas.metamodel.FURCAS.textblocks.TextBlock;
import com.sap.furcas.metamodel.FURCAS.textblocks.TextblocksFactory;
import com.sap.furcas.metamodel.FURCAS.textblocks.Version;
import com.sap.furcas.runtime.common.interfaces.IModelElementProxy;
import com.sap.furcas.runtime.parser.textblocks.ModelElementFromTextBlocksFactory;
import com.sap.furcas.runtime.parser.textblocks.TextBlockFactory;
import com.sap.furcas.runtime.parser.textblocks.observer.TextBlockProxy;
import com.sap.furcas.runtime.parser.textblocks.observer.TokenRelocationUtil;
import com.sap.furcas.runtime.tcs.TcsUtil;
import com.sap.furcas.runtime.textblocks.TbNavigationUtil;
import com.sap.furcas.runtime.textblocks.TbUtil;
import com.sap.ide.cts.parser.incremental.TextBlockReuseStrategy.ReuseType;
import com.sap.ide.cts.parser.incremental.TextBlockReuseStrategy.TbBean;

public class ReuseAwareTextBlockFactoryImpl implements TextBlockFactory {

	private final TextblocksFactory textblocksFactory;
	private final Map<Template, TextBlockDefinition> tbDefsMap = new HashMap<Template, TextBlockDefinition>();
	private TextBlockReuseStrategy reuseStrategy;
	private final ModelElementFromTextBlocksFactory modelElementFactory;
	private ReferenceHandler referenceHandler;
	private final OppositeEndFinder oppositeEndFinder;
	private final EStructuralFeature templateTypeRef;

	

	public ReuseAwareTextBlockFactoryImpl(TextblocksFactory textblocksPackage, 
		TextBlockReuseStrategy tbReuseStrategy, ModelElementFromTextBlocksFactory modelElementFactory,
		OppositeEndFinder oppositeEndFinder) {
		super();
		this.textblocksFactory = textblocksPackage;
		reuseStrategy = tbReuseStrategy;
		this.modelElementFactory = modelElementFactory;
		this.oppositeEndFinder = oppositeEndFinder;
		this.templateTypeRef = TextblockdefinitionPackage.eINSTANCE.getTextBlockDefinition_ParseRule();
	}

	@Override
	public TextBlock createBlock() {
		TextBlock textBlock = textblocksFactory.createTextBlock();
		// TODO: check versioning for incremental parsing and adapt
		// correspondingly here
		textBlock.setVersion(Version.CURRENT);
		textBlock.setOffsetRelative(true);
		textBlock.setComplete(true); // default
		textBlock.setOffset(0);
		return textBlock;
	}
	
	/**
	 * Method implemented for interface
	 * {@link ITextBlockCreator#createNewTextBlock(TextBlockProxy)}
	 */
	@Override
	public TextBlock createNewTextBlock(TextBlockProxy proxy, TextBlock parent) {
		// createModelElements(proxy);
		return instantiateBlockAndMoveTokens(proxy, parent);
	}
	
	/**
	 * Instantiates a new {@link TextBlock} for the {@link TextBlockProxy} while
	 * moving all tokens that were captured there into the new block.
	 * Furthermore it calls itself recursively to add new blocks for its
	 * subBlock Proxies.
	 * 
	 * @param newVersion
	 *            The Proxy to instatiate
	 * @param parent
	 *            The parent textblock
	 * @return the newly instantiated {@link TextBlock} for the given proxy.
	 */
	private TextBlock instantiateBlockAndMoveTokens(TextBlockProxy newVersion,
			TextBlock parent) {
		TextBlock tb = this.createBlock();
		TextBlockDefinition tbDef = getTbDef(newVersion.getTemplate());
		tb.setType(tbDef);
		tb.setSequenceElement(newVersion.getSequenceElement());
		tb.getParentAltChoices().addAll(newVersion.getAlternativeChoices());
		tb.getAdditionalTemplates().addAll(newVersion.getAdditionalTemplates());
		int endIndex = 0;
		for (Object subNode : newVersion.getSubNodes()) {
			if (subNode instanceof TextBlockProxy) {
				if (((TextBlockProxy) subNode).getSubNodes().size() > 0) {
					// do not create textBlocks for proxies that have no content
					// this may be the case for example with rules for elements
					// that have no correspondence in the concrete syntax and
					// have been generated by rules containing only property
					// inits.
				    TextBlock reuseCandidate = IncrementalParsingUtil.getOriginalVersion((TextBlockProxy) subNode, parent);
				    TbBean subBlock = reuseStrategy.reuseTextBlock(reuseCandidate, (TextBlockProxy) subNode);
				    if(subBlock.reuseType.equals(ReuseType.COMPLETE)) {
    				        AbstractToken firstToken = TbNavigationUtil.firstToken(subBlock.textBlock);
    				        TokenRelocationUtil.updateTextBlockLocationAfterRemoval(firstToken.getParent());
    				        TokenRelocationUtil.updateParentsAscendingAfterRemoval(firstToken.getParent());
    				        int lengthDiff = TbUtil.getAbsoluteOffset(subBlock.textBlock) -  TbUtil.getAbsoluteOffset(firstToken);
                                        subBlock.textBlock.setOffset(TbUtil.getAbsoluteOffset(firstToken));
                                        subBlock.textBlock.setOffsetRelative(false);
                                        subBlock.textBlock.setLength(subBlock.textBlock.getLength() + lengthDiff); 
                                        //the tb is moved to a new parent, therefore
                                        //all the feature that referred from the parent to this TB
                                        //needs to be unset
                                        referenceHandler.unsetFeature(parent, subBlock.textBlock);
                                        subBlock.textBlock.setParent(null);
				    }
				    addToBlockAt(tb, endIndex++, subBlock.textBlock);
				}
			} else if (subNode instanceof AbstractToken) {
				TokenRelocationUtil.relocateToken((AbstractToken) subNode,
						endIndex++, tb);
				reuseStrategy.notifyTokenReuse((AbstractToken) subNode);
			}
		}
		tb.getCorrespondingModelElements().addAll(
				modelElementFactory.createModelElementsFromTextBlock(newVersion));
		// Add all elements in the context to the textblock
		for (Object elementInContext : newVersion.getContextElements()) {
			if (elementInContext instanceof IModelElementProxy) {
				if (((IModelElementProxy) elementInContext).getRealObject() == null) {
					throw new IncrementalParsingException(
							"Element in context was not resolved: "
									+ elementInContext);
				}
				tb.getElementsInContext().add(
						(EObject) ((IModelElementProxy) elementInContext)
								.getRealObject());
			} else if (elementInContext instanceof EObject) {
				tb.getElementsInContext().add((EObject) elementInContext);
			}
		}
		// if the template has specified the addToContext property we need to
		// add the corresponding element
		// to the context
		if (newVersion.getTemplate() instanceof ClassTemplate) {
			if (((ClassTemplate) newVersion.getTemplate()).isIsAddToContext()) {
				// move up to the first parent textblock that has the context
				// property set
				TextBlock loopParent = parent;
				while (loopParent != null) {
					if (TcsUtil.isContext(loopParent.getType().getParseRule())) {
						loopParent.getElementsInContext().addAll(
								tb.getCorrespondingModelElements());
						break;
					}
					loopParent = loopParent.getParent();
				}
			}
		}
		return tb;
	}

	/**
	 * Get the {@link TextBlockDefinition} for the given template.
	 * 
	 * @param template
	 * @return
	 */
	@Override
	public TextBlockDefinition getTbDef(Template template) {
		TextBlockDefinition tbDef = tbDefsMap.get(template);
		if (tbDef == null && template != null) {
			// check if there was already a corresponding tbdef within the
			// mapping definition
			Collection<EObject> tbDefs = oppositeEndFinder.
				navigateOppositePropertyWithBackwardScope(templateTypeRef, template);
			if (!tbDefs.isEmpty()) {
				if (tbDefs.size() == 1) {
					tbDef = (TextBlockDefinition) tbDefs.iterator().next();
				} else {
					// TODO What to do if there is more than one?
					// for now this case seems strange, so throw an exception
					throw new IncrementalParsingException(
							"Cannot handle more than one TextBlocksDefinition per Template!");
				}
			} else {
				tbDef = initializeTextBlockDefinition(template);
			}
			tbDefsMap.put(template, tbDef);
		}
		return tbDef;
	}

	/**
	 * Initializes a new {@link TextBlockDefinition} for the given template TODO
	 * this should actually be done during creation of the mapping model.
	 * 
	 * @param template
	 * @return
	 */
	private TextBlockDefinition initializeTextBlockDefinition(Template template) {
		TextBlockDefinition tbDef = TextblockdefinitionFactory.eINSTANCE.createTextBlockDefinition();
		tbDef.setParseRule(template);
		((EObject) template).eResource().getContents().add(tbDef);
		return tbDef;
	}
	

	public void setTextBlocksReuseStrategy(
			TextBlockReuseStrategy textBlockReuseStrategyImpl) {
		reuseStrategy = textBlockReuseStrategyImpl;
	}

	public void setReferenceHandler(ReferenceHandler referenceHandler) {
		this.referenceHandler = referenceHandler;
	}
	
}
