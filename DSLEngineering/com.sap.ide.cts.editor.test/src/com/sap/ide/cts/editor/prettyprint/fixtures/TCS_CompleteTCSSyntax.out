syntax TCS{

  primitiveTemplate identifier for PrimitiveTypes::String default using NAME:value="unescapeString(%token%)";

  primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";

  primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";

  primitiveTemplate integerSymbol for PrimitiveTypes::Integer default using INT:value="Integer.valueOf(%token%)";

  primitiveTemplate floatSymbol for PrimitiveTypes::Double default using FLOAT:value="Double.valueOf(%token%)";

  template Model::Classifier referenceOnly
    :(isDefined(container)?container "::" name:name)
    ;
  template Model::Namespace abstract operatored(DBLCOLON);

  template Model::GeneralizableElement referenceOnly
    :name
    ;
  operatorTemplate Model::ModelElement(operators=opDlColon,source=container)referenceOnly
    :name
    ;
  template textblockdefinition::TextBlockDefinition
    :
    ;
  template TCS::ConcreteSyntax main context
    :"syntax" name (isDefined(k)?"(" "k" "=" "k" ")") "{" [templates (isDefined(keywords)?"keywords" "{" ["keywords"] "}") (isDefined(symbols)?"symbols" "{" ["symbols"] "}") operatorLists tokens (isDefined(lexer)?"lexer" "=" "lexer"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} ";")]{nbNL=2} "}"
    ;
  function reference(TCS::QualifiedNamedElement)
    :(isDefined(metaReference)?metaReference:"->" names{separator="::"})
    ;
  template TCS::Template abstract;

  template TCS::PrimitiveTemplate
    :"primitiveTemplate" templateName "for" $reference (isDefault?"default") "using" tokenName (orKeyword?"orKeyword") ":" "value" "=" "value"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} (isDefined(serializer)?"," "serializer" "=" "serializer"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";}) ";" textBlockDefinition{forcedUpper=1}
    ;
  template TCS::EnumerationTemplate context addToContext
    :"enumerationTemplate" $reference (automatic?"auto") (isDefined(mappings)?[":" [mappings{separator=","}]{startNL=false} ";"]:";") textBlockDefinition{forcedUpper=1}
    ;
  template TCS::EnumLiteralMapping
    :literal "=" element
    ;
  template TCS::ClassTemplate context addToContext
    :"template" $reference (isReferenceOnly?"referenceOnly":(isDefined(mode)?"#" mode) (isDefined(disambiguate)?"(" "disambiguate" "=" "disambiguate"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} ")") (isDefined(disambiguateV3)?"(" "disambiguateV3" "=" "disambiguateV3"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} ")") (isMulti?"multi") (isMain?"main") (isAbstract?(isDeep?"deep") "abstract") (isOperatored?"operatored" (isDefined(operatorList)?"(" operatorList{refersTo=name} ")")) (isContext?"context" (isDefined(contextTags)?contextTags)) (isAddToContext?"addToContext") (isNonPrimary?"nonPrimary") (isDefined(prefixSequence)?"prefix" [":" [prefixSequence]{startNL=false}])) (isDefined(templateSequence)?[":" [templateSequence]{startNL=false} ";"]:";") textBlockDefinition{forcedUpper=1}
    ;
  template TCS::OperatorTemplate context addToContext
    :"operatorTemplate" $reference "(" "operators" "=" "operators"{refersTo=name} "," "source" "=" storeLeftSideTo (isDefined(storeOperatorTo)?"," "storeOpTo" "=" storeOperatorTo) (isDefined(storeRightSideTo)?"," "storeRightTo" "=" storeRightSideTo) (isDefined("disambiguate")?"," "disambiguate" "=" "disambiguate"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";}) (isDefined("disambiguateV3")?"," "disambiguateV3" "=" "disambiguateV3"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";}) ")" (isReferenceOnly?"referenceOnly":(isContext?"context" (isDefined(contextTags)?contextTags))) (isDefined(otSequence)?[":" [otSequence]{startNL=false} ";"]:";") textBlockDefinition{forcedUpper=1}
    ;
  template TCS::FunctionTemplate context addToContext
    :"function" functionName "(" $reference ")" [":" [functionSequence]{startNL=false} ";"]
    ;
  template TCS::ContextTags
    :"(" tags{separator=","} ")"
    ;
  template TCS::Sequence
    :elements
    ;
  template TCS::SequenceElement abstract;

  template TCS::LiteralRef
    :referredLiteral{refersTo="value", lookIn=#all, as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";, autoCreate=ifmissing, createAs=Keyword} {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::PropertyReference
    :(isDefined(strucfeature)?strucfeature{refersTo=name, query="OCL:let c = #context.oclAsType(TCS::Template).metaReference in
		  				let result = c.lookupElementExtended(?) in
		  				if not (result.oclIsInvalid()) then
		  					if(result.oclIsTypeOf(Model::Attribute) or
		  							result.oclIsTypeOf(Model::Reference)
		  							or result.oclIsTypeOf(Model::StructureField)) then
		  						Bag{result}	
		  					else 		
		  						c.allSupertypes()->prepend(c)->collect(
		  							st | st.oclAsType(Model::Classifier).typedElements->select(
		  								te | 
		  									if te.oclIsTypeOf(Model::AssociationEnd) then
		  										te.oclAsType(Model::AssociationEnd).otherEnd().name = ? 
		  									else		
		  										false 
		  									endif
		  								)->collect(ae | ae.oclAsType(Model::AssociationEnd).otherEnd())
		  						)
		  					endif 
		  				else	
		  					c.allSupertypes()->prepend(c)->collect(
		  						st | st.oclAsType(Model::Classifier).typedElements->select(
		  							te | 
		  								if te.oclIsTypeOf(Model::AssociationEnd) then
		  									te.oclAsType(Model::AssociationEnd).otherEnd().name = ? 
		  								else
		  									false 
		  								endif
		  							)
		  						)->collect(ae | ae.oclAsType(Model::AssociationEnd).otherEnd()
		  					) 
		  				endif
		  					", as=primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";}:"->" name{as=primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";})
    ;
  template TCS::Property
    :propertyReference (isDefined(propertyArgs)?"{" propertyArgs{separator=","} "}") {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::CustomSeparator
    :"<" name ">" {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::Block
    :"[" blockSequence "]" (isDefined(blockArgs)?"{" blockArgs{separator=","} "}") {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::ConditionalElement
    :"(" condition "?" thenSequence (isDefined(elseSequence)?":" elseSequence) ")" {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::Alternative
    :"[[" sequences{separator="|"} "]]" (isMulti?"*") {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::SequenceInAlternative
    :(isDefined("disambiguate")?"disambiguate" "(" "disambiguate"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} ")") elements
    ;
  template TCS::FunctionCall
    :"$" calledFunction{refersTo=functionName} {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::InjectorActionsBlock
    :"{{" injectorActions{separator=","} "}}" {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::InjectorAction abstract;

  template TCS::PropertyInit abstract;

  template TCS::PrimitivePropertyInit
    :propertyReference (isDefault?"<-":"=") "value"
    ;
  template TCS::LookupPropertyInit
    :propertyReference (isDefault?"<-":"=") "lookIn" "(" "value"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} ")"
    ;
  template TCS::ForeachPredicatePropertyInit
    :propertyReference (isDefault?"<-":"=") "foreach" "(" "value"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} (isDefined(mode)?"," "mode" "=" "mode"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";}) (isDefined(predicatesemantic)?"," predicatesemantic{separator=","}) ")"
    ;
  template TCS::PredicateSemantic
    :(isDefined(when)?"when" "=" "when"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} ",") (isDefined("mode")?"mode" "=" "mode"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} ",") "as" "=" "as"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";, query="OCL:self.foreachParent.injectorActionsBlockReference.parentTemplate.concreteSyntax.templates", filter="->select(t | 
							if(t.oclIsTypeOf(TCS::ClassTemplate)) then 
							 	t.oclAsType(TCS::ClassTemplate).metaReference.name = ? 
							 		and ( 
							 	t.oclAsType(TCS::ClassTemplate).metaReference.allSupertypes()
							 	->prepend(t.oclAsType(TCS::ClassTemplate).metaReference)		
							 	->includesAll(self.foreachParent.propertyReference.strucfeature.type.allSupertypes()))
							  		and ( 
							  		if self.mode->isEmpty() then	
							 			t.oclAsType(TCS::ClassTemplate).mode = self.foreachParent.mode
							                else 		
							 			t.oclAsType(TCS::ClassTemplate).mode = self.mode 
							 		endif ) 
							else 
								if (t.oclIsTypeOf(TCS::PrimitiveTemplate)) then  			
							 		t.oclAsType(TCS::PrimitiveTemplate).templateName = ? 
							 	else 
							 		false 
							 	endif 
 	   						endif)
							"}
    ;
  template TCS::PropertyArg abstract;

  template TCS::RefersToPArg
    :"refersTo" "=" propertyName{as=primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";}
    ;
  template TCS::LookInPArg
    :"lookIn" "=" (propertyName="#all"?"#" "all":propertyName{as=primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";, separator="."})
    ;
  template TCS::CreateInPArg
    :"createIn" "=" propertyName{as=primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";, separator="."}
    ;
  template TCS::AsPArg
    :"as" "=" "template"{as=primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";, query="OCL:self.property.parentTemplate.concreteSyntax.templates", filter="->select(t | 
									if(t.oclIsTypeOf(TCS::ClassTemplate)) then 
										t.oclAsType(TCS::ClassTemplate).metaReference.name = ? 
										and(self.property.propertyReference.strucfeature.type.allSupertypes()
											->prepend(self.property.propertyReference.strucfeature.type)
											->includes(t.oclAsType(TCS::ClassTemplate).metaReference))
										and (
											if (not self.property.propertyArgs->select(
													arg | arg.oclIsTypeOf(TCS::ModePArg))->isEmpty()
												) 
											then
												t.oclAsType(TCS::ClassTemplate).mode = 
													self.property.propertyArgs->select(
														arg | arg.oclIsTypeOf(TCS::ModePArg))
															.oclAsType(TCS::ModePArg)->asSequence()->at(1)
													.mode
											else
												t.oclAsType(TCS::ClassTemplate).mode.oclIsUndefined()
											endif
										)
									else
										if(t.oclIsTypeOf(TCS::PrimitiveTemplate)) then
											t.oclAsType(TCS::PrimitiveTemplate).templateName = ? 
										else
											false
										endif
									endif)
								"}
    ;
  template TCS::SeparatorPArg
    :"separator" "=" separatorSequence
    ;
  template TCS::DisambiguatePArg
    :"disambiguate" "=" disambiguation{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";}
    ;
  template TCS::AutoCreatePArg
    :"autoCreate" "=" "value"
    ;
  enumerationTemplate TCS::AutoCreateKind
    :#always="always",
      #ifmissing="ifmissing",
      #never="never"
    ;
  template TCS::ImportContextPArg
    :"importContext"
    ;
  template TCS::PartialPArg
    :"partial"
    ;
  template TCS::ForcedLowerPArg
    :"forcedLower" "=" "value"
    ;
  template TCS::ForcedUpperPArg
    :"forcedUpper" "=" "value"
    ;
  template TCS::CreateAsPArg
    :"createAs" "=" name{as=primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";, separator="::"}
    ;
  template TCS::QueryPArg
    :"query" "=" "query"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";}
    ;
  template TCS::FilterPArg
    :"filter" "=" "filter"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} (isDefined(invert)?"," "invert" "=" "invert"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";})
    ;
  template TCS::ModePArg
    :"mode" "=" "mode"{as=primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";}
    ;
  template TCS::BlockArg abstract;

  template TCS::NbNLBArg
    :"nbNL" "=" "value"
    ;
  template TCS::IndentIncrBArg
    :"indentIncr" "=" "value"
    ;
  template TCS::StartNLBArg
    :"startNL" "=" ("value"?"true":"false")
    ;
  template TCS::StartNbNLBArg
    :"startNbNL" "=" "value"
    ;
  template TCS::EndNLBArg
    :"endNL" "=" ("value"?"true":"false")
    ;
  template TCS::Symbol addToContext
    :name "=" "value"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} (isDefined(spaces)?":" spaces{separator=","}) ";"
    ;
  enumerationTemplate TCS::SpaceKind
    :#leftSpace="leftSpace",
      #leftNone="leftNone",
      #rightSpace="rightSpace",
      #rightNone="rightNone"
    ;
  template TCS::Keyword addToContext
    :name "=" "value"{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";} ";"
    ;
  template TCS::OperatorList addToContext
    :"operators" (isDefined(name)?name) "{" [priorities] "}"
    ;
  template TCS::Priority
    :"priority" "value" (associativity=#left?:"," associativity) "{" ["operators"] "}"
    ;
  template TCS::Operator addToContext
    :(isPostfix?"postfix") name "=" (isDefined(literal)?[[literal{refersTo=name}| literal{refersTo="value", lookIn=#all, as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";, autoCreate=ifmissing, createAs=Keyword}]]) "," arity ";"
    ;
  enumerationTemplate TCS::Associativity
    :#left="left",
      #right="right"
    ;
  template TCS::Expression abstract;

  template TCS::AndExp
    :expressions{separator="and"}
    ;
  template TCS::AtomExp abstract;

  template TCS::EqualsExp
    :propertyReference "=" "value"
    ;
  template TCS::BooleanPropertyExp
    :propertyReference
    ;
  template TCS::IsDefinedExp
    :"isDefined" "(" propertyReference ")"
    ;
  template TCS::OneExp
    :"one" "(" propertyReference ")"
    ;
  template TCS::InstanceOfExp
    :propertyReference "instanceOf" supertype{separator="::"}
    ;
  template TCS::Value abstract;

  template TCS::StringVal
    :symbol{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";}
    ;
  template TCS::IntegerVal
    :symbol
    ;
  template TCS::NegativeIntegerVal
    :"-" symbol
    ;
  template TCS::EnumLiteralVal
    :"#" name{as=primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";}
    ;
  template TCS::Token
    :(isOmitted?"omitted") "token" name ":" pattern ";"
    ;
  template TCS::OrPattern
    :simplePatterns{separator="|"}
    ;
  template TCS::SimplePattern abstract;

  template TCS::RulePattern
    :rule
    ;
  template TCS::Rule abstract;

  template TCS::WordRule
    :"word" "(" "start" "=" "start" "," "part" "=" "part" (isDefined(end)?"," "end" "=" "end") ")"
    ;
  template TCS::EndOfLineRule
    :"endOfLine" "(" "start" "=" (dropStart?"drop") "start" ")"
    ;
  template TCS::MultiLineRule
    :"multiLine" "(" "start" "=" (dropStart?"drop") "start" "," "end" "=" (dropEnd?"drop") "end" (isDefined(esc)?"," "esc" "=" "esc" (isDefined(escMappings)?"," "(" escMappings{separator=","} ")")) ")"
    ;
  template TCS::Mapping abstract;

  template TCS::SimpleMapping
    :key "->" "value"
    ;
  template TCS::WildcardMapping
    :"." "->" "."
    ;
  template TCS::OctalMapping
    :"octal"
    ;
  template TCS::HexadecimalMapping
    :"hex"
    ;
  template TCS::StringPattern
    :name{as=primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="'\"' + %value%.toCString() + '\"'";}
    ;
  template TCS::ClassPattern
    :"[" name "]"
    ;
  symbols{
    lsquare="[";
    rsquare="]";
    dlsquare="[[";
    drsquare="]]";
    excl="!";
    coma=",";
    lparen="(";
    rparen=")";
    lcurly="{";
    rcurly="}";
    dlcurly="{{";
    drcurly="}}";
    semi=";";
    colon=":";
    dlcolon="::";
    pipe="|";
    sharp="#";
    qmark="?";
    dollar="$";
    arobas="@";
    point=".";
    rarrow="->";
    minus="-";
    star="*";
    slash="/";
    plus="+";
    eq="=";
    gt=">";
    lt="<";
    ge=">=";
    le="<=";
    ne="<>";
    larrow="<-";
  }

  operators DBLCOLON{
    priority 0{
      opDlColon=dlcolon,2;
    }
  }

  token COMMENT:endOfLine(start="--");

  lexer=

  "
%options testLiterals = false;

NL
	:	(	'\r' '\n'
		|	'\n' '\r'	//Improbable
		|	'\r'
		|	'\n'
		)
	{newline();}
	;

WS
	:	(	' '
		|	'\t'
		)
	;

%protected
DIGIT
	:	'0'..'9'
	;

%protected
ALPHA
	:	'a'..'z'
	|	'A'..'Z'
	|	'_'
	//For Unicode compatibility (from 0000 to 00ff)
	|	'\u00C0' .. '\u00D6'
	|	'\u00D8' .. '\u00F6'
	|	'\u00F8' .. '\u00FF'
	;
	



%protected
SNAME
	:	(ALPHA) (ALPHA | DIGIT)* 
;


NAME
	:	(   
		SNAME
		|	'\''!  // exclamation marks means to exclude the char from the token (in theory)
			(	ESC
			|	'\n' {newline();}
			|	~('\\'|'\''|'\n') // means any other character
			)*
			'\''!
		)
	;
	

INT
	:	(DIGIT)+
	;

	FLOAT	:	DIGIT+ '.' DIGIT*	;

%protected
ESC
	:	'\\'!
		(	'n' 
		|	'r' 
		|	't' 
		|	'b' 
		|	'f' 
		|	'"' 
		|	'\'' 
		|	'\\' 
		|	(
				('0'..'3')
				(
				:	('0'..'7')
					(
					:	'0'..'7'
					)?
				)?
			|	('4'..'7')
				(
				:	('0'..'7')
				)?
			)
				{
				}
		)
	;

STRING
	:	'"'!
		(	ESC
		|	'\n' {newline();}
		|	~('\\'|'\"'|'\n')  // means any other character
		)*
		'"'!
	;

	";
}