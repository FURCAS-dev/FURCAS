-- Test base for modifications to the tcs language
-- !! This file may not reflect the latest coreMonet syntax, look for the one in /bootstrap instead

syntax TCS {

	primitiveTemplate identifier for PrimitiveTypes::String default using NAME:
		value = "%token%";

	primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:
		value = "%token%";

	primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:
		value = "%token%",
		--serializer="'\\\"' + %value%.toCString() + '\\\"'";

	primitiveTemplate integerSymbol for PrimitiveTypes::Integer default using INT:
		value = "Integer.valueOf(%token%)";

	primitiveTemplate floatSymbol for PrimitiveTypes::Double default using FLOAT:
		value = "Double.valueOf(%token%)";

	template TCS::ConcreteSyntax main context
		:	"syntax" name (isDefined(k) ?  "(" "k" "=" k ")") "{" [
				templates
				(isDefined(keywords) ? "keywords" "{" [ keywords ] "}")
				(isDefined(symbols) ? "symbols" "{" [ symbols ] "}")
				operatorLists
				tokens
				(isDefined(lexer) ? "lexer" "=" lexer{as = stringSymbol} ";")
			] {nbNL = 2} "}"
		;

-- @begin Templates
	template TCS::Template abstract;
	
	template Model::Namespace abstract operatored(DBLCOLON);
	
	template Model::GeneralizableElement referenceOnly -- should never be created
		: name
		;
		
	operatorTemplate Model::ModelElement(operators =
			opDlColon, source = 'container') referenceOnly -- should never be created
		:
			name
		;

	template Model::Classifier referenceOnly  -- should never be created
	: ( isDefined(container) ? container   -- is of type namespace in MM 
	  "::" name : name)
	;
	
	
	function reference(TCS::QualifiedNamedElement)
		: (isDefined(metaReference) 
		  ? metaReference   -- is assumed to be of type Classifier in MM
		  : "->" names{separator="::"})
		;
		
	

	template TCS::PrimitiveTemplate
		:	"primitiveTemplate" templateName "for" $reference
				(isDefault ? "default")
				"using" tokenName
				(orKeyword ? "orKeyword")
			":"
				"value" "=" value{as = stringSymbol}
				(isDefined(serializer) ?
					"," "serializer" "=" serializer{as = stringSymbol}
				)
			";"
		;

	template TCS::EnumerationTemplate context addToContext
		:	"enumerationTemplate" $reference (automatic ? "auto")
			(isDefined(mappings) ?
					[ ":" [
						mappings{separator = ","}
					] {startNL = false} ";" ]
				:
					";"
			)
		;

	template TCS::EnumLiteralMapping
		:	literal "=" element
		;

	template TCS::ClassTemplate context addToContext
		:	"template" $reference
			(isReferenceOnly 
			  ? "referenceOnly" -- Reference Templates do not have other classTemplate attributes 
			  : 
				(isDefined(mode) ? "#" mode)
				(isDefined(disambiguate) ? "(" "disambiguate" "=" disambiguate{as = stringSymbol} ")")
				(isMulti ? "multi")
				(isMain ? "main")
				(isAbstract ? (isDeep ? "deep") "abstract")
				(isOperatored ? "operatored" (isDefined(operatorList) ? "(" operatorList{refersTo = name} ")"))
				(isContext ? "context")
				(isAddToContext ? "addToContext")
				(isNonPrimary ? "nonPrimary")
				(isDefined(prefixSequence) ? "prefix" [ ":" [ prefixSequence ] {startNL = false} ])
			)
			(isDefined(templateSequence) ? [ ":" [ templateSequence ] {startNL = false} ";" ] : ";")
		;

	template TCS::OperatorTemplate context addToContext
		:	"operatorTemplate" $reference 
			"("
				"operators" "=" operators{refersTo = name}
				"," "source" "=" source
				(isDefined(storeOpTo) ? "," "storeOpTo" "=" storeOpTo)
				(isDefined(storeRightTo) ? "," "storeRightTo" "=" storeRightTo)
				(isDefined(disambiguate) ? "," "disambiguate" "=" disambiguate{as = stringSymbol})
				(isDefined(disambiguateV3) ? "," "disambiguateV3" "=" disambiguateV3{as = stringSymbol})
			")"
			(isReferenceOnly ? "referenceOnly" :
				(isContext ? "context")
			)
			(isDefined(otSequence) ? [ ":" [ otSequence ] {startNL = false} ";" ] : ";")
		;

	template TCS::FunctionTemplate context addToContext
		:	"function" functionName "(" $reference ")"
				[ ":"
					[ functionSequence ] {startNL = false}
				";" ]
		;
-- @end Templates

	template TCS::Sequence
		:	elements
		;

-- @begin Sequence Elements
	template TCS::SequenceElement abstract;

	template TCS::LiteralRef
		:
-- COMMENT FOR EXTRACTOR
--			[[
				referredLiteral{refersTo = value, lookIn = #all, as = stringSymbol, autoCreate = ifmissing, createAs = Keyword}
--			|
--				"@" referredLiteral{refersTo = name}
--			]]
		;

	template TCS::Property addToContext
		: -- for reference, need to look in metareference modelElement of the template this property belongs to	
		  (isDefined(strucfeature) ? strucfeature{refersTo=name, lookIn='#context.metaReference', as = identifierOrKeyword}
		  : "->" name{as = identifierOrKeyword})
		(isDefined(propertyArgs) ? "{" propertyArgs{separator = ","} "}")
		;

	template TCS::CustomSeparator
		:	"<" name ">"
		;

	template TCS::Block
		:	"[" blockSequence "]" (isDefined(blockArgs) ? "{" blockArgs{separator = ","} "}")
		;

	template TCS::ConditionalElement
		:	"(" condition "?" thenSequence (isDefined(elseSequence) ? ":" elseSequence) ")"
		;

--	template TCS::PropertyInit
--		:	"{{" name "<-" value "}}"
--		;

	template TCS::Alternative
		:	"[[" sequences{separator = "|"} "]]" (isMulti ? "*")
		;

	template TCS::FunctionCall
		:	"$" calledFunction{refersTo = functionName}
		;
-- @end Sequence Elements


-- @begin Property Arguments
	template TCS::PropertyArg abstract;

	template TCS::RefersToPArg
		:	"refersTo" "=" propertyName{as = identifierOrKeyword}
		;

	template TCS::LookInPArg
		:	"lookIn" "=" (propertyName = "#all" ? "#" "all" : propertyName{as = identifierOrKeyword, separator = "."})
		;

	template TCS::CreateInPArg
		:	"createIn" "=" propertyName{as = identifierOrKeyword, separator = "."}
		;

	template TCS::AsPArg
		:	"as" "=" value {as = identifierOrKeyword}
		;

--	template TCS::RefersToKeyPArg
--		:	"refersToKey" "=" (value ? "true" : "false")
--		;

	template TCS::SeparatorPArg
		:	"separator" "=" separatorSequence
		;

	template TCS::AutoCreatePArg
		:	"autoCreate" "=" value
		;

	enumerationTemplate TCS::AutoCreateKind
		:	#always		= "always",
			#ifmissing	= "ifmissing",
			#never		= "never"
		;

	template TCS::ImportContextPArg
		:	"importContext"
		;

	template TCS::ForcedLowerPArg
		:	"forcedLower" "=" value
		;

	template TCS::CreateAsPArg
		:	"createAs" "=" name{as = identifierOrKeyword, separator = "::"}
		;

	template TCS::QueryPArg
		:	"query" "=" query{as = identifierOrKeyword}
		;

	template TCS::ModePArg
		:	"mode" "=" mode{as = identifierOrKeyword}
		;
-- @end Property Arguments


-- @begin Block Arguments
	template TCS::BlockArg abstract;

	template TCS::NbNLBArg
		:	"nbNL" "=" value
		;

	template TCS::IndentIncrBArg
		:	"indentIncr" "=" value
		;

	template TCS::StartNLBArg
		:	"startNL" "=" (value ? "true" : "false")
		;

	template TCS::StartNbNLBArg
		:	"startNbNL" "=" value
		;

	template TCS::EndNLBArg
		:	"endNL" "=" (value ? "true" : "false")
		;
-- @end Block Arguments


-- @begin Literals
--	template Literal abstract;

	template TCS::Symbol addToContext
		:	name "=" value{as = stringSymbol} (isDefined(spaces) ? ":" spaces{separator = ","}) ";"
		;

	enumerationTemplate TCS::SpaceKind
		:	#leftSpace	=	"leftSpace",
			#leftNone	=	"leftNone",
			#rightSpace	=	"rightSpace",
			#rightNone	=	"rightNone"
		;

	template TCS::Keyword addToContext
		:	name "=" value{as = stringSymbol} ";"
		;
-- @end Literals

-- @begin Operators
	template TCS::OperatorList addToContext
		:	"operators" (isDefined(name) ? name) "{" [
				priorities
			] "}"
		;

	template TCS::Priority
		:	"priority" value
			(associativity = #left ?
					-- nothing
				:
					"," associativity
			)
			"{" [
				operators
			] "}"
		;
		
	template TCS::Operator addToContext
		:	(isPostfix ? "postfix") name "="
			(isDefined(literal) ? [[
				literal{refersTo = name}
			|
				literal{refersTo = value, lookIn = #all, as = stringSymbol, autoCreate = ifmissing, createAs = Keyword}
			]])
			"," arity ";"
		;

	enumerationTemplate TCS::Associativity
		:	#left		= "left",
			#right		= "right"
		;
-- @end Operators

-- @begin Expressions
	template TCS::Expression abstract;

	template TCS::AndExp
		:	expressions{separator = "and"}
		;

	template TCS::AtomExp abstract;

	template TCS::EqualsExp
		:	propertyName{as = identifierOrKeyword} "=" value
		;

	template TCS::BooleanPropertyExp
		:	propertyName{as = identifierOrKeyword}
		;

	template TCS::IsDefinedExp
		:	"isDefined" "(" propertyName{as = identifierOrKeyword} ")"
		;
		
	template TCS::OneExp
		:	"one" "(" propertyName{as = identifierOrKeyword} ")"
		;

	template TCS::InstanceOfExp
		:	propertyName{as = identifierOrKeyword} "instanceOf" supertype{separator = "::"}
		;

--@end Expressions

-- @begin Values
	template TCS::Value abstract;

	template TCS::StringVal
		:	symbol{as = stringSymbol}
		;
	
	template TCS::IntegerVal
		:	symbol
		;
	
	template TCS::NegativeIntegerVal
		:	"-" symbol
		;

	template TCS::EnumLiteralVal
		:	"#" name{as = identifierOrKeyword}
		;
-- @end Values


-- @begin Tokens
	template TCS::Token
		:	"token" name ":" pattern ";"
		;

	template TCS::OrPattern
		:	simplePatterns{separator = "|"}
		;

-- @begin SimplePatterns
	template TCS::SimplePattern abstract;

	template TCS::RulePattern
--		:	name "(" arguments{separator = ","} ")"
		:	rule
		;

-- @begin Rules
	template TCS::Rule abstract;

	template TCS::WordRule
		:	"word" "("
				"start" "=" start ","
				"part" "=" part
				(isDefined(end) ?
					"," "end" "=" end
				)
--				(isDefined(words) ?
--					"," "words" "=" "(" words{separator = ","} ")"
--				)
			")"
		;

--	template TCS::Word
--		:	name{as = stringSymbol} ":" token
--		;

	template TCS::EndOfLineRule
		:	"endOfLine" "("
				"start" "=" (dropStart ? "drop") start
			")"
		;

	template TCS::MultiLineRule
		:	"multiLine" "("
				"start" "=" (dropStart ? "drop") start ","
				"end" "=" (dropEnd ? "drop") end
				(isDefined(esc) ?
					"," "esc" "=" esc
					(isDefined(escMappings) ?
						"," "(" escMappings{separator = ","} ")"
					)
				)
			")"
		;
	
	template TCS::Mapping abstract;
	
	template TCS::SimpleMapping
		:	key "->" value
		;
		
	template TCS::WildcardMapping
		:	"." "->" "."
		;
		
	template TCS::OctalMapping
		:	"octal"
		;
		
	template TCS::HexadecimalMapping
		:	"hex"
		;
-- @end Rules

--	template TCS::RuleArgument
--		:	name "=" value
--		;

	template TCS::StringPattern
		:	name{as = stringSymbol}
		;

	template TCS::ClassPattern
		:	"[" name "]"
		;
-- @end SimplePatterns
-- @end Tokens
	
	symbols {
		lsquare		= "[";
		rsquare		= "]";
		dlsquare	= "[[";
		drsquare	= "]]";
		excl		= "!";
		coma		= ",";
		lparen		= "(";
		rparen		= ")";
		lcurly		= "{";
		rcurly		= "}";
		dlcurly		= "{{";
		drcurly		= "}}";
		semi		= ";";
		colon		= ":";
		dlcolon		= "::";		
		pipe		= "|";
		sharp		= "#";
		qmark		= "?";
		dollar		= "$";
		arobas		= "@";

		-- operator symbols
		point		= ".";
		rarrow		= "->";
		minus		= "-";
		star		= "*";
		slash		= "/";
		plus		= "+";
		eq		= "=";
		gt		= ">";
		lt		= "<";
		ge		= ">=";
		le		= "<=";
		ne		= "<>";
		larrow		= "<-";
	}

	operators DBLCOLON{
		priority 0 {
			opDlColon = dlcolon, 2;
		}
	}

	token COMMENT	: endOfLine(start = "--");

	lexer = "
%options testLiterals = false;

NL
	:	(	'\\r' '\\n'
		|	'\\n' '\\r'	//Improbable
		|	'\\r'
		|	'\\n'
		)
	{newline();}
	;

WS
	:	(	' '
		|	'\\t'
		)
	;

%protected
DIGIT
	:	'0'..'9'
	;

%protected
ALPHA
	:	'a'..'z'
	|	'A'..'Z'
	|	'_'
	//For Unicode compatibility (from 0000 to 00ff)
	|	'\\u00C0' .. '\\u00D6'
	|	'\\u00D8' .. '\\u00F6'
	|	'\\u00F8' .. '\\u00FF'
	;
	



%protected
SNAME
	:	(ALPHA) (ALPHA | DIGIT)* 
;

NAME
	:	(   
		SNAME
		|	'\\''!
			(	ESC
			|	'\\n' {newline();}
			|	~('\\\\'|'\\''|'\\n')
			)*
			'\\''!
		{setText(unescapeString(getText(), 1));}
		)
	;
	

INT
	:	(DIGIT)+
	;

	FLOAT	:	DIGIT+ '.' DIGIT*	;

%protected
ESC
	:	'\\\\'!
		(	'n' 
		|	'r' 
		|	't' 
		|	'b' 
		|	'f' 
		|	'\"' 
		|	'\\'' 
		|	'\\\\' 
		|	(
				('0'..'3')
				(
				:	('0'..'7')
					(
					:	'0'..'7'
					)?
				)?
			|	('4'..'7')
				(
				:	('0'..'7')
				)?
			)
				{
				}
		)
	;

STRING
	:	'\"'!
		(	ESC
		|	'\\n' {newline();}
		|	~('\\\\'|'\\\"'|'\\n')
		)*
		'\"'!
		{setText(unescapeString(getText(), 1));}

	;

	";

}
