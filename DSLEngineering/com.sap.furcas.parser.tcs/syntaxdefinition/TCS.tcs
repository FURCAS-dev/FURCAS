-- Identifiers are ALPHA (ALPHA | DIGIT)* with a special form between single quote to escape them in case they are the same as a keywords of TCS
-- Strings are double quoted
-- Comments begin with -- and end with the end of the line
syntax TCS {

        primitiveTemplate identifier for ecore::EString default using NAME :
                value = "unescapeString(%token%)";

        primitiveTemplate identifierOrKeyword for ecore::EString using NAME orKeyword:
                value = "unescapeString(%token%)";
                
        primitiveTemplate escapedIdentifierOrKeyword for ecore::EString using NAME orKeyword:
                value = "unescapeString(%token%)",
                serializer = "\'%value%\'";

        primitiveTemplate stringSymbol for ecore::EString using STRING:
                value = "unescapeString(%token%)",
				serializer="\"%value%\"";
	
	primitiveTemplate plainStringSymbol for ecore::EString using STRING:
                value = "unescapeString(%token%)";

        primitiveTemplate integerSymbol for ecore::EIntegerObject default using INT:
                value = "Integer.valueOf(%token%)";

        primitiveTemplate floatSymbol for ecore::EDoubleObject default using FLOAT:
                value = "Double.valueOf(%token%)";
       
/**        primitiveTemplate qualifiedNameSymbol for ecore::EString using QNAME:
                value = "unescapeString(%token%)";
                
          primitiveTemplate qualifiedNameSymbolList for ecore::EString using QNAME:
                value = "java.util.Arrays.asList(unescapeString(%token%).split(\"::\"))";
*/
        -- ecore element representation in qualified names

        
        -- A modelClassifier is either its container followed by :: and a name, or just a name
        template ecore::EClassifier referenceOnly --should never be created
        : ( isDefined(ePackage) ? ePackage   -- is of type Namespace in MM
          "::" name : name)
        ;
/** TODO: Find out how to do this properly. Currently it does not really make sense          
        -- Namespace gets operatored using the :: operator to resolve left recursion
        template ecore::ENamedElement abstract operatored(DBLCOLON);
*/        
        -- if parsed path has more than one element, 
        -- the first will be of type Generalizable element
        -- because that is the type of Mode::ModelElement.container
        template ecore::EPackage referenceOnly -- should never be created
                : name
                ;
                
/** TODO: Find out how to do this properly. Currently it does not really make sense  
        -- any following elements in a package path will be resolved using this
        operatorTemplate ecore::EClassifier(operators =
                        opDlColon, source = 'ePackage') referenceOnly -- should never be created
                :
                        name
                ;
        -- end ecore element representation
*/


        -- @begin TextBlockDefintion
        template textblockdefinition::TextBlockDefinition
                :
                ;
        -- @end TextBlockDefintion      

        -- the root element of any syntax definition
        template TCS::ConcreteSyntax main context
                :       "syntax" name (isDefined(k) ?  "(" "k" "=" k ")") "{" [
                                templates
                                (isDefined(keywords) ? "keywords" "{" [ keywords ] "}")
                                (isDefined(symbols) ? "symbols" "{" [ symbols ] "}")
                                operatorLists
                                tokens
                                (isDefined(lexer) ? "lexer" "=" lexer{as = stringSymbol} ";")
                        ] {nbNL = 2} "}"
                ;


        
        -- utility for all qualified meta references
        function reference(TCS::QualifiedNamedElement)
                : (isDefined(metaReference) 
                  ? 
/**               [[
                        metaReference{as=qualifiedNameSymbol,
                        query="let e=Sequence{1..?.size()}->select(j|?.subString(j, j+1) = '::')->iterate(
                                        i; acc:Tuple(pos:Integer, ns:Set(ecore:EObject), qn:String)=Tuple{pos=1, ns=null, qn=''} |
                                let namePart=?.subString(acc.pos, -1+i) in
                                Tuple{pos=i+2,
                                      ns=if acc.ns=null then
                                        Namespace.allInstances()->select(
                                                ns2 | ns2.container->isEmpty() and ns2.name=namePart)
                                  else
                                        acc.ns.contents->select(ns2 | ns2.name=namePart)->asSet()
                                  endif,
                                  qn=acc.qn.concat('::').concat(namePart)}) in
                                  e.ns.contents->select(c | c.name=?.subString(e.pos, ?.size()))",
                        filter="",
                        invert="let qname = self.getQualifiedName()->iterate(n, qn | qn=qn.concat('::'.concat(q))).substring(3, qname.size())"
                        } 
                        |
                        metaReference{as=identifier, query="Classifier.allInstances()", filter="->select(c | c.name = ?)", invert="name"}
*/                      metaReference   
                        --]]
                  : "->" names{separator="::"}) -- workaround allowing to specify metatypes without directly referencing them
/**                    [[
                        "->" names{as=qualifiedNameSymbolList} -- workaround allowing to specify metatypes without directly referencing them
                        |
                        
                        "->" names{as=identifier, forcedUpper=1, forcedLower=1} -- workaround allowing to specify metatypes without directly referencing them
                    ]]
                    )
*/                  
                ;

-- @begin Templates

        template TCS::Template abstract;
        
        template TCS::ContextTemplate abstract;

        template TCS::PrimitiveTemplate
                :       "primitiveTemplate" templateName "for" $reference
                                (isDefault ? "default")
                                "using" tokenName
                                (orKeyword ? "orKeyword")
                        ":"
                                "value" "=" value{as = stringSymbol}
                                (isDefined(serializer) ?
                                        "," "serializer" "=" serializer{as = stringSymbol}
                                )
                        ";"
/** TODO: property not specified in the metamodel
                        textBlockDefinition{forcedUpper=1}
*/
                ;

        template TCS::EnumerationTemplate context addToContext
                :       "enumerationTemplate" $reference (automatic ? "auto")
                        (isDefined(mappings) ?
                                        [ ":" [
                                                mappings{separator = ","}
                                        ] {startNL = false} ";" ]
                                :
                                        ";"
                        )
/** TODO: property not specified in the metamodel
                        textBlockDefinition{forcedUpper=1}
*/
                ;

        template TCS::EnumLiteralMapping
                :       literal "=" element
                ;

        template TCS::ClassTemplate context addToContext
                :       "template" $reference
                        (isReferenceOnly 
                          ? "referenceOnly" -- Reference Templates do not have other classTemplate attributes 
                          : 
                                (isDefined(mode) ? "#" mode{as = identifierOrKeyword})
                                (isDefined(disambiguate) ? "(" "disambiguate" "=" disambiguate{as = stringSymbol} ")")
                                (isDefined(disambiguateV3) ? "(" "disambiguateV3" "=" disambiguateV3{as = stringSymbol} ")")
                                (isDefined(semDisambiguate) ? "(" "semDisambiguate" "=" semDisambiguate{as = stringSymbol} ")")
                                (isMulti ? "multi")
                                (isMain ? "main")
                                (isAbstract ? (isDeep ? "deep") "abstract")
                                (isOperatored ? "operatored" (isDefined(operatorList) ? "(" operatorList{refersTo = name} ")"))
                                (isContext ? "context" (isDefined(contextTags) ? contextTags))
                                (isAddToContext ? "addToContext")
                                (isNonPrimary ? "nonPrimary")
                                (isDefined(prefixSequence) ? "prefix" [ ":" [ prefixSequence ] {startNL = false} ])
                          )
                        (isDefined(templateSequence) ? [ ":" [ templateSequence ] {startNL = false} ";" ] : ";")
/** TODO: property not specified in the metamodel
                        textBlockDefinition{forcedUpper=1}
*/
                ;

        template TCS::OperatorTemplate context addToContext
                :       "operatorTemplate" $reference "("
                                "operators" "=" operators{refersTo = name}
                                "," "source" "=" storeLeftSideTo
                                (isDefined(storeOperatorTo) ? "," "storeOpTo" "=" storeOperatorTo)
                                (isDefined(storeRightSideTo) ? "," "storeRightTo" "=" storeRightSideTo)
                                (isDefined(disambiguate) ? "," "disambiguate" "=" disambiguate{as = stringSymbol})
                                (isDefined(disambiguateV3) ? "," "disambiguateV3" "=" disambiguateV3{as = stringSymbol})
                                (isDefined(semDisambiguate) ? "," "semDisambiguate" "=" semDisambiguate{as = stringSymbol})
                        ")"
                        (isReferenceOnly ? "referenceOnly" :
                                (isContext ? "context" (isDefined(contextTags) ? contextTags))
                        )
                        (isDefined(otSequence) ? [ ":" [ otSequence ] {startNL = false} ";" ] : ";")
/** TODO: property not specified in the metamodel
                        textBlockDefinition{forcedUpper=1}
*/
                ;

        template TCS::FunctionTemplate context addToContext
                :       "function" functionName "(" $reference ")"
                                [ ":"
                                        [ functionSequence ] {startNL = false}
                                ";" ]
                ;
                
        template TCS::ContextTags
                : "(" tags{separator= ","} ")"
                ;
-- @end Templates

        template TCS::Sequence
                :       [ elements ]
                ;

-- @begin Sequence Elements
        template TCS::SequenceElement abstract;

/** TODO keyword property not defined

        template TCS::LiteralRef
                :
-- COMMENT FOR EXTRACTOR
--                      [[
                                referredLiteral{refersTo = value, lookIn = #all, as = stringSymbol, autoCreate = ifmissing, createAs = Keyword}
--                      |
--                              "@" referredLiteral{refersTo = name}
--                      ]]
                        {{ parentTemplate = lookIn("OCL:#context") }}
                ;
*/

        template TCS::PropertyReference 
            :
            -- for reference, need to look in metareference modelElement of the template this property belongs to       
                  (isDefined(strucfeature) ? 
                        strucfeature{
                                refersTo=name, 
                                query="OCL:let c:ecore::EClass = #context.oclAsType(FURCAS::TCS::Template).metaReference in
                                                let result:ecore::EClass = c.getEStructuralFeature(?) in
                                                if not (result.oclIsInvalid()) then
                                                        if(result.oclIsTypeOf(ecore::EAttribute) or
                                                                        result.oclIsTypeOf(ecore::EReference)
                                                                        or result.oclIsTypeOf(ecore::StructureField)) then
                                                                Bag{result}     
                                                        else            
                                                                c.eAllSuperTypes->prepend(c)->collect(
                                                                        st | st.oclAsType(ecore::EClassifier).typedElements->select(
                                                                                te | 
                                                                                        if te.oclIsTypeOf(Model::AssociationEnd) then
                                                                                                te.oclAsType(Model::AssociationEnd).otherEnd().name = ? 
                                                                                        else            
                                                                                                false 
                                                                                        endif
                                                                                )->collect(ae | ae.oclAsType(Model::AssociationEnd).otherEnd())
                                                                )
                                                        endif 
                                                else    
                                                        c.eAllSuperTypes->prepend(c)->collect(
                                                                st | st.oclAsType(ecore::EClassifier).typedElements->select(
                                                                        te | 
                                                                                if te.oclIsTypeOf(Model::AssociationEnd) then
                                                                                        te.oclAsType(Model::AssociationEnd).otherEnd().name = ? 
                                                                                else
                                                                                        false 
                                                                                endif
                                                                        )
                                                                )->collect(ae | ae.oclAsType(Model::AssociationEnd).otherEnd()
                                                        ) 
                                                endif
                                                        ",
                                                filter="", invert="name", as = identifierOrKeyword}
                  : "->" name{as = identifierOrKeyword})
            ;

        template TCS::Property
                : propertyReference
                  (isDefined(propertyArgs) ? "{" propertyArgs{separator = ","} "}")
                  {{ parentTemplate = lookIn("OCL:#context") }}
                ;

        template TCS::CustomSeparator
                :       "<" name ">"
                        {{ parentTemplate = lookIn("OCL:#context") }}
                ;

        template TCS::Block
                :       "[" blockSequence "]" (isDefined(blockArgs) ? "{" blockArgs{separator = ","} "}")
                        {{ parentTemplate = lookIn("OCL:#context") }}
                ;

        template TCS::ConditionalElement
                :       "(" condition "?" thenSequence (isDefined(elseSequence) ? ":" elseSequence) ")"
                        {{ parentTemplate = lookIn("OCL:#context") }}
                ;

        template TCS::Alternative
                :       "[[" [ sequences{separator = "|"} ]  "]]" (isMulti ? "*")
                        {{ parentTemplate = lookIn("OCL:#context") }}
                ;
                
        template TCS::SequenceInAlternative
                :       (isDefined(disambiguate) ? "disambiguate" "(" disambiguate{as = stringSymbol} ")") 
                        [ elements ]
                ;
                
        template TCS::FunctionCall
                :       "$" calledFunction{refersTo = functionName}
                        {{ parentTemplate = lookIn("OCL:#context") }}
                ;

        template TCS::InjectorActionsBlock
                :       "{{" [ injectorActions{separator = ","} ] "}}"
                        {{ parentTemplate = lookIn("OCL:#context") }}
                ;
                
        template TCS::InjectorAction abstract;
        
        template TCS::PropertyInit abstract;
        
/** TODO: Properties not specified within the metamodel  
        
        template TCS::PrimitivePropertyInit
                :       propertyReference (isDefault ? "<-" : "=") value { as = escapedIdentifierOrKeyword }
                ;
        
        template TCS::LookupPropertyInit
                :       propertyReference (isDefault ? "<-" : "=") "lookIn" "(" value { as = stringSymbol } ")"
                ;
        template TCS::ForeachPredicatePropertyInit
                :       propertyReference (isDefault ? "<-" : "=") "foreach" "(" 
                                value {as = stringSymbol} 
                                (isDefined(mode)? "," "mode" "=" mode {as = identifierOrKeyword})
                                (isDefined(predicateSemantic)? "," [ predicateSemantic {separator=","} ] )
                                ")"
                ;
*/                

                template TCS::PredicateSemantic
                : (isDefined(when)?  "when" "=" when {as = stringSymbol}",") 
                  (isDefined(mode)?  "mode" "=" mode {as = identifierOrKeyword}",")
                  "as" "=" 
/**               [[
                  as {as = qualifiedNameSymbol, 
                                        query="OCL:self.foreachParent.injectorActionsBlockReference.parentTemplate.concreteSyntax.templates", 
                                        filter="->select(t | if(t.oclIsTypeOf(FURCAS::TCS::ClassTemplate)) then 
                                let e=Sequence{1..?.size()}->select(j|?.subString(j, j+1) = '::')->iterate(
                                        i; acc:Tuple(pos:Integer, ns:Set(ecore:EObject), qn:String)=Tuple{pos=1, ns=null, qn=''} |
                                let namePart=?.subString(acc.pos, -1+i) in
                                Tuple{pos=i+2,
                                      ns=if acc.ns=null then
                                        Namespace.allInstances()->select(
                                                ns2 | ns2.container->isEmpty() and ns2.name=namePart)
                                  else
                                        acc.ns.contents->select(ns2 | ns2.name=namePart)->asSet()
                                  endif,
                                  qn=acc.qn.concat('::').concat(namePart)}) in
                                  e.ns.contents->select(c | c.name=?.subString(e.pos, ?.size()))->asSequence()->at(1) =
                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference
                                                                                and(t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference).eAllSuperTypes
                                                                                        TCS::prepend(t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference)
                                                                                        TCS::includes(self.foreachParent.propertyReference.strucfeature.type)
                                                                                and (
                                                                                        if(not self.mode.oclIsUndefined()) then
                                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).mode = self.mode
                                                                                        else
                                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).mode = self.foreachParent.mode
                                                                                        endif
                                                                                )                                                                       
                                                                        else
                                                                                if(t.oclIsTypeOf(FURCAS::TCS::PrimitiveTemplate)) then
                                                                                        t.oclAsType(FURCAS::TCS::PrimitiveTemplate).templateName = ?
                                                                                else
                                                                                        false
                                                                                endif
                                                                        endif)
                                                                ",
                                                        invert="OCL:if self.oclIsTypeOf(FURCAS::TCS::ClassTemplate) then
                                                                                        self.oclAsType(FURCAS::TCS::ClassTemplate).metaReference.name
                                                                                else 
                                                                                        if self.oclIsTypeOf(FURCAS::TCS::PrimitiveTemplate) then
                                                                                                self.oclAsType(FURCAS::TCS::PrimitiveTemplate).templateName
                                                                                        else
                                                                                                '<no name?>'
                                                                                        endif
                                                                                endif"}
                        |       
*/                              as {as = identifierOrKeyword, 
                                                                query="OCL:self.foreachParent.injectorActionsBlockReference.parentTemplate.concreteSyntax.templates", 
                                                        filter="->select(t | 
                                                                        if(t.oclIsTypeOf(FURCAS::TCS::ClassTemplate)) then 
                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference.name = ?
                                                                                and(t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference).eAllSuperTypes
                                                                                        TCS::prepend(t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference)
                                                                                        TCS::includes(self.foreachParent.propertyReference.strucfeature.type)
                                                                                and (
                                                                                        if(not self.mode.oclIsUndefined()) then
                                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).mode = self.mode
                                                                                        else
                                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).mode = self.foreachParent.mode
                                                                                        endif
                                                                                )                                                                       
                                                                        else
                                                                                if(t.oclIsTypeOf(FURCAS::TCS::PrimitiveTemplate)) then
                                                                                        t.oclAsType(FURCAS::TCS::PrimitiveTemplate).templateName = ?
                                                                                else
                                                                                        false
                                                                                endif
                                                                        endif)
                                                                ",
                                                        invert="OCL:if self.oclIsTypeOf(FURCAS::TCS::ClassTemplate) then
                                                                                        self.oclAsType(FURCAS::TCS::ClassTemplate).metaReference.name
                                                                                else 
                                                                                        if self.oclIsTypeOf(FURCAS::TCS::PrimitiveTemplate) then
                                                                                                self.oclAsType(FURCAS::TCS::PrimitiveTemplate).templateName
                                                                                        else
                                                                                                '<no name?>'
                                                                                        endif
                                                                                endif"}
                        --]]
                ;

-- @end Sequence Elements


-- @begin Property Arguments
        template TCS::PropertyArg abstract;

        template TCS::RefersToPArg
                :       "refersTo" "=" propertyName{as = identifierOrKeyword}
                ;

        template TCS::LookInPArg
                :       "lookIn" "=" (propertyName = "#all" ? "#" "all" : propertyName{as = identifierOrKeyword, separator = "."})
                ;

        template TCS::CreateInPArg
                :       "createIn" "=" propertyName{as = identifierOrKeyword, separator = "."}
                ;

        template TCS::AsPArg
                :       "as" "=" 
/**                     [[
                                template {as = qualifiedNameSymbol, 
                                        query="OCL:self.property.parentTemplate.concreteSyntax.templates", 
                                        filter="->select(t | if(t.oclIsTypeOf(FURCAS::TCS::ClassTemplate)) then 
                                let e=Sequence{1..?.size()}->select(j|?.subString(j, j+1) = '::')->iterate(
                                        i; acc:Tuple(pos:Integer, ns:Set(ecore:EObject), qn:String)=Tuple{pos=1, ns=null, qn=''} |
                                let namePart=?.subString(acc.pos, -1+i) in
                                Tuple{pos=i+2,
                                      ns=if acc.ns=null then
                                        Namespace.allInstances()->select(
                                                ns2 | ns2.container->isEmpty() and ns2.name=namePart)
                                  else
                                        acc.ns.contents->select(ns2 | ns2.name=namePart)->asSet()
                                  endif,
                                  qn=acc.qn.concat('::').concat(namePart)}) in
                                  e.ns.contents->select(c | c.name=?.subString(e.pos, ?.size()))->asSequence()->at(1) =
                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference
                                                                                and(self.property.propertyReference.strucfeature.type.eAllSuperTypes
                                                                                        TCS::prepend(self.property.propertyReference.strucfeature.type)
                                                                                        TCS::includes(t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference))
                                                                                and (
                                                                                        if (not self.property.propertyArgs->select(
                                                                                                        arg | arg.oclIsTypeOf(FURCAS::TCS::ModePArg))->isEmpty()
                                                                                                ) 
                                                                                        then
                                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).mode = 
                                                                                                        self.property.propertyArgs->select(
                                                                                                                arg | arg.oclIsTypeOf(FURCAS::TCS::ModePArg))
                                                                                                                        .oclAsType(FURCAS::TCS::ModePArg)->asSequence()->at(1)
                                                                                                        .mode
                                                                                        else
                                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).mode.oclIsUndefined()
                                                                                        endif
                                                                                )
                                                                        else
                                                                                if(t.oclIsTypeOf(FURCAS::TCS::PrimitiveTemplate)) then
                                                                                        t.oclAsType(FURCAS::TCS::PrimitiveTemplate).templateName = ? 
                                                                                else
                                                                                        false
                                                                                endif
                                                                        endif)
                                                                ",
                                                        invert="OCL:if self.oclIsTypeOf(FURCAS::TCS::ClassTemplate) then
                                                                                        self.oclAsType(FURCAS::TCS::ClassTemplate).metaReference.name
                                                                                else 
                                                                                        if self.oclIsTypeOf(FURCAS::TCS::PrimitiveTemplate) then
                                                                                                self.oclAsType(FURCAS::TCS::PrimitiveTemplate).templateName
                                                                                        else
                                                                                                '<no name?>'
                                                                                        endif
                                                                                endif"}
                        |
*/
                                template {as = identifierOrKeyword, 
                                                                query="OCL:self.property.parentTemplate.concreteSyntax.templates", 
                                                                filter="->select(t | 
                                                                        if(t.oclIsTypeOf(FURCAS::TCS::ClassTemplate)) then 
                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference.name = ? 
                                                                                and(self.property.propertyReference.strucfeature.type.eAllSuperTypes
                                                                                        TCS::prepend(self.property.propertyReference.strucfeature.type)
                                                                                        TCS::includes(t.oclAsType(FURCAS::TCS::ClassTemplate).metaReference))
                                                                                and (
                                                                                        if (not self.property.propertyArgs->select(
                                                                                                        arg | arg.oclIsTypeOf(FURCAS::TCS::ModePArg))->isEmpty()
                                                                                                ) 
                                                                                        then
                                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).mode = 
                                                                                                        self.property.propertyArgs->select(
                                                                                                                arg | arg.oclIsTypeOf(FURCAS::TCS::ModePArg))
                                                                                                                        .oclAsType(FURCAS::TCS::ModePArg)->asSequence()->at(1)
                                                                                                        .mode
                                                                                        else
                                                                                                t.oclAsType(FURCAS::TCS::ClassTemplate).mode.oclIsUndefined()
                                                                                        endif
                                                                                )
                                                                        else
                                                                                if(t.oclIsTypeOf(FURCAS::TCS::PrimitiveTemplate)) then
                                                                                        t.oclAsType(FURCAS::TCS::PrimitiveTemplate).templateName = ? 
                                                                                else
                                                                                        false
                                                                                endif
                                                                        endif)
                                                                ", 
                                                                invert="OCL:if self.oclIsTypeOf(FURCAS::TCS::ClassTemplate) then
                                                                                        self.oclAsType(FURCAS::TCS::ClassTemplate).metaReference.name
                                                                                else 
                                                                                        if self.oclIsTypeOf(FURCAS::TCS::PrimitiveTemplate) then
                                                                                                self.oclAsType(FURCAS::TCS::PrimitiveTemplate).templateName
                                                                                        else
                                                                                                '<no name?>'
                                                                                        endif
                                                                                endif"}
                        --]]
                ;

--      template TCS::RefersToKeyPArg
--              :       "refersToKey" "=" (value ? "true" : "false")
--              ;

        template TCS::SeparatorPArg
                :       "separator" "=" separatorSequence
                ;

        template TCS::DisambiguatePArg
                :       "disambiguate" "=" disambiguation{as = stringSymbol}
                ;

        template TCS::AutoCreatePArg
                :       "autoCreate" "=" value
                ;

        enumerationTemplate TCS::AutoCreateKind
                :       #always         = "always",
                        #ifmissing      = "ifmissing",
                        #never          = "never"
                ;

        template TCS::ImportContextPArg
                :       "importContext"
                ;
                
        template TCS::PartialPArg
                :       "partial"
                ;       

        template TCS::ForcedLowerPArg
                :       "forcedLower" "=" value
                ;
                
        template TCS::ForcedUpperPArg
                :       "forcedUpper" "=" value
                ;

        template TCS::CreateAsPArg
                :       "createAs" "=" name{as = identifierOrKeyword, separator = "::"}
                ;

        template TCS::QueryPArg
                :       "query" "=" query{as = stringSymbol}
                ;
                
        template TCS::FilterPArg
                :       "filter" "=" filter{as = stringSymbol} (isDefined(invert) ? "," "invert" "=" invert{as = stringSymbol})
                ;

        template TCS::ModePArg
                :       "mode" "=" mode{as = identifierOrKeyword}
                ;
-- @end Property Arguments


-- @begin Block Arguments

        template TCS::BlockArg abstract;

/** TODO: Properties not specified within the metamodel  
        template TCS::NbNLBArg -- Number of New Line
                :       "nbNL" "=" value --int
                ;

        template TCS::IndentIncrBArg
                :       "indentIncr" "=" value --int
                ;

        template TCS::StartNLBArg  -- newlines before block
                :       "startNL" "=" (value ? "true" : "false")  --boolean
                ;

        template TCS::StartNbNLBArg
                :       "startNbNL" "=" value --int 
                ;

        template TCS::EndNLBArg -- one newline after block plus indent -1
                :       "endNL" "=" (value ? "true" : "false") --boolean
                ;
*/
-- @end Block Arguments


-- @begin Literals
--      template TCS::Literal abstract;

        template TCS::Symbol addToContext
                :       name "=" value{as = stringSymbol} (isDefined(spaces) ? ":" spaces{separator = ","}) ";"
                ;

        enumerationTemplate TCS::SpaceKind
                :       #leftSpace      =       "leftSpace",
                        #leftNone       =       "leftNone",
                        #rightSpace     =       "rightSpace",
                        #rightNone      =       "rightNone"
                ;
        template TCS::Keyword addToContext
                :       
/** TODO: Properties not specified within the metamodel  
                name "=" value{as = stringSymbol} ";"
*/               
                ;
-- @end Literals

-- @begin Operators
        template TCS::OperatorList addToContext
                :       "operators" (isDefined(name) ? name) "{" [
                                priorities
                        ] "}"
                ;

        template TCS::Priority
                :       "priority" value
                        (associativity = #left ?
                                        -- nothing
                                :
                                        "," associativity
                        )
                        "{" [
                                operators
                        ] "}"
                ;
                
        template TCS::Operator addToContext
                :       
/** TODO keyword property not defined
                		(isPostfix ? "postfix") name "="
                        (isDefined(literal) ? [[
                                literal{refersTo = name}
                        |
                                literal{refersTo = value, lookIn = #all, as = stringSymbol, autoCreate = ifmissing, createAs = Keyword}
                        ]])
                        "," arity ";"
*/
                ;
        enumerationTemplate TCS::Associativity
                :       #left           = "left",
                        #right          = "right"
                ;
-- @end Operators

-- @begin Expressions
        template TCS::Expression abstract;

        template TCS::AndExp
                :       expressions{separator = "and"}
                ;

        template TCS::AtomExp abstract;

        template TCS::EqualsExp
                :       propertyReference "=" value
                ;

        template TCS::BooleanPropertyExp
                :       propertyReference
                ;

        template TCS::IsDefinedExp
                :       "isDefined" "(" propertyReference ")"
                ;
                
        template TCS::OneExp
                :       "one" "(" propertyReference ")"
                ;

        template TCS::InstanceOfExp
                :       propertyReference "instanceOf" 
                        supertype{separator = "::"}
/**                     [[
                                supertype{as=qualifiedNameSymbolList}
                        |

                                supertype{as=identifier, forcedUpper=1, forcedLower=1} 
                        ]]
*/
                ;

--@end Expressions

-- @begin Values
        template TCS::Value abstract;

        template TCS::StringVal
                :       symbol{as = stringSymbol}
                ;
        
        template TCS::IntegerVal
                :       symbol
                ;
        
        template TCS::NegativeIntegerVal
                :       "-" symbol
                ;

        template TCS::EnumLiteralVal
                :       "#" name{as = identifierOrKeyword}
                ;
-- @end Values


-- @begin Tokens
        template TCS::Token
                :       (omitted ? "omitted") "token" name ":" pattern ";"
                ;

        template TCS::OrPattern
                :       simplePatterns{separator = "|"}
                ;

-- @begin SimplePatterns
        template TCS::SimplePattern abstract;

        template TCS::RulePattern
--              :       name "(" arguments{separator = ","} ")"
                :       rule
                ;

-- @begin Rules
        template TCS::Rule abstract;

        template TCS::WordRule
                :       "word" "("
                                "start" "=" start ","
                                "part" "=" part
                                (isDefined(end) ?
                                        "," "end" "=" end
                                )
--                              (isDefined(words) ?
--                                      "," "words" "=" "(" words{separator = ","} ")"
--                              )
                        ")"
                ;

--      template TCS::Word
--              :       name{as = stringSymbol} ":" token
--              ;

        template TCS::EndOfLineRule
                :       "endOfLine" "("
                                "start" "=" (dropStart ? "drop") start
                        ")"
                ;

        template TCS::MultiLineRule
                :       "multiLine" "("
                                "start" "=" (dropStart ? "drop") start ","
                                "end" "=" (dropEnd ? "drop") end
                                (isDefined(esc) ?
                                        "," "esc" "=" esc
                                        (isDefined(escMappings) ?
                                                "," "(" escMappings{separator = ","} ")"
                                        )
                                )
                        ")"
                ;
        
        template TCS::Mapping abstract;
        
      /** TODO: Properties not specified within the metamodel  
        template TCS::SimpleMapping
                :       key "->" value
                ;
      */      
        template TCS::WildcardMapping
                :       "." "->" "."
                ;
                
        template TCS::OctalMapping
                :       "octal"
                ;
                
        template TCS::HexadecimalMapping
                :       "hex"
                ;
-- @end Rules

--      template RuleArgument
--              :       name "=" value
--              ;

        template TCS::StringPattern
                :       name{as = stringSymbol}
                ;

        template TCS::ClassPattern
                :       "[" name "]"
                ;
-- @end SimplePatterns
-- @end Tokens
        
        symbols {
                lsquare         = "[";
                rsquare         = "]";
                dlsquare        = "[[";
                drsquare        = "]]";
                excl            = "!";
                coma            = ",";
                lparen          = "(";
                rparen          = ")";
                lcurly          = "{";
                rcurly          = "}";
                dlcurly         = "{{";
                drcurly         = "}}";
                semi            = ";";
                colon           = ":";
                dlcolon         = "::";         
                pipe            = "|";
                sharp           = "#";
                qmark           = "?";
                dollar          = "$";
                arobas          = "@";
                
                -- operator symbols
                point           = ".";
                rarrow          = "->";
                minus           = "-";
                star            = "*";
                slash           = "/";
                plus            = "+";
                eq              = "=";
                gt              = ">";
                lt              = "<";
                ge              = ">=";
                le              = "<=";
                ne              = "<>";
                larrow          = "<-";
        }
        
        -- operator for left recursive qualified names
        operators DBLCOLON{
                priority 0 {
                        opDlColon = dlcolon, 2;
                }
        }

        omitted token COMMENT   : endOfLine(start = "--");
        omitted token MULTI_LINE_COMMENT        : multiLine(start = "/**", end = "*/");

        lexer = "
%options testLiterals = false;

NL
        :       (       '\\r' '\\n'
                |       '\\n' '\\r'     //Improbable
                |       '\\r'
                |       '\\n'
                )
        {newline();$channel=HIDDEN;}
        ;

WS
        :       (       ' '
                |       '\\t'
                ){$channel=HIDDEN;}
        ;

%protected
DIGIT
        :       '0'..'9'
        ;

%protected
ALPHA
        :       'a'..'z'
        |       'A'..'Z'
        |       '_'
        //For Unicode compatibility (from 0000 to 00ff)
        |       '\\u00C0' .. '\\u00D6'
        |       '\\u00D8' .. '\\u00F6'
        |       '\\u00F8' .. '\\u00FF'
        ;
        



%protected
SNAME
        :       
//      (~ORKEYWORD)=> 
        (ALPHA) (ALPHA | DIGIT)* 
;

//QNAME_OR_NAME :
//         ( ORKEYWORD COLON ) => ORKEYWORD { _type = ORKEYWORD; }
//         |    ( SNAME DLCOLON SNAME ) => QNAME { _type = QNAME; }
//         |    (~ORKEYWORD COLON | SNAME COLON ~(COLON) ) => NAME { _type = NAME; }
//         |    ( ~ORKEYWORD | SNAME ~COLON ) => NAME { _type = NAME; }
//         |    ( '\\'' SNAME) => NAME { _type = NAME; }
//;

//%protected 
//ORKEYWORD :
//      'orKeyword'
//;

//%protected
NAME
        :       (   
                        SNAME
                |       '\\''!  // exclamation marks means to exclude the char from the token (in theory)
                        (       ESC
                        |       '\\n' {newline();}
                        |       ~('\\\\'|'\\''|'\\n') // means any other character
                        )*
                        '\\''!
                )
        ;

//%protected
//QNAME
//        : SNAME DLCOLON SNAME (DLCOLON SNAME )*
//        ;

INT
        :       (DIGIT)+
        ;

        FLOAT   :       DIGIT+ '.' DIGIT*       ;

%protected
ESC
        :       '\\\\'!
                (       'n' 
                |       'r' 
                |       't' 
                |       'b' 
                |       'f' 
                |       '\"' 
                |       '\\'' 
                |       '\\\\' 
                |       (
                                ('0'..'3')
                                (
                                :       ('0'..'7')
                                        (
                                        :       '0'..'7'
                                        )?
                                )?
                        |       ('4'..'7')
                                (
                                :       ('0'..'7')
                                )?
                        )
                                {
                                }
                )
        ;

STRING
        :       '\"'!
                (       ESC
                |       '\\n' {newline();}
                |       ~('\\\\'|'\\\"'|'\\n')  // means any other character
                )*
                '\"'!
        ;

        ";

}
