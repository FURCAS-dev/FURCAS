syntax $dslname$ {

-- place templates here (at least one main template)

 	 primitiveTemplate identifier for String default using NAME:
 	   value = "%token%";
        
 	 primitiveTemplate integerSymbol for Integer default using INT:
   	     value = "Integer.valueOf(%token%)";
	
 	 template ReplaceMe main:
  	;
-- place keywords here (optional, seldom used)

-- place symbols here (optional)
	 	
	symbols {
		lbracket	= "[";
		rbracket	= "]";
		lcurl		= "{";
		rcurl		= "}";
		langle      = "<";
		rangle      = ">";
		lparen		= "(";
		rparen		= ")";
		excl		= "!";
		equals		= "=";
		equalsEquals= "==";
		assign		= ":=";
		dot			= ".";
		ddot		= "..";
		arrow		= "->";
		pipe		= "|";
		colon		= ":";
		dcolon		= "::";
		semicolon	= ";";
		including	= "including";
		excluding	= "excluding";
		includingat	= "includingAt";
		excludingat	= "excludingAt";
		iterate		= "iterate";
		lcurl_lbrack = "{[";
		lbrack_lcurl = "[{";
		rcurl_rbrack = "}]";
		rbrack_rcurl = "]}";
		star		= "*";
	}
	
-- place operatorLists here (optional)
	
	operators Expressions {
		priority 0 {
			dotOp		= ".", 2;
			dcolonOp	= "::", 2;
			lparen		= "(", 2;
			arrowOp     = "->", 2;
			lbracketOp  = "[", 2;
		}
		priority 1 {
			equalsOp	  = "==", 2;
			equivalenceOp = "<=>", 2;
		}
		priority 2 {
			questionmark = "?", 2;
		}
	}
	
	operators TypeDefinitions {
		priority 0 {
			postfix starOp	= star, 1;
			-- postfix upperOp	= INT, 1;
		}
		priority 1 {
			bracketOp	= lbracket, 2;
			braceOp		= lcurl, 2;
			-- lowerOp		= INT, 2;
		}
	}
	

-- place tokens here (optional, except for COMMENT)
	token COMMENT	: endOfLine(start = "//");
	

-- place lexer here (optional)	
	lexer = "
	%options testLiterals = false;


NL
	:	(	'\\r' '\\n'
		|	'\\n' '\\r'	//Improbable
		|	'\\r'
		|	'\\n'
		)
	{newline();$channel=HIDDEN;}
	;

WS
	:	(	' '
		|	'\\t'
		){$channel=HIDDEN;}
	;

%protected
DIGIT
	:	'0'..'9'
	;

%protected
ALPHA
	:	'a'..'z'
	|	'A'..'Z'
	|	'_'
	//For Unicode compatibility (from 0000 to 00ff)
	|	'\\u00C0' .. '\\u00D6'
	|	'\\u00D8' .. '\\u00F6'
	|	'\\u00F8' .. '\\u00FF'
	;

%protected
SNAME
	:	(ALPHA) (ALPHA | DIGIT)*
;

BOOL	:	'true' | 'false'	;

OBJECT	:	'o:'	;

NAME
	:	(
			SNAME
		|	'\\''!
			(	
		//	ESC	|
			'\\n' {newline();}
			|	~('\\\\'|'\\\''|'\\n')
			)*
			'\\''!
		)
	;

BINARY
	:	'0x'((DIGIT | 'a'..'f' | 'A'..'F') (DIGIT | 'a'..'f' | 'A'..'F'))+
	;

protected
INT
 : (DIGIT)+
 ;

%protected
FLOAT
	:	DIGIT+ '.' DIGIT*
	;
  
RANGE_OR_INT
    :   ( INT '..' ) => INT  { _type = INT; }
    |	( INT '.' NAME ) => INT { _type = INT; }
    |   ( INT '.' ~('.'	|	'a'..'z'
					   	|	'A'..'Z'
					   	|	'_'
						//For Unicode compatibility (from 0000 to 00ff)
						|	'\\u00C0' .. '\\u00D6'
						|	'\\u00D8' .. '\\u00F6'
						|	'\\u00F8' .. '\\u00FF') )  => FLOAT { _type = FLOAT; }
    |   INT                  { _type = INT; }
    ;


DATE	:	DIGIT DIGIT DIGIT DIGIT '-' DIGIT DIGIT '-' DIGIT DIGIT ((' '|'T') DIGIT DIGIT ':' DIGIT DIGIT ':' DIGIT DIGIT
            (
              ( (',' | '.') DIGIT ) => ((',' | '.') (DIGIT)+)
              |
            )
            ('Z' | (('+'|'-') DIGIT DIGIT DIGIT DIGIT)?) )? ;

STRING
	:	'\"'!
		(	
		//ESC	|		
			'\\n' {newline();}
		|	~('\\\\'|'\"'|'\\n')
		)*
		'\"'!
	;

	"; 
}
