package com.sap.ide.cts.parser.incremental;

import static com.sap.mi.textual.parsing.textblocks.TbChangeUtil.addToBlockAt;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;

import com.sap.furcas.metamodel.TCS.ClassTemplate;
import com.sap.furcas.metamodel.TCS.Template;
import com.sap.furcas.metamodel.textblocks.AbstractToken;
import com.sap.furcas.metamodel.textblocks.TextBlock;
import com.sap.furcas.metamodel.textblocks.TextblocksPackage;
import com.sap.mi.textual.common.interfaces.IModelElementProxy;
import com.sap.mi.textual.parsing.textblocks.ModelElementFromTextBlocksFactory;
import com.sap.mi.textual.parsing.textblocks.TextBlockFactory;
import com.sap.mi.textual.parsing.textblocks.observer.TextBlockProxy;
import com.sap.mi.textual.parsing.textblocks.observer.TokenRelocationUtil;
import com.sap.mi.textual.tcs.util.TcsUtil;

public class ReuseAwareTextBlockFactoryImpl implements TextBlockFactory {

	private TextblocksPackage textblocksPackage;
	private Map<Template, TextBlockDefinition> tbDefsMap = new HashMap<Template, TextBlockDefinition>();
	private TextBlockReuseStrategy reuseStrategy;
	private ModelElementFromTextBlocksFactory modelElementFactory;
	
	

	public ReuseAwareTextBlockFactoryImpl(TextblocksPackage textblocksPackage, 
		TextBlockReuseStrategy tbReuseStrategy, ModelElementFromTextBlocksFactory modelElementFactory) {
		super();
		this.textblocksPackage = textblocksPackage;
		reuseStrategy = tbReuseStrategy;
		this.modelElementFactory = modelElementFactory;
	}

	@Override
	public TextBlock createBlock() {
		TextBlock textBlock = (TextBlock) textblocksPackage.getTextBlock()
			.refCreateInstance();
		// TODO: check versioning for incremental parsing and adapt
		// correspondingly here
		textBlock.setVersion(VersionEnum.CURRENT);
		textBlock.setOffsetRelative(true);
		textBlock.setComplete(true); // default
		textBlock.setOffset(0);
		return textBlock;
	}
	
	/**
	 * Method implemented for interface
	 * {@link ITextBlockCreator#createNewTextBlock(TextBlockProxy)}
	 */
	@Override
	public TextBlock createNewTextBlock(TextBlockProxy proxy, TextBlock parent) {
		// createModelElements(proxy);
		return instantiateBlockAndMoveTokens(proxy, parent);
	}
	
	/**
	 * Instantiates a new {@link TextBlock} for the {@link TextBlockProxy} while
	 * moving all tokens that were captured there into the new block.
	 * Furthermore it calls itself recursively to add new blocks for its
	 * subBlock Proxies.
	 * 
	 * @param newVersion
	 *            The Proxy to instatiate
	 * @param parent
	 *            The parent textblock
	 * @return the newly instantiated {@link TextBlock} for the given proxy.
	 */
	private TextBlock instantiateBlockAndMoveTokens(TextBlockProxy newVersion,
			TextBlock parent) {
		TextBlock tb = this.createBlock();
		TextBlockDefinition tbDef = getTbDef(newVersion.getTemplate());
		tb.setType(tbDef);
		tb.setSequenceElement(newVersion.getSequenceElement());
		tb.getParentAltChoices().addAll(newVersion.getAlternativeChoices());
		tb.getAdditionalTemplates().addAll(newVersion.getAdditionalTemplates());
		int endIndex = 0;
		for (Object subNode : newVersion.getSubNodes()) {
			if (subNode instanceof TextBlockProxy) {
				if (((TextBlockProxy) subNode).getSubNodes().size() > 0) {
					// do not create textBlocks for proxies that have no content
					// this may be the case for example with rules for elements
					// that have no correspondence in the concrete syntax and
					// have been generated by rules containing only property
					// inits.
					addToBlockAt(tb, endIndex++, instantiateBlockAndMoveTokens(
							(TextBlockProxy) subNode, tb));
				}
			} else if (subNode instanceof AbstractToken) {
				TokenRelocationUtil.relocateToken((AbstractToken) subNode,
						endIndex++, tb);
				reuseStrategy.notifyTokenReuse((AbstractToken) subNode);
			}
		}
		tb.getCorrespondingModelElements().addAll(
				modelElementFactory.createModelElementsFromTextBlock(newVersion));
		// Add all elements in the context to the textblock
		for (Object elementInContext : newVersion.getContextElements()) {
			if (elementInContext instanceof IModelElementProxy) {
				if (((IModelElementProxy) elementInContext).getRealObject() == null) {
					throw new IncrementalParsingException(
							"Element in context was not resolved: "
									+ elementInContext);
				}
				tb.getElementsInContext().add(
						(EObject) ((IModelElementProxy) elementInContext)
								.getRealObject());
			} else if (elementInContext instanceof EObject) {
				tb.getElementsInContext().add((EObject) elementInContext);
			}
		}
		// if the template has specified the addToContext property we need to
		// add the corresponding element
		// to the context
		if (newVersion.getTemplate() instanceof ClassTemplate) {
			if (((ClassTemplate) newVersion.getTemplate()).isIsAddToContext()) {
				// move up to the first parent textblock that has the context
				// property set
				TextBlock loopParent = parent;
				while (loopParent != null) {
					if (TcsUtil.isContext(loopParent.getType().getParseRule())) {
						loopParent.getElementsInContext().addAll(
								tb.getCorrespondingModelElements());
						break;
					}
					loopParent = loopParent.getParentBlock();
				}
			}
		}
		return tb;
	}

	/**
	 * Get the {@link TextBlockDefinition} for the given template.
	 * 
	 * @param template
	 * @return
	 */
	public TextBlockDefinition getTbDef(Template template) {
		TextBlockDefinition tbDef = tbDefsMap.get(template);
		if (tbDef == null && template != null) {
			// check if there was already a corresponding tbdef within the
			// mapping definition
			Collection<TextBlockDefinition> tbDefs = textblocksPackage
					.getTextblockdefinition()
					.getTextblockDefinitionReferencesProduction()
					.getTextBlockDefinition(template);
			if (!tbDefs.isEmpty()) {
				if (tbDefs.size() == 1) {
					tbDef = tbDefs.iterator().next();
				} else {
					// TODO What to do if there is more than one?
					// for now this case seems strange, so throw an exception
					throw new IncrementalParsingException(
							"Cannot handle more than one TextBlocksDefinition per Template!");
				}
			} else {
				tbDef = initializeTextBlockDefinition(template);
			}
			tbDefsMap.put(template, tbDef);
		}
		return tbDef;
	}

	/**
	 * Initializes a new {@link TextBlockDefinition} for the given template TODO
	 * this should actually be done during creation of the mapping model.
	 * 
	 * @param template
	 * @return
	 */
	private TextBlockDefinition initializeTextBlockDefinition(Template template) {
		TextBlockDefinition tbDef = (TextBlockDefinition) textblocksPackage
				.getTextblockdefinition().getTextBlockDefinition()
				.refCreateInstance();
		tbDef.setParseRule(template);
		((EObject) template).get___Partition()
				.assignElementIncludingChildren(tbDef);
		return tbDef;
	}
}
