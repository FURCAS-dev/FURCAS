syntax TCS{

  primitiveTemplate identifier for PrimitiveTypes::String default using NAME:value="unescapeString(%token%)";

  primitiveTemplate identifierOrKeyword for PrimitiveTypes::String using NAME orKeyword:value="unescapeString(%token%)";

  primitiveTemplate stringSymbol for PrimitiveTypes::String using STRING:value="unescapeString(%token%)",serializer="\"%value%\"";

  primitiveTemplate integerSymbol for PrimitiveTypes::Integer default using INT:value="Integer.valueOf(%token%)";

  primitiveTemplate floatSymbol for PrimitiveTypes::Double default using FLOAT:value="Double.valueOf(%token%)";

  template Model::Classifier referenceOnly
    :(isDefined(container)?container "::" name:name)
    ;
  template Model::Namespace abstract operatored(DBLCOLON);

  template Model::GeneralizableElement referenceOnly
    :name
    ;
  operatorTemplate Model::ModelElement(operators=opDlColon,source=container)referenceOnly
    :name
    ;
  template textblockdefinition::TextBlockDefinition
    :
    ;
  template TCS::ConcreteSyntax main context
    :"syntax" name (isDefined(k)?"(" "k" "=" k ")") "{" [templates (isDefined(keywords)?"keywords" "{" [keywords] "}") (isDefined(symbols)?"symbols" "{" [symbols] "}") operatorLists tokens (isDefined(lexer)?"lexer" "=" lexer{as=stringSymbol} ";")]{nbNL=2} "}"
    ;
  function reference(TCS::QualifiedNamedElement)
    :(isDefined(metaReference)?metaReference:"->" names{separator="::"})
    ;
  template TCS::Template abstract;

  template TCS::ContextTemplate abstract;

  template TCS::PrimitiveTemplate
    :"primitiveTemplate" templateName "for" $reference (isDefault?"default") "using" tokenName (orKeyword?"orKeyword") ":" "value" "=" value{as=stringSymbol} (isDefined(serializer)?"," "serializer" "=" serializer{as=stringSymbol}) ";" textBlockDefinition{forcedUpper=1}
    ;
  template TCS::EnumerationTemplate context addToContext
    :"enumerationTemplate" $reference (automatic?"auto") (isDefined(mappings)?[":" [mappings{separator=","}]{startNL=false} ";"]:";") textBlockDefinition{forcedUpper=1}
    ;
  template TCS::EnumLiteralMapping
    :literal "=" element
    ;
  template TCS::ClassTemplate context addToContext
    :"template" $reference (isReferenceOnly?"referenceOnly":(isDefined(mode)?"#" mode) (isDefined(disambiguate)?"(" "disambiguate" "=" disambiguate{as=stringSymbol} ")") (isDefined(disambiguateV3)?"(" "disambiguateV3" "=" disambiguateV3{as=stringSymbol} ")") (isMulti?"multi") (isMain?"main") (isAbstract?(isDeep?"deep") "abstract") (isOperatored?"operatored" (isDefined(operatorList)?"(" operatorList{refersTo=name} ")")) (isContext?"context" (isDefined(contextTags)?contextTags)) (isAddToContext?"addToContext") (isNonPrimary?"nonPrimary") (isDefined(prefixSequence)?"prefix" [":" [prefixSequence]{startNL=false}])) (isDefined(templateSequence)?[":" [templateSequence]{startNL=false} ";"]:";") textBlockDefinition{forcedUpper=1}
    ;
  template TCS::OperatorTemplate context addToContext
    :"operatorTemplate" $reference "(" "operators" "=" operators{refersTo=name} "," "source" "=" storeLeftSideTo (isDefined(storeOperatorTo)?"," "storeOpTo" "=" storeOperatorTo) (isDefined(storeRightSideTo)?"," "storeRightTo" "=" storeRightSideTo) (isDefined(disambiguate)?"," "disambiguate" "=" disambiguate{as=stringSymbol}) (isDefined(disambiguateV3)?"," "disambiguateV3" "=" disambiguateV3{as=stringSymbol}) ")" (isReferenceOnly?"referenceOnly":(isContext?"context" (isDefined(contextTags)?contextTags))) (isDefined(otSequence)?[":" [otSequence]{startNL=false} ";"]:";") textBlockDefinition{forcedUpper=1}
    ;
  template TCS::FunctionTemplate context addToContext
    :"function" functionName "(" $reference ")" [":" [functionSequence]{startNL=false} ";"]
    ;
  template TCS::ContextTags
    :"(" tags{separator=","} ")"
    ;
  template TCS::Sequence
    :elements
    ;
  template TCS::SequenceElement abstract;

  template TCS::LiteralRef
    :referredLiteral{refersTo=value, lookIn=#all, as=stringSymbol, autoCreate=ifmissing, createAs=Keyword} {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::PropertyReference
    :(isDefined(strucfeature)?strucfeature{refersTo=name, query="OCL:let c = #context.oclAsType(TCS::Template).metaReference in
		  				let result = c.lookupElementExtended(?) in
		  				if not (result.oclIsInvalid()) then
		  					if(result.oclIsTypeOf(Model::Attribute) or
		  							result.oclIsTypeOf(Model::Reference)
		  							or result.oclIsTypeOf(Model::StructureField)) then
		  						Bag{result}	
		  					else 		
		  						c.allSupertypes()->prepend(c)->collect(
		  							st | st.oclAsType(Model::Classifier).typedElements->select(
		  								te | 
		  									if te.oclIsTypeOf(Model::AssociationEnd) then
		  										te.oclAsType(Model::AssociationEnd).otherEnd().name = ? 
		  									else		
		  										false 
		  									endif
		  								)->collect(ae | ae.oclAsType(Model::AssociationEnd).otherEnd())
		  						)
		  					endif 
		  				else	
		  					c.allSupertypes()->prepend(c)->collect(
		  						st | st.oclAsType(Model::Classifier).typedElements->select(
		  							te | 
		  								if te.oclIsTypeOf(Model::AssociationEnd) then
		  									te.oclAsType(Model::AssociationEnd).otherEnd().name = ? 
		  								else
		  									false 
		  								endif
		  							)
		  						)->collect(ae | ae.oclAsType(Model::AssociationEnd).otherEnd()
		  					) 
		  				endif
		  					", filter="",invert="name", as=identifierOrKeyword}:"->" name{as=identifierOrKeyword})
    ;
  template TCS::Property
    :propertyReference (isDefined(propertyArgs)?"{" propertyArgs{separator=","} "}") {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::CustomSeparator
    :"<" name ">" {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::Block
    :"[" blockSequence "]" (isDefined(blockArgs)?"{" blockArgs{separator=","} "}") {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::ConditionalElement
    :"(" condition "?" thenSequence (isDefined(elseSequence)?":" elseSequence) ")" {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::Alternative
    :"[[" sequences{separator="|"} "]]" (isMulti?"*") {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::SequenceInAlternative
    :(isDefined(disambiguate)?"disambiguate" "(" disambiguate{as=stringSymbol} ")") elements
    ;
  template TCS::FunctionCall
    :"$" calledFunction{refersTo=functionName} {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::InjectorActionsBlock
    :"{{" injectorActions{separator=","} "}}" {{parentTemplate=lookIn("OCL:#context")}}
    ;
  template TCS::InjectorAction abstract;

  template TCS::PropertyInit abstract;

  template TCS::PrimitivePropertyInit
    :propertyReference (isDefault?"<-":"=") value
    ;
  template TCS::LookupPropertyInit
    :propertyReference (isDefault?"<-":"=") "lookIn" "(" value{as=stringSymbol} ")"
    ;
  template TCS::ForeachPredicatePropertyInit
    :propertyReference (isDefault?"<-":"=") "foreach" "(" value{as=stringSymbol} (isDefined(mode)?"," "mode" "=" mode{as=stringSymbol}) (isDefined(predicatesemantic)?"," predicatesemantic{separator=","}) ")"
    ;
  template TCS::PredicateSemantic
    :(isDefined(when)?"when" "=" when{as=stringSymbol} ",") (isDefined(mode)?"mode" "=" mode{as=stringSymbol} ",") "as" "=" as{as=identifierOrKeyword, query="OCL:self.foreachParent.injectorActionsBlockReference.parentTemplate.concreteSyntax.templates", filter="->select(t | 
									if(t.oclIsTypeOf(TCS::ClassTemplate)) then 
										t.oclAsType(TCS::ClassTemplate).metaReference.name = ?
										and(t.oclAsType(TCS::ClassTemplate).metaReference).allSupertypes()
											->prepend(t.oclAsType(TCS::ClassTemplate).metaReference)
											->includes(self.foreachParent.propertyReference.strucfeature.type)
										and (
											if(not self.mode.oclIsUndefined()) then
												t.oclAsType(TCS::ClassTemplate).mode = self.mode
											else
												t.oclAsType(TCS::ClassTemplate).mode = self.foreachParent.mode
											endif
										)									
									else
										if(t.oclIsTypeOf(TCS::PrimitiveTemplate)) then
											t.oclAsType(TCS::PrimitiveTemplate).templateName = ?
										else
											false
										endif
									endif)
								",invert="OCL:if self.oclIsTypeOf(TCS::ClassTemplate) then
											self.oclAsType(TCS::ClassTemplate).metaReference.name
										else 
											if self.oclIsTypeOf(TCS::PrimitiveTemplate) then
												self.oclAsType(TCS::PrimitiveTemplate).templateName
											else
												'<no name?>'
											endif
										endif"}
    ;
  template TCS::PropertyArg abstract;

  template TCS::RefersToPArg
    :"refersTo" "=" propertyName{as=identifierOrKeyword}
    ;
  template TCS::LookInPArg
    :"lookIn" "=" (propertyName="#all"?"#" "all":propertyName{as=identifierOrKeyword, separator="."})
    ;
  template TCS::CreateInPArg
    :"createIn" "=" propertyName{as=identifierOrKeyword, separator="."}
    ;
  template TCS::AsPArg
    :"as" "=" template{as=identifierOrKeyword, query="OCL:self.property.parentTemplate.concreteSyntax.templates", filter="->select(t | 
									if(t.oclIsTypeOf(TCS::ClassTemplate)) then 
										t.oclAsType(TCS::ClassTemplate).metaReference.name = ? 
										and(self.property.propertyReference.strucfeature.type.allSupertypes()
											->prepend(self.property.propertyReference.strucfeature.type)
											->includes(t.oclAsType(TCS::ClassTemplate).metaReference))
										and (
											if (not self.property.propertyArgs->select(
													arg | arg.oclIsTypeOf(TCS::ModePArg))->isEmpty()
												) 
											then
												t.oclAsType(TCS::ClassTemplate).mode = 
													self.property.propertyArgs->select(
														arg | arg.oclIsTypeOf(TCS::ModePArg))
															.oclAsType(TCS::ModePArg)->asSequence()->at(1)
													.mode
											else
												t.oclAsType(TCS::ClassTemplate).mode.oclIsUndefined()
											endif
										)
									else
										if(t.oclIsTypeOf(TCS::PrimitiveTemplate)) then
											t.oclAsType(TCS::PrimitiveTemplate).templateName = ? 
										else
											false
										endif
									endif)
								",invert="OCL:if self.oclIsTypeOf(TCS::ClassTemplate) then
											self.oclAsType(TCS::ClassTemplate).metaReference.name
										else 
											if self.oclIsTypeOf(TCS::PrimitiveTemplate) then
												self.oclAsType(TCS::PrimitiveTemplate).templateName
											else
												'<no name?>'
											endif
										endif"}
    ;
  template TCS::SeparatorPArg
    :"separator" "=" separatorSequence
    ;
  template TCS::DisambiguatePArg
    :"disambiguate" "=" disambiguation{as=stringSymbol}
    ;
  template TCS::AutoCreatePArg
    :"autoCreate" "=" value
    ;
  enumerationTemplate TCS::AutoCreateKind
    :#always="always",
      #ifmissing="ifmissing",
      #never="never"
    ;
  template TCS::ImportContextPArg
    :"importContext"
    ;
  template TCS::PartialPArg
    :"partial"
    ;
  template TCS::ForcedLowerPArg
    :"forcedLower" "=" value
    ;
  template TCS::ForcedUpperPArg
    :"forcedUpper" "=" value
    ;
  template TCS::CreateAsPArg
    :"createAs" "=" name{as=identifierOrKeyword, separator="::"}
    ;
  template TCS::QueryPArg
    :"query" "=" query{as=stringSymbol}
    ;
  template TCS::FilterPArg
    :"filter" "=" filter{as=stringSymbol} (isDefined(invert)?"," "invert" "=" invert{as=stringSymbol})
    ;
  template TCS::ModePArg
    :"mode" "=" mode{as=identifierOrKeyword}
    ;
  template TCS::BlockArg abstract;

  template TCS::NbNLBArg
    :"nbNL" "=" value
    ;
  template TCS::IndentIncrBArg
    :"indentIncr" "=" value
    ;
  template TCS::StartNLBArg
    :"startNL" "=" (value?"true":"false")
    ;
  template TCS::StartNbNLBArg
    :"startNbNL" "=" value
    ;
  template TCS::EndNLBArg
    :"endNL" "=" (value?"true":"false")
    ;
  template TCS::Symbol addToContext
    :name "=" value{as=stringSymbol} (isDefined(spaces)?":" spaces{separator=","}) ";"
    ;
  enumerationTemplate TCS::SpaceKind
    :#leftSpace="leftSpace",
      #leftNone="leftNone",
      #rightSpace="rightSpace",
      #rightNone="rightNone"
    ;
  template TCS::Keyword addToContext
    :name "=" value{as=stringSymbol} ";"
    ;
  template TCS::OperatorList addToContext
    :"operators" (isDefined(name)?name) "{" [priorities] "}"
    ;
  template TCS::Priority
    :"priority" value (associativity=#left?:"," associativity) "{" [operators] "}"
    ;
  template TCS::Operator addToContext
    :(isPostfix?"postfix") name "=" (isDefined(literal)?[[literal{refersTo=name}| literal{refersTo=value, lookIn=#all, as=stringSymbol, autoCreate=ifmissing, createAs=Keyword}]]) "," arity ";"
    ;
  enumerationTemplate TCS::Associativity
    :#left="left",
      #right="right"
    ;
  template TCS::Expression abstract;

  template TCS::AndExp
    :expressions{separator="and"}
    ;
  template TCS::AtomExp abstract;

  template TCS::EqualsExp
    :propertyReference "=" value
    ;
  template TCS::BooleanPropertyExp
    :propertyReference
    ;
  template TCS::IsDefinedExp
    :"isDefined" "(" propertyReference ")"
    ;
  template TCS::OneExp
    :"one" "(" propertyReference ")"
    ;
  template TCS::InstanceOfExp
    :propertyReference "instanceOf" supertype{separator="::"}
    ;
  template TCS::Value abstract;

  template TCS::StringVal
    :symbol{as=stringSymbol}
    ;
  template TCS::IntegerVal
    :symbol
    ;
  template TCS::NegativeIntegerVal
    :"-" symbol
    ;
  template TCS::EnumLiteralVal
    :"#" name{as=identifierOrKeyword}
    ;
  template TCS::Token
    :(isOmitted?"omitted") "token" name ":" pattern ";"
    ;
  template TCS::OrPattern
    :simplePatterns{separator="|"}
    ;
  template TCS::SimplePattern abstract;

  template TCS::RulePattern
    :rule
    ;
  template TCS::Rule abstract;

  template TCS::WordRule
    :"word" "(" "start" "=" start "," "part" "=" part (isDefined(end)?"," "end" "=" end) ")"
    ;
  template TCS::EndOfLineRule
    :"endOfLine" "(" "start" "=" (dropStart?"drop") start ")"
    ;
  template TCS::MultiLineRule
    :"multiLine" "(" "start" "=" (dropStart?"drop") start "," "end" "=" (dropEnd?"drop") end (isDefined(esc)?"," "esc" "=" esc (isDefined(escMappings)?"," "(" escMappings{separator=","} ")")) ")"
    ;
  template TCS::Mapping abstract;

  template TCS::SimpleMapping
    :key "->" value
    ;
  template TCS::WildcardMapping
    :"." "->" "."
    ;
  template TCS::OctalMapping
    :"octal"
    ;
  template TCS::HexadecimalMapping
    :"hex"
    ;
  template TCS::StringPattern
    :name{as=stringSymbol}
    ;
  template TCS::ClassPattern
    :"[" name "]"
    ;
  symbols{
    lsquare="[";
    rsquare="]";
    dlsquare="[[";
    drsquare="]]";
    excl="!";
    coma=",";
    lparen="(";
    rparen=")";
    lcurly="{";
    rcurly="}";
    dlcurly="{{";
    drcurly="}}";
    semi=";";
    colon=":";
    dlcolon="::";
    pipe="|";
    sharp="#";
    qmark="?";
    dollar="$";
    arobas="@";
    point=".";
    rarrow="->";
    minus="-";
    star="*";
    slash="/";
    plus="+";
    eq="=";
    gt=">";
    lt="<";
    ge=">=";
    le="<=";
    ne="<>";
    larrow="<-";
  }

  operators DBLCOLON{
    priority 0{
      opDlColon=dlcolon,2;
    }
  }

  omitted token COMMENT:endOfLine(start="--");

  lexer=

  "
%options testLiterals = false;

NL
	:	(	'\\r' '\\n'
		|	'\\n' '\\r'	//Improbable
		|	'\\r'
		|	'\\n'
		)
	{newline();$channel=HIDDEN;}
	;

WS
	:	(	' '
		|	'\\t'
		){$channel=HIDDEN;}
	;

%protected
DIGIT
	:	'0'..'9'
	;

%protected
ALPHA
	:	'a'..'z'
	|	'A'..'Z'
	|	'_'
	//For Unicode compatibility (from 0000 to 00ff)
	|	'\\u00C0' .. '\\u00D6'
	|	'\\u00D8' .. '\\u00F6'
	|	'\\u00F8' .. '\\u00FF'
	;
	



%protected
SNAME
	:	(ALPHA) (ALPHA | DIGIT)* 
;


NAME
	:	(   
		SNAME
		|	'\\''!  // exclamation marks means to exclude the char from the token (in theory)
			(	ESC
			|	'\\n' {newline();}
			|	~('\\\\'|'\\''|'\\n') // means any other character
			)*
			'\\''!
		)
	;
	

INT
	:	(DIGIT)+
	;

	FLOAT	:	DIGIT+ '.' DIGIT*	;

%protected
ESC
	:	'\\\\'!
		(	'n' 
		|	'r' 
		|	't' 
		|	'b' 
		|	'f' 
		|	'\"' 
		|	'\\'' 
		|	'\\\\' 
		|	(
				('0'..'3')
				(
				:	('0'..'7')
					(
					:	'0'..'7'
					)?
				)?
			|	('4'..'7')
				(
				:	('0'..'7')
				)?
			)
				{
				}
		)
	;

STRING
	:	'\"'!
		(	ESC
		|	'\\n' {newline();}
		|	~('\\\\'|'\\\"'|'\\n')  // means any other character
		)*
		'\"'!
	;

	";
}